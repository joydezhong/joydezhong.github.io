[{"title":"async/await和generator函数","date":"2021-11-26T14:54:00.000Z","path":"2021/11/26/asyncawait函数/","text":"promise的用法示例： 12345Promise.resolve(a).then(b =&gt; &#123; // do someting&#125;).then(c =&gt; &#123; // do someting&#125;) 换为async/await用法示例： 12345async () =&gt; &#123; const a = await Promise.resolve(a) const b = await Promise.resolve(b) const c = await Promise.resolve(c)&#125; 换为Generator函数的写法： 1234567891011function *myGenerator() &#123; yield &#x27;1&#x27;; yield &#x27;2&#x27;; return &#x27;3&#x27;;&#125;const genFn = myGenerator();genFn.next(); // &#123;value: &#x27;1&#x27;, done: false&#125;genFn.next(); // &#123;value: &#x27;2&#x27;, done: false&#125;genFn.next(); // &#123;value: &#x27;3&#x27;, done: true&#125;genFn.next(); // &#123;value: undefined, done: true&#125; 还可以通过next方法传入参数，让Generator函数的yield语句具有返回值。 12345678910function *myGenerator() &#123; console.log(yield &#x27;1&#x27;); // test1 console.log(yield &#x27;2&#x27;); // test2 console.log(yield &#x27;3&#x27;); // test3&#125;const genFn = myGenerator();genFn.next(&#x27;test1&#x27;);genFn.next(&#x27;test2&#x27;);genFn.next(&#x27;test3&#x27;); 不同点： async/await是自动执行，不需要手动调用next()执行下一步骤。 async返回的是Promise对象，Generator函数返回生成器对象。 await能够返回Promise执行resolve/reject的值。 一、自动执行/手动执行 手动执行 1234567891011121314151617181920function *myGenerator() &#123; yield Promise.resolve(&#x27;a&#x27;); yield Promise.resolve(&#x27;b&#x27;); yield Promise.resolve(&#x27;c&#x27;);&#125;const gen = myGenerator();gen.next().value.then(a =&gt; &#123; console.log(a); gen.next().value.then(b =&gt; &#123; console.log(b); gen.next().value.then(c =&gt; &#123; console.log(c) &#125; &#125;)&#125;)// a// b// c 自动执行 123456789101112131415161718192021function run(generator) &#123; const gen = generator(); function _next(value) &#123; const result = gen.next(); if(result.done) return result.value; result.value.then(res =&gt; &#123; _next(res); &#125;) &#125; _next();&#125;function *generator()&#123; console.log(yield Promise.resolve(&#x27;a&#x27;)); console.log(yield Promise.resolve(&#x27;b&#x27;)); console.log(yield Promise.resolve(&#x27;c&#x27;));&#125;;run(generator);// a// b// c 二、返回Promise和捕获异常 12345678910111213141516171819202122232425262728293031323334353637function run(generator) &#123; return new Promise((resolve, reject) =&gt; &#123; var gen = generator(); function _next(val) &#123; try &#123; var result = gen.next(val); &#125; catch (error) &#123; return reject(error); &#125; if(result.done) &#123; return resolve(result.value); &#125; Promise.resolve(result.value).then(res =&gt; &#123; _next(res); &#125;, error =&gt; &#123; gen.throw(error); &#125;) &#125; _next(); &#125;)&#125;// 测试使用function* myGenerator() &#123; try &#123; console.log(yield Promise.resolve(1)) console.log(yield 2) //2 console.log(yield Promise.reject(&#x27;error&#x27;)) &#125; catch (error) &#123; console.log(error) &#125;&#125;const value = run(myGenerator);// 1// 2// error Generator 结合上面说的async/await不同点，我们可以知道Generator具有的特点 调用Generator函数，并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器(iterator)对象。 可以分段执行，通过调用next()方法，执行下一个步骤。 next()方法固定的返回一个对象，对象里面的value是当前步骤yield后面的值，done可以判断Generator函数是否执行完毕。 一、switch 模拟 缺点需要每次传参 12345678910111213141516function gen$(nextStep) &#123; while(1) &#123; switch (nextStep) &#123; case 0: return &#x27;result1&#x27;; case 2: return &#x27;result2&#x27;; case 4: return &#x27;result3&#x27;; case 6: return undefined; &#125; &#125;&#125;console.log(gen$(2)); // result2 二、闭包，无需传参，调用一次，执行一次 1234567891011121314151617181920212223242526function gen$2() &#123; var nextStep = 0; return function ()&#123; while(1) &#123; switch (nextStep) &#123; case 0: nextStep = 2; return &#x27;result1&#x27;; case 2: nextStep = 4; return &#x27;result2&#x27;; case 4: nextStep = 6; return &#x27;result3&#x27;; case 6: return undefined; &#125; &#125; &#125;&#125;const fn = gen$2()fn(); // result1fn(); // result2fn(); // result3fn(); // undefined 三、使用全局变量控制 12345678910111213141516171819202122var context = &#123; next: 0, prev: 0&#125;function gen$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return &#x27;result1&#x27;; case 2: _context.next = 4; return &#x27;result2&#x27;; case 4: _context.next = 6; return &#x27;result3&#x27;; case 6: return undefined; &#125; &#125;&#125; 四、next()方法改变执行步骤 12345678910111213141516171819202122232425262728293031var context = &#123; next: 0, prev: 0&#125;function gen$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return &#x27;result1&#x27;; case 2: _context.next = 4; return &#x27;result2&#x27;; case 4: _context.next = 6; return &#x27;result3&#x27;; case 6: return undefined; &#125; &#125;&#125;var gen = function() &#123; return &#123; next: function() &#123; value = gen$(context); return value; &#125; &#125;&#125; 五、添加状态和改变状态并返回一个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function gen$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return &#x27;result1&#x27;; case 2: _context.next = 4; return &#x27;result2&#x27;; case 4: _context.next = 6; return &#x27;result3&#x27;; case 6: case &#x27;end&#x27;: return _context.stop(); &#125; &#125;&#125;var context = &#123; next: 0, prev: 0, done: false, stop: function stop() &#123; this.done = true &#125;&#125;let gen = function() &#123; return &#123; next: function() &#123; value = context.done ? undefined : gen$(context) done = context.done return &#123; value, done &#125; &#125; &#125;&#125;var g = gen()console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next()) 参考： https://juejin.cn/post/6844904096525189128#heading-14 https://zhuanlan.zhihu.com/p/216060145","tags":[{"name":"async","slug":"async","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/async/"},{"name":"await","slug":"await","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/await/"},{"name":"generator","slug":"generator","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/generator/"}]},{"title":"简单的实现手写Promise","date":"2021-11-12T13:44:00.000Z","path":"2021/11/12/promise/","text":"在前端工作中，Promise是必不可以，在面试过程中当然也是必考的知识点之一，甚至更有，直接给出一张白纸，请手写一个Promise。 1、两个状态 123456789101112131415161718192021222324252627282930313233class MyPromise &#123; constructor(executor) &#123; // 初始化值 this.initValue() // 初始化this指向 this.initBind() // 执行回调传进来的函数 executor(this.resolve, this.reject) &#125; initBind() &#123; this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; initValue() &#123; // 初始化值 this.PromiseResult = null // promise结果值 this.PromiseState = &#x27;pending&#x27; // 等待中 &#125; resolve(value) &#123; // 若执行resolve，状态变为fulfilled this.PromiseState = &#x27;fulfilled&#x27; this.PromiseResult = value &#125; reject(reason) &#123; // 若执行reject，状态变更为rejected this.PromiseState = &#x27;rejected&#x27; this.PromiseResult = reason &#125;&#125; 2、状态不可逆 12345678910111213141516171819202122232425262728293031323334353637class MyPromise &#123; constructor(executor) &#123; // 初始化值 this.initValue() // 初始化this指向 this.initBind() // 执行回调传进来的函数 executor(this.resolve, this.reject) &#125; initBind() &#123; this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; initValue() &#123; // 初始化值 this.PromiseResult = null // promise结果值 this.PromiseState = &#x27;pending&#x27; // 等待中 &#125; resolve(value) &#123; // 状态不可逆 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行resolve，状态变为fulfilled this.PromiseState = &#x27;fulfilled&#x27; this.PromiseResult = value &#125; reject(reason) &#123; // 状态不可变逆 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行reject，状态变更为rejected this.PromiseState = &#x27;rejected&#x27; this.PromiseResult = reason &#125;&#125; 3、出现异常，状态rejected 123456789101112131415161718192021222324252627282930313233343536373839404142class MyPromise &#123; constructor(executor) &#123; // 初始化值 this.initValue() // 初始化this指向 this.initBind() // 捕获异常 状态变为rejected try &#123; // 执行回调传进来的函数 executor(this.resolve, this.reject) &#125; catch (error) &#123; this.reject(error) &#125; &#125; initBind() &#123; this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; initValue() &#123; // 初始化值 this.PromiseResult = null // promise结果值 this.PromiseState = &#x27;pending&#x27; // 等待中 &#125; resolve(value) &#123; // 状态不可变更 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行resolve，状态变为fulfilled this.PromiseState = &#x27;fulfilled&#x27; this.PromiseResult = value &#125; reject(reason) &#123; // 状态不可变更 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行reject，状态变更为rejected this.PromiseState = &#x27;rejected&#x27; this.PromiseResult = reason &#125;&#125; 4、then的两个回调函数 1234567891011121314// ......then(onFulFilled, onRejected) &#123; // 校验then参数函数的类型 onFulFilled = typeof onFulFilled === &#x27;function&#x27; ? onFulFilled : val =&gt; val onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; if(this.PromiseState === &#x27;fulfilled&#x27;) &#123; // 成功状态执行成功回调 onFulFilled(this.PromiseResult) &#125; else if(this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult) &#125;&#125;// ...... 5、支持异步和多次调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class MyPromise &#123; constructor(executor) &#123; // 初始化值 this.initValue() // 初始化this指向 this.initBind() // 捕获异常 状态变为rejected this.onFulfilledCallback = [];//成功的回调数组 this.onRejectedCallback = []; //失败的回调数组 try &#123; // 执行回调传进来的函数 executor(this.resolve, this.reject) &#125; catch (error) &#123; this.reject(error) &#125; &#125; initBind() &#123; this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; initValue() &#123; // 初始化值 this.PromiseResult = null // promise结果值 this.PromiseState = &#x27;pending&#x27; // 等待中 &#125; resolve(value) &#123; // 状态不可变更 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行resolve，状态变为fulfilled this.PromiseState = &#x27;fulfilled&#x27; this.PromiseResult = value this.onFulfilledCallback.forEach(fn =&gt; fn(value)) &#125; reject(reason) &#123; // 状态不可变更 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行reject，状态变更为rejected this.PromiseState = &#x27;rejected&#x27; this.PromiseResult = reason this.onRejectedCallback.forEach(fn =&gt; fn(reason)) &#125; then(onFulFilled, onRejected) &#123; // 校验then参数函数的类型 onFulFilled = typeof onFulFilled === &#x27;function&#x27; ? onFulFilled : val =&gt; val onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; if(this.PromiseState === &#x27;fulfilled&#x27;) &#123; // 成功状态执行成功回调 onFulFilled(this.PromiseResult) &#125; else if(this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult) &#125; else if(this.PromiseState === &#x27;pending&#x27;) &#123; typeof onFulFilled === &#x27;function&#x27; &amp;&amp; this.onFulfilledCallback.push(onFulFilled) typeof onRejected === &#x27;function&#x27; &amp;&amp; this.onRejectedCallback.push(onRejected) &#125; &#125;&#125; 6、链式回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143class MyPromise &#123; constructor(executor) &#123; // 初始化值 this.initValue() // 初始化this指向 this.initBind() // 捕获异常 状态变为rejected this.onFulfilledCallback = [];//成功的回调数组 this.onRejectedCallback = []; //失败的回调数组 try &#123; // 执行回调传进来的函数 executor(this.resolve, this.reject) &#125; catch (error) &#123; this.reject(error) &#125; &#125; initBind() &#123; this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) &#125; initValue() &#123; // 初始化值 this.PromiseResult = null // promise结果值 this.PromiseState = &#x27;pending&#x27; // 等待中 &#125; resolve(value) &#123; // 状态不可变更 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行resolve，状态变为fulfilled this.PromiseState = &#x27;fulfilled&#x27; this.PromiseResult = value this.onFulfilledCallback.forEach(fn =&gt; fn(value)) &#125; reject(reason) &#123; // 状态不可变更 if(this.PromiseState !== &#x27;pending&#x27;) return // 若执行reject，状态变更为rejected this.PromiseState = &#x27;rejected&#x27; this.PromiseResult = reason this.onRejectedCallback.forEach(fn =&gt; fn(reason)) &#125; then(onFulFilled, onRejected) &#123; // 校验then参数函数的类型 onFulFilled = typeof onFulFilled === &#x27;function&#x27; ? onFulFilled : val =&gt; val onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; // 需要实现链式调用，需要在then函数中返回一个Promise并且做对应的参数判断 const _this = this const promise2 = new MyPromise((resolve, reject) =&gt; &#123; if(_this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulFilled(_this.PromiseResult) _this.resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; else if(_this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(_this.PromiseResult) _this.resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; else if(_this.PromiseState === &#x27;pending&#x27;) &#123; _this.onFulfilledCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulFilled(_this.PromiseResult) _this.resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) _this.onRejectedCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(_this.PromiseResult) _this.resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) &#125; &#125;) return promise2; &#125; /** * * @param &#123;新的promise对象&#125; promise2 * @param &#123;上一个then的返回值&#125; x * @param &#123;promise2的resolve&#125; resolve * @param &#123;promise2的reject&#125; reject */ resolvePromise(promise2, x, resolve, reject) &#123; if(promise2 === x) &#123; reject(new TypeError(&#x27;Chaining cycle.&#x27;)) &#125; if(x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let used; try &#123; let then = x.then if(typeof then === &#x27;function&#x27;) &#123; then.call(x, (y) =&gt; &#123; if(used) return; used = true this.resolvePromise(promise2, y, resolve, reject) &#125;, (r) =&gt; &#123; if(used) return; used = true reject(r) &#125;) &#125; else &#123; if(used) return; used = true resolve(x) &#125; &#125; catch (error) &#123; if(used) return; used = true reject(e) &#125; &#125; else &#123; resolve(x) &#125; &#125;&#125; 7、其他方法 7.1、all 接收一个promise数组，若数组中有非promise项，当此项为成功。 promise数组全部执行成功，则返回结果数组；有一项失败，则返回此项失败的结果。 12345678910111213141516171819static all(promises) &#123; // 结果数组 const result = [] let count = 0 return new MyPromise((resolve, reject) =&gt; &#123; const addData = (index, value) =&gt; &#123; result[index] = value count++ if (count === promises.length) resolve(result) &#125; promises.forEach((promise, index) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(index, res) &#125;, error =&gt; reject(error)) &#125; &#125;) &#125;)&#125; 7.2、race 接收一个promise数组，若数组中有非promise项，当此项为成功。 哪个Promise最快得到结果，就返回那个结果，无论成功失败。 123456789101112131415static race(promises) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, error =&gt; &#123; reject(error) &#125;) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; 7.3、allSettled 接收一个promise数组，若数组中有非promise项，当此项为成功。 把每一项Promise执行完结果的状态值，组合成数组返回。 123456789101112131415161718192021222324252627static allSettled(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let count = 0 const addData = (status, value, i) =&gt; &#123; result[i] = &#123; status, value &#125; count++ if (count === promises.length) &#123; resolve(result) &#125; &#125; promises.forEach((promise, i) =&gt; &#123; if (promise instanceof MyPromise) &#123; promise.then(res =&gt; &#123; addData(&#x27;fulfilled&#x27;, res, i) &#125;, error =&gt; &#123; addData(&#x27;rejected&#x27;, error, i) &#125;) &#125; else &#123; addData(&#x27;fulfilled&#x27;, promise, i) &#125; &#125;) &#125;)&#125; 7.4、any any和all相反，接收一个promise数组，若数组中有非promise项，当此项为成功。 若有一项执行成功，则返回成功的结果；若所有的都失败，则抛出Error错误 123456789101112131415static any(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promises.forEach((promise) =&gt; &#123; promise.then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; count++ if (count === promises.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27;)) &#125; &#125;) &#125;) &#125;)&#125;","tags":[{"name":"Promise","slug":"Promise","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Promise/"}]},{"title":"如何开始一个脚手架工程项目","date":"2021-10-28T11:44:00.000Z","path":"2021/10/28/手写脚手架/","text":"一、 初始化一个npm项目 手动创建 package.json，自行键入&quot;name、version、description、main&quot;等字段。 npm init自动生成package.json。 这里介绍下main字段的作用，看到很多文章都说“指定主入口文件”，却很少看到有详细说明的。 学过c语言的应该了解，程序的执行有个main函数，这个main函数是程序的唯一执行入口，而package.json中的main含义类似，当这个项目作为npm包给被他人安装使用时，他人引用你的模块全部从main指引的模块导出，这相对于他人即为主入口，但相对于自己项目即为主出口。 二、模块查找 在node中以require(m)的方式引入模块，那么这种引入方式是如何查找模块的呢？ 如果 m 是node的核心模块名，直接返回核心模块。 如果 m 以/ ./ ../方式开头的： 计算 m 的绝对路径 p； 如果 p 是文件，尝试以该文件的类型加载，成功则返回； 如果 p.js 是文件，当作 CommonJS 脚本加载，成功则返回； 如果 p.json 是文件，当作 json 文件加载，成功则返回； 如果 p.node 是文件，当作原生扩展模块加载，成功则返回； 以上都不成功，把 p 当作目录： 如果 p/package.json 是文件，找里面的 main 字段； 如果没有 main 字段，尝试加载 p/index.js p/index.json p/index.node； 如果有 main 字段； 计算 main 绝对路径 q，按上面的规则当作文件尝试加载 如果都失败，尝试 q/index.js q/index.json q/index.node 如果 q/package.json 不是文件，尝试加载 q/index.js q/index.json q/index.node 以上都不成功，throw not found 三、如何运行自定义命令 如何运行自定义命令，而不是使用node xxx，这时候就需要用到第一小节package.json中的bin字段了。 在node项目中，可以把Js文件当做shell脚本来执行，只需要在文件开头标明#! /usr/bin/env node表示使用nodejs解析。 下面来实现一个用自定义命令输出参数的小案例： 新建/lib/echo.js， 1234// echo.jsmodule.exports = function (message) &#123; return message;&#125;; 新建/bin/node-echo.js， 123456#! /usr/bin/env nodeconst argv = require(&#x27;argv&#x27;);const echo = require(&#x27;../lib/echo&#x27;);console.log(echo(argv.run().targets.join(&#x27; &#x27;))); 配置bin命令 123456// package.json// ...&quot;bin&quot;: &#123; &quot;node-echo&quot;: &quot;./bin/node-echo.js&quot;,&#125;,// ... 此时在终端运行node-echo命令是无效的，还需要通过npm link进行本地开发连接，当然，也可以在link后面指定模块名称，这时候指定的模块就会引入到当前项目的node_modules下面。 四、如何进行命令行交互 这里需要使用到相关工具包：命令行工具commander、交互工具inquirer、参数工具argv，借助这三个工具，我们可以实现输出项目版本信息，获取命令help提示，交互选择的功能。 编辑node-echo.js， 1234567891011121314151617181920212223242526#! /usr/bin/env node// 命令行工具const program = require(&#x27;commander&#x27;);// 命令交互工具const inquirer = require(&#x27;inquirer&#x27;);const TEMPLATE_ENUM = require(&#x27;../lib/template/templateEnum.json&#x27;);const &#123; version &#125; = require(&#x27;../package.json&#x27;);// 输出版本信息和help提示program.version(version, &#x27;-v, --version&#x27;) .usage(&#x27;&lt;command&gt; [options]&#x27;)program.command(&#x27;create&#x27;).description(&#x27;创建一个项目模板&#x27;).action(async (cmd) =&gt; &#123; const &#123; template &#125; = await inquirer.prompt([ &#123; type: &#x27;list&#x27;, name: &#x27;template&#x27;, message: &#x27;选择要使用的模板&#x27;, choices: Object.keys(TEMPLATE_ENUM) &#125; ]) console.log(&#x27;你选择了：&#x27;,template)&#125;)// 把命令行参数传给commander解析program.parse(process.argv); 模板枚举可以根据需要自行定制json格式， 1234567891011121314// templateEnum.json&#123; &quot;pc&quot;: &#123; &quot;download&quot;: &quot;xxxxxx&quot;, &quot;gitUrl&quot;: &quot;xxxxxx&quot;, &quot;repoName&quot;: &quot;template_PC&quot; &#125;, &quot;nativeApp&quot;: &#123; &quot;download&quot;: &quot;&quot; &#125;, &quot;miniApp&quot;: &#123; &quot;download&quot;: &quot;&quot; &#125;&#125; 五、拉取远程仓库代码到本地 这节拉取远程代码，涉及比较多的边界处理，仅列举部分伪代码以做说明。 123456789101112131415161718192021222324// createTemplate.jsasync create(props) &#123; // 项目name、创建路径和git仓库一些信息 const &#123; name, mkdir, gitRepo &#125; = props; try &#123; console.log(`⠋`, `下载模板中, 请稍候...`); // 返回临时数据目录 tmpdir = await fetchRemotePreset(gitRepo[&#x27;url&#x27;]); &#125; catch (e) &#123; console.error(` 下载失败`); throw e; &#125; // 将接收的模板文件 传入到目标目录中 try &#123; fs.copySync(tmpdir, context, &#123; filter: (src, dest) =&gt; &#123; return path.basename(src, &#x27;.git&#x27;) !== gitRepo.repoName &#125; &#125;); &#125; catch (error) &#123; return console.error(`Error: $&#123;error&#125;`); &#125;&#125; 在正式执远程下载前还有很多校验处理，比如： node版本是否符合要求，项目名称是否符合命名要求，当前创建目录是否为空等等。 12345678910111213141516171819202122// loadRemoteProject.jsconst fs = require(&#x27;fs-extra&#x27;);module.exports = async function fetchRemotePreset(name, clone = false) &#123; const os = require(&#x27;os&#x27;); const path = require(&#x27;path&#x27;); const download = require(&#x27;./gitDownloadRepo&#x27;); // 生成临时目录, 方便后续中间件对其抓取下来的模板进行处理 const tmpdir = path.resolve(os.tmpdir(), &#x27;node-echo&#x27;); // 将临时目录的内容先清空， 否则无法写入正常的拉取后的文件 await fs.remove(tmpdir); return new Promise((resolve, reject) =&gt; &#123; download(name, tmpdir, &#123; clone &#125;, err =&gt; &#123; if (err) &#123; return reject(err); &#125; return resolve(tmpdir); &#125;); &#125;);&#125;; 借助一些工具包，对远程项目下载，由于安全机制问题，先下载到对应的系统临时文件下，再通过fs模块复制到对应的项目目录中去。 此外，还需要一些终端字符输出美化，终端清空，版本升级提示等，才能让这个脚手架工具更加完美。 详细代码参考：https://github.com/joydezhong/simpleCli-template.git","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/NodeJs/"}]},{"title":"antd源码解析之Avatar","date":"2021-07-23T13:02:00.000Z","path":"2021/07/23/antd_avatar/","text":"Avatar音译‘阿凡达’，释义头像或某事物的化身，支持文字、Icon、图片、远程图片，解析源码前先来看看所需参数。 Avatar作为独立组件时： API参数 123456789101112131415161718192021222324export interface AvatarProps &#123; /** 指定头像形状：圆形，方形 */ shape?: &#x27;circle&#x27; | &#x27;square&#x27;; /** 指定头像大小：大，小，默认 */ size?: AvatarSize; /** 字符类型距离左右两侧边界单位像素 */ gap?: number; /** 图片资源路径或图片元素 */ src?: React.ReactNode; /** 图片资源链接 */ srcSet?: string; /** 图片是否拖拽 */ draggable?: boolean; /** 头像的Icon图标 */ icon?: React.ReactNode; style?: React.CSSProperties; prefixCls?: string; className?: string; children?: React.ReactNode; /** 图片加载失败的替换文字 */ alt?: string; /** 图片加载失败的回调 */ onError?: () =&gt; boolean;&#125; 部分主要代码 这个组件采用函数式编程的写法，在这只列举部分主要的代码，一些动态css代码以省略号代替，完整源码请参考官方库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148const InternalAvatar: React.ForwardRefRenderFunction&lt;unknown, AvatarProps&gt; = (props, ref) =&gt; &#123; /** 组内嵌套使用时 Group中Context的size */ const groupSize = React.useContext(SizeContext); const [scale, setScale] = React.useState(1); const [mounted, setMounted] = React.useState(false); const [isImgExist, setIsImgExist] = React.useState(true); const avatarNodeRef = React.useRef&lt;HTMLElement&gt;(); const avatarChildrenRef = React.useRef&lt;HTMLElement&gt;(); const avatarNodeMergeRef = composeRef(ref, avatarNodeRef); const &#123; getPrefixCls &#125; = React.useContext(ConfigContext); const setScaleParam = () =&gt; &#123; if (!avatarChildrenRef.current || !avatarNodeRef.current) &#123; return; &#125; const childrenWidth = avatarChildrenRef.current.offsetWidth; const nodeWidth = avatarNodeRef.current.offsetWidth; if (childrenWidth !== 0 &amp;&amp; nodeWidth !== 0) &#123; const &#123; gap = 4 &#125; = props; if (gap * 2 &lt; nodeWidth) &#123; setScale(nodeWidth - gap * 2 &lt; childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1); &#125; &#125; &#125;; React.useEffect(() =&gt; &#123; setMounted(true); &#125;, []); React.useEffect(() =&gt; &#123; setIsImgExist(true); setScale(1); &#125;, [props.src]); React.useEffect(() =&gt; &#123; setScaleParam(); &#125;, [props.gap]); const handleImgLoadError = () =&gt; &#123; const &#123; onError &#125; = props; const errorFlag = onError ? onError() : undefined; if (errorFlag !== false) &#123; setIsImgExist(false); &#125; &#125;; const &#123; prefixCls: customizePrefixCls, shape, size: customSize, src, srcSet, icon, className, alt, draggable, children, ...others &#125; = props; const size = customSize === &#x27;default&#x27; ? groupSize : customSize; const screens = useBreakpoint(); // ...responsiveSizeStyle... // ...devWarning... // ...prefixCls... // ...sizeCls... const hasImageElement = React.isValidElement(src); // ...classString... // ...sizeStyle... let childrenToRender; if (typeof src === &#x27;string&#x27; &amp;&amp; isImgExist) &#123; childrenToRender = ( &lt;img src=&#123;src&#125; draggable=&#123;draggable&#125; srcSet=&#123;srcSet&#125; onError=&#123;handleImgLoadError&#125; alt=&#123;alt&#125; /&gt; ); &#125; else if (hasImageElement) &#123; childrenToRender = src; &#125; else if (icon) &#123; childrenToRender = icon; &#125; else if (mounted || scale !== 1) &#123; const transformString = `scale($&#123;scale&#125;) translateX(-50%)`; const childrenStyle: React.CSSProperties = &#123; msTransform: transformString, WebkitTransform: transformString, transform: transformString, &#125;; const sizeChildrenStyle: React.CSSProperties = typeof size === &#x27;number&#x27; ? &#123; lineHeight: `$&#123;size&#125;px`, &#125; : &#123;&#125;; childrenToRender = ( &lt;ResizeObserver onResize=&#123;setScaleParam&#125;&gt; &lt;span className=&#123;`$&#123;prefixCls&#125;-string`&#125; ref=&#123;(node: HTMLElement) =&gt; &#123; avatarChildrenRef.current = node; &#125;&#125; style=&#123;&#123; ...sizeChildrenStyle, ...childrenStyle &#125;&#125; &gt; &#123;children&#125; &lt;/span&gt; &lt;/ResizeObserver&gt; ); &#125; else &#123; childrenToRender = ( &lt;span className=&#123;`$&#123;prefixCls&#125;-string`&#125; style=&#123;&#123; opacity: 0 &#125;&#125; ref=&#123;(node: HTMLElement) =&gt; &#123; avatarChildrenRef.current = node; &#125;&#125; &gt; &#123;children&#125; &lt;/span&gt; ); &#125; delete others.onError; delete others.gap; return ( &lt;span &#123;...others&#125; style=&#123;&#123; ...sizeStyle, ...responsiveSizeStyle, ...others.style &#125;&#125; className=&#123;classString&#125; ref=&#123;avatarNodeMergeRef as any&#125; &gt; &#123;childrenToRender&#125; &lt;/span&gt; );&#125;;const Avatar = React.forwardRef&lt;unknown, AvatarProps&gt;(InternalAvatar);Avatar.displayName = &#x27;Avatar&#x27;;Avatar.defaultProps = &#123; shape: &#x27;circle&#x27; as AvatarProps[&#x27;shape&#x27;], size: &#x27;default&#x27; as AvatarProps[&#x27;size&#x27;],&#125;;export default Avatar; ① 使用React.forwardRef接收一个函数式组件InternalAvatar，两个参数props、ref，这个React API可以把ref转发到组件树的任意一个组件中，在组件树的任意组件中即可操作父组件传过来的ref。 ② 使用React.isValidElement方法验证是否是react图片元素，通过ResizeObserver组件的api回调来计算缩放比例，实现响应式尺寸。 ③ 当传入的参数不在约定规则之内时，渲染对应的children，并置为透明隐藏。 与Avatar.Group嵌套使用时： API参数 1234567891011121314export interface GroupProps &#123; className?: string; children?: React.ReactNode; style?: React.CSSProperties; prefixCls?: string; /** 显示的最大头像个数 */ maxCount?: number; /** 多余头像样式 */ maxStyle?: React.CSSProperties; /** 多余头像气泡弹出位置 */ maxPopoverPlacement?: &#x27;top&#x27; | &#x27;bottom&#x27;; /** 自定义组内头像的大小 */ size?: AvatarSize;&#125; Group中代码相对较少，这里全部列举出来，有两点需要分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const Group: React.FC&lt;GroupProps&gt; = props =&gt; &#123; const &#123; getPrefixCls, direction &#125; = React.useContext(ConfigContext); const &#123; prefixCls: customizePrefixCls, className = &#x27;&#x27;, maxCount, maxStyle, size &#125; = props; const prefixCls = getPrefixCls(&#x27;avatar-group&#x27;, customizePrefixCls); const cls = classNames( prefixCls, &#123; [`$&#123;prefixCls&#125;-rtl`]: direction === &#x27;rtl&#x27;, &#125;, className, ); const &#123; children, maxPopoverPlacement = &#x27;top&#x27; &#125; = props; const childrenWithProps = toArray(children).map((child, index) =&gt; cloneElement(child, &#123; key: `avatar-key-$&#123;index&#125;`, &#125;), ); const numOfChildren = childrenWithProps.length; if (maxCount &amp;&amp; maxCount &lt; numOfChildren) &#123; const childrenShow = childrenWithProps.slice(0, maxCount); const childrenHidden = childrenWithProps.slice(maxCount, numOfChildren); childrenShow.push( &lt;Popover key=&quot;avatar-popover-key&quot; content=&#123;childrenHidden&#125; trigger=&quot;hover&quot; placement=&#123;maxPopoverPlacement&#125; overlayClassName=&#123;`$&#123;prefixCls&#125;-popover`&#125; &gt; &lt;Avatar style=&#123;maxStyle&#125;&gt;&#123;`+$&#123;numOfChildren - maxCount&#125;`&#125;&lt;/Avatar&gt; &lt;/Popover&gt;, ); return ( &lt;SizeContextProvider size=&#123;size&#125;&gt; &lt;div className=&#123;cls&#125; style=&#123;props.style&#125;&gt; &#123;childrenShow&#125; &lt;/div&gt; &lt;/SizeContextProvider&gt; ); &#125; return ( &lt;SizeContextProvider size=&#123;size&#125;&gt; &lt;div className=&#123;cls&#125; style=&#123;props.style&#125;&gt; &#123;childrenWithProps&#125; &lt;/div&gt; &lt;/SizeContextProvider&gt; );&#125;;export default Group; ① 利用props.children获取组件的子链，对子链（react元素）遍历，然后使用React.cloneElement()方法以子链元素为样本克隆一份，可以把新传入的props和旧的props进行合并。 ② 父组件使用Context保存size配置，下面子组件Avatar可以使用Group中的size数据。","tags":[]},{"title":"前端自动化部署方案二","date":"2021-07-02T12:40:00.000Z","path":"2021/07/02/自动化部署二/","text":"这是前端自动化部署方案一windows系统的姊妹篇Linux系统自动化部署解决方案，不得不说，Linux在这里的优势显而易见。 服务端 更新并升级安装源，安装ssh服务 123sudo apt updatesudo apt upgradesudo apt-get install openssh-server 启动服务后，需要设置用户名密码 1234sudo service ssh start 启动服务sudo service ssh stop 关闭服务sudo service sshd reload [停止进程后重启] ==&gt; 推荐sudo service sshd restart [干掉进程后重启] ==&gt; 不推荐 客户端 利用node-ssh进行SSH连接、文件传输、远程执行shell脚本，利用archiver执行文件压缩操作。 1.导入模块 1234const path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);const archiver = require(&#x27;archiver&#x27;);const &#123;NodeSSH&#125; = require(&#x27;node-ssh&#x27;); 2.初始化ssh和配置项 123456789101112131415161718const ssh = new NodeSSH();const config = &#123; /**路径 */ path: &#123; romotePath: &#x27;/home/dalao/Projects/www&#x27;, localPath: &#x27;./build&#x27; &#125;, /**压缩文件名 */ compressName: &#x27;Compression.zip&#x27;, /**远程连接配置 */ romote: &#123; host: &#x27;10.0.0.87&#x27;, port: 22, username: &#x27;dalao&#x27;, password: &#x27;123456&#x27;, &#125;&#125; 3.压缩文件 1234567891011121314151617181920212223242526272829303132const createZip = async () =&gt; &#123; try &#123; console.log(&#x27;压缩中...&#x27;) return await new Promise((resolve, reject) =&gt; &#123; // 创建最终打包文件的输出流 const output = fs.createWriteStream(`$&#123;process.cwd()&#125;/Compression.zip`) // 生成archiver对象，打包类型为zip const archive = archiver(&#x27;zip&#x27;, &#123; zlib: &#123; level: 9 &#125; // Sets the compression level. &#125;); output.on(&#x27;close&#x27;, (e) =&gt; &#123; if (e) &#123; console.log(&#x27;压缩失败：&#x27; + e) reject(e) process.exit(1) &#125; else &#123; console.log(&#x27;Compression.zip 打包成功&#x27;) resolve(&#123;code: 1, msg: &#x27;开始装载上传...&#x27;&#125;) &#125; &#125;) // 将打包对象与输出流关联 archive.pipe(output) // 从子目录追加文件，将其内容放在archive的根目录 archive.directory(config.path.localPath, false) // 结束archive archive.finalize() &#125;) &#125; catch (e) &#123; console.log(&#x27;压缩失败：&#x27; + e) process.exit(1) &#125;&#125; 4.远程部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** 远程连接 */const remoteConnect = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; ssh.connect(config.romote).then((result) =&gt; &#123; resolve(&#123; code: 1&#125;) &#125;).catch((err) =&gt; &#123; reject(err) &#125;); &#125;)&#125;/** 清除服务器缓存 */const clearServer = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; ssh.execCommand(`rm -rf $&#123;config.path.romotePath&#125;/*`).then((result) =&gt; &#123; resolve(&#123; code: 1&#125;) &#125;).catch((err) =&gt; &#123; reject(err) &#125;); &#125;)&#125;/**上传文件夹（不用压缩包）*/const uploadDir = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; ssh.putDirectory(config.path.localPath, config.path.romotePath).then((result) =&gt; &#123; resolve(&#123; code: 1 &#125;) &#125;).catch((err) =&gt; &#123; reject(err) &#125;); &#125;)&#125;/**上传压缩包 解压并删除压缩包 */const uploadFileAndUnzip = (localPath, remotePath) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; ssh.putFile(localPath, remotePath).then((result) =&gt; &#123; //@ 这里也可用用执行远程shell脚本替代 // #!/bin/bash // cd /usr1/AAA/mydemo // #删除原静态资源目录 // rm -rf public // cd /usr1/AAA // #解压新的包 // unzip public.zip // #将解压出的public目录移动到服务端程序目录BBB中 // mv public ./mydemo ssh.execCommand(`unzip $&#123;config.compressName&#125;; rm -rf $&#123;config.compressName&#125;`, &#123; cwd: config.path.romotePath &#125;).then((result) =&gt; &#123; resolve(&#123; code: 1 &#125;) &#125;).catch((err) =&gt; &#123; reject(err) &#125;); &#125;).catch((err) =&gt; &#123; reject(err) &#125;); &#125;)&#125;async function main() &#123; const res = await createZip() if(res[&#x27;code&#x27;] === 1) &#123; const connectRes = await remoteConnect() await clearServer() console.log(&#x27;远程连接中...&#x27;) if(connectRes[&#x27;code&#x27;] === 1) &#123; console.log(&#x27;连接成功，文件上传中...&#x27;) // const uploadRes = await uploadDir() const uploadRes = await uploadFileAndUnzip(`./$&#123;config.compressName&#125;`, `$&#123;config.path.romotePath&#125;/$&#123;config.compressName&#125;`) if(uploadRes[&#x27;code&#x27;] === 1) &#123; console.log(&#x27;文件上传成功&#x27;) process.exit(1) &#125; &#125; &#125;&#125;/** 执行主函数 */main()","tags":[]},{"title":"antd源码解析之Calendar","date":"2021-06-26T02:25:00.000Z","path":"2021/06/26/antd_calendar/","text":"Calendar日历，有传统可添加日程的方格形式，也有卡片的mini模式。 要解析这个组件，首先来看看它引入了哪些工具： ① 引入了moment的typescript接口。 ② 基于rc-picker组件，还引入了包括其组件在内的一些ts类型和工具函数。 ③ 引入了rc-util工具包中的useMergedState hook函数用于状态处理。 ④ 引入lodash的padStart函数用于字符串处理。 ⑤ 使用了Select组件和Radio组件内置的Group、Button。 index入口页 12345678import &#123; Moment &#125; from &#x27;moment&#x27;;import momentGenerateConfig from &#x27;rc-picker/lib/generate/moment&#x27;;import generateCalendar, &#123; CalendarProps &#125; from &#x27;./generateCalendar&#x27;;const Calendar = generateCalendar&lt;Moment&gt;(momentGenerateConfig);export &#123; CalendarProps &#125;;export default Calendar; 入口文件rc-picker组件moment工具函数的generateConfig模块，该模块内部其实就是调用node的moment模块进行一些常规操作的封装，比如：获取/设置当前时间，获取/设置年月日等。调用组件主函数generateCalendar并导出执行结果和Propr类型。 API参数 12345678910111213141516171819202122232425262728293031323334export interface CalendarProps&lt;DateType&gt; &#123; prefixCls?: string; className?: string; style?: React.CSSProperties; /** 国际化配置 */ locale?: typeof enUS; validRange?: [DateType, DateType]; /** 不可选择的日期，参数为当前 value，注意使用时不要直接修改 */ disabledDate?: (date: DateType) =&gt; boolean; /** 自定义渲染日期单元格，返回内容覆盖单元格 */ dateFullCellRender?: (date: DateType) =&gt; React.ReactNode; /** 自定义渲染日期单元格，返回内容会被追加到单元格 */ dateCellRender?: (date: DateType) =&gt; React.ReactNode; /** 自定义渲染月单元格，返回内容覆盖单元格 */ monthFullCellRender?: (date: DateType) =&gt; React.ReactNode; /** 自定义渲染月单元格，返回内容会被追加到单元格 */ monthCellRender?: (date: DateType) =&gt; React.ReactNode; /** 自定义头部内容 */ headerRender?: HeaderRender&lt;DateType&gt;; /** 展示日期 */ value?: DateType; /** 默认展示的日期 */ defaultValue?: DateType; /** 初始模式 */ mode?: CalendarMode; /** 是否全屏显示 */ fullscreen?: boolean; /** 日期变化回调 */ onChange?: (date: DateType) =&gt; void; /** 日期面板变化回调 */ onPanelChange?: (date: DateType, mode: CalendarMode) =&gt; void; /** 点击选择日期回调 */ onSelect?: (date: DateType) =&gt; void;&#125; 三个工具函数 123456789101112131415function isSameYear(date1: DateType, date2: DateType) &#123; return date1 &amp;&amp; date2 &amp;&amp; generateConfig.getYear(date1) === generateConfig.getYear(date2);&#125;function isSameMonth(date1: DateType, date2: DateType) &#123; return ( isSameYear(date1, date2) &amp;&amp; generateConfig.getMonth(date1) === generateConfig.getMonth(date2) );&#125;function isSameDate(date1: DateType, date2: DateType) &#123; return ( isSameMonth(date1, date2) &amp;&amp; generateConfig.getDate(date1) === generateConfig.getDate(date2) );&#125; 这三个函数用于判断当前选择的时间日期和之前的日期是否是处于同一天/同一月/同一年。 render函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253return ( &lt;LocaleReceiver componentName=&quot;Calendar&quot; defaultLocale=&#123;getDefaultLocale&#125;&gt; &#123;(mergedLocale: any) =&gt; ( &lt;div className=&#123;classNames( calendarPrefixCls, &#123; [`$&#123;calendarPrefixCls&#125;-full`]: fullscreen, [`$&#123;calendarPrefixCls&#125;-mini`]: !fullscreen, [`$&#123;calendarPrefixCls&#125;-rtl`]: direction === &#x27;rtl&#x27;, &#125;, className, )&#125; style=&#123;style&#125; &gt; &#123;headerRender ? ( headerRender(&#123; value: mergedValue, type: mergedMode, onChange: onInternalSelect, onTypeChange: triggerModeChange, &#125;) ) : ( &lt;CalendarHeader prefixCls=&#123;calendarPrefixCls&#125; value=&#123;mergedValue&#125; generateConfig=&#123;generateConfig&#125; mode=&#123;mergedMode&#125; fullscreen=&#123;fullscreen&#125; locale=&#123;mergedLocale.lang&#125; validRange=&#123;validRange&#125; onChange=&#123;onInternalSelect&#125; onModeChange=&#123;triggerModeChange&#125; /&gt; )&#125; &lt;RCPickerPanel value=&#123;mergedValue&#125; prefixCls=&#123;prefixCls&#125; locale=&#123;mergedLocale.lang&#125; generateConfig=&#123;generateConfig&#125; dateRender=&#123;dateRender&#125; monthCellRender=&#123;date =&gt; monthRender(date, mergedLocale.lang)&#125; onSelect=&#123;onInternalSelect&#125; mode=&#123;panelMode&#125; picker=&#123;panelMode as any&#125; disabledDate=&#123;mergedDisabledDate&#125; hideHeader /&gt; &lt;/div&gt; )&#125; &lt;/LocaleReceiver&gt;); ① 使用国际化配置组件LocaleReceiver，内部通过组件名componentName获取国际化配置数据，并传参到this.props.children()函数中。 ② 优先加载用户配置的自定义头部渲染headerRender。 ③ 若没有配置该项则渲染CalendarHeader组件，然后渲染rc-picker。 三个State状态 123456789101112131415// Current Value// 引入rc-util中的工具hook函数 状态值处理const [mergedValue, setMergedValue] = useMergedState(() =&gt; value || generateConfig.getNow(), &#123; defaultValue, value,&#125;);// Modeconst [mergedMode, setMergedMode] = useMergedState(&#x27;month&#x27;, &#123; value: mode,&#125;);const panelMode = React.useMemo&lt;&#x27;month&#x27; | &#x27;date&#x27;&gt;( () =&gt; (mergedMode === &#x27;year&#x27; ? &#x27;month&#x27; : &#x27;date&#x27;), [mergedMode],); 三个状态中，mergedValue存储的是日历的当前值，mergedMode储存的是日历头部的模式，panelMode则是日历面板的模式。 禁用处理 123456789101112// Disabled Date// 判断不可用时间是否在有效时间范围内 在做禁用处理const mergedDisabledDate = React.useCallback( (date: DateType) =&gt; &#123; const notInRange = validRange ? generateConfig.isAfter(validRange[0], date) || generateConfig.isAfter(date, validRange[1]) : false; return notInRange || !!disabledDate?.(date); &#125;, [disabledDate, validRange],); 对于有配置时间显示范围和禁用函数的情况下执行这个函数。 一些事件处理函数 123456789101112131415161718192021222324252627282930const triggerPanelChange = (date: DateType, newMode: CalendarMode) =&gt; &#123; onPanelChange?.(date, newMode);&#125;;const triggerChange = (date: DateType) =&gt; &#123; setMergedValue(date); if (!isSameDate(date, mergedValue)) &#123; // Trigger when month panel switch month if ( (panelMode === &#x27;date&#x27; &amp;&amp; !isSameMonth(date, mergedValue)) || (panelMode === &#x27;month&#x27; &amp;&amp; !isSameYear(date, mergedValue)) ) &#123; triggerPanelChange(date, mergedMode); &#125; onChange?.(date); &#125;&#125;;// 头部显示模式改变const triggerModeChange = (newMode: CalendarMode) =&gt; &#123; setMergedMode(newMode); triggerPanelChange(mergedValue, newMode);&#125;;// 时间被选择const onInternalSelect = (date: DateType) =&gt; &#123; triggerChange(date); onSelect?.(date);&#125;; 时间处理包括日历头部显示模式改变和日期改变，从而导致组件状态的变更触发组件重新渲染。 渲染日期/月份 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 渲染日期 渲染月份const dateRender = React.useCallback( (date: DateType): React.ReactNode =&gt; &#123; if (dateFullCellRender) &#123; return dateFullCellRender(date); &#125; return ( &lt;div className=&#123;classNames(`$&#123;prefixCls&#125;-cell-inner`, `$&#123;calendarPrefixCls&#125;-date`, &#123; [`$&#123;calendarPrefixCls&#125;-date-today`]: isSameDate(today, date), &#125;)&#125; &gt; &lt;div className=&#123;`$&#123;calendarPrefixCls&#125;-date-value`&#125;&gt; &#123;padStart(String(generateConfig.getDate(date)), 2, &#x27;0&#x27;)&#125; &lt;/div&gt; &lt;div className=&#123;`$&#123;calendarPrefixCls&#125;-date-content`&#125;&gt; &#123;dateCellRender &amp;&amp; dateCellRender(date)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;, [dateFullCellRender, dateCellRender],);const monthRender = React.useCallback( (date: DateType, locale: Locale): React.ReactNode =&gt; &#123; if (monthFullCellRender) &#123; return monthFullCellRender(date); &#125; const months = locale.shortMonths || generateConfig.locale.getShortMonths!(locale.locale); return ( &lt;div className=&#123;classNames(`$&#123;prefixCls&#125;-cell-inner`, `$&#123;calendarPrefixCls&#125;-date`, &#123; [`$&#123;calendarPrefixCls&#125;-date-today`]: isSameMonth(today, date), &#125;)&#125; &gt; &lt;div className=&#123;`$&#123;calendarPrefixCls&#125;-date-value`&#125;&gt; &#123;months[generateConfig.getMonth(date)]&#125; &lt;/div&gt; &lt;div className=&#123;`$&#123;calendarPrefixCls&#125;-date-content`&#125;&gt; &#123;monthCellRender &amp;&amp; monthCellRender(date)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;, [monthFullCellRender, monthCellRender],); 渲染日历面板的月份或者日期以用户自定义渲染函数优先，否则加载原计划中的布局和样式。 CalendarHeader组件 1234567891011121314151617181920212223242526272829303132export interface CalendarHeaderProps&lt;DateType&gt; &#123; prefixCls: string; value: DateType; validRange?: [DateType, DateType]; generateConfig: GenerateConfig&lt;DateType&gt;; locale: Locale; mode: CalendarMode; fullscreen: boolean; onChange: (date: DateType) =&gt; void; onModeChange: (mode: CalendarMode) =&gt; void;&#125;function CalendarHeader&lt;DateType&gt;(props: CalendarHeaderProps&lt;DateType&gt;) &#123; const &#123; prefixCls, fullscreen, mode, onChange, onModeChange &#125; = props; const divRef = React.useRef&lt;HTMLDivElement&gt;(null); const sharedProps = &#123; ...props, onChange, fullscreen, divRef, &#125;; return ( &lt;div className=&#123;`$&#123;prefixCls&#125;-header`&#125; ref=&#123;divRef&#125;&gt; &lt;YearSelect &#123;...sharedProps&#125; /&gt; &#123;mode === &#x27;month&#x27; &amp;&amp; &lt;MonthSelect &#123;...sharedProps&#125; /&gt;&#125; &lt;ModeSwitch &#123;...sharedProps&#125; onModeChange=&#123;onModeChange&#125; /&gt; &lt;/div&gt; );&#125;export default CalendarHeader; 日历头部组件，分为三个子组件：年份选择，月份选择和模式转换，涉及到最重要的函数就是onChange和onModeChange函数，作用就是当年份或者月份和显示模式变动之后修改对应的组件状态，从而重新渲染组件。 渲染头部年份/月份/模式选择 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 渲染头部 年份选择function YearSelect&lt;DateType&gt;(props: SharedProps&lt;DateType&gt;) &#123; const &#123; fullscreen, validRange, generateConfig, locale, prefixCls, value, onChange, divRef, &#125; = props; // 上下十年范围可供选择 const year = generateConfig.getYear(value || generateConfig.getNow()); let start = year - YearSelectOffset; let end = start + YearSelectTotal; if (validRange) &#123; start = generateConfig.getYear(validRange[0]); end = generateConfig.getYear(validRange[1]) + 1; &#125; const suffix = locale &amp;&amp; locale.year === &#x27;年&#x27; ? &#x27;年&#x27; : &#x27;&#x27;; const options: &#123; label: string; value: number &#125;[] = []; for (let index = start; index &lt; end; index++) &#123; options.push(&#123; label: `$&#123;index&#125;$&#123;suffix&#125;`, value: index &#125;); &#125; return ( &lt;Select size=&#123;fullscreen ? undefined : &#x27;small&#x27;&#125; options=&#123;options&#125; value=&#123;year&#125; className=&#123;`$&#123;prefixCls&#125;-year-select`&#125; onChange=&#123;numYear =&gt; &#123; let newDate = generateConfig.setYear(value, numYear); if (validRange) &#123; const [startDate, endDate] = validRange; const newYear = generateConfig.getYear(newDate); const newMonth = generateConfig.getMonth(newDate); if ( newYear === generateConfig.getYear(endDate) &amp;&amp; newMonth &gt; generateConfig.getMonth(endDate) ) &#123; newDate = generateConfig.setMonth(newDate, generateConfig.getMonth(endDate)); &#125; if ( newYear === generateConfig.getYear(startDate) &amp;&amp; newMonth &lt; generateConfig.getMonth(startDate) ) &#123; newDate = generateConfig.setMonth(newDate, generateConfig.getMonth(startDate)); &#125; &#125; onChange(newDate); &#125;&#125; getPopupContainer=&#123;() =&gt; divRef!.current!&#125; /&gt; );&#125; 以当前年份为中心，提供上下十个年份供选择，循环生成对应的Option选项，再把Select渲染到CalendarHeader组件的div中。 同理，月份Select渲染也是类似： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 渲染头部 月份选择function MonthSelect&lt;DateType&gt;(props: SharedProps&lt;DateType&gt;) &#123; const &#123; prefixCls, fullscreen, validRange, value, generateConfig, locale, onChange, divRef, &#125; = props; const month = generateConfig.getMonth(value || generateConfig.getNow()); let start = 0; let end = 11; if (validRange) &#123; const [rangeStart, rangeEnd] = validRange; const currentYear = generateConfig.getYear(value); if (generateConfig.getYear(rangeEnd) === currentYear) &#123; end = generateConfig.getMonth(rangeEnd); &#125; if (generateConfig.getYear(rangeStart) === currentYear) &#123; start = generateConfig.getMonth(rangeStart); &#125; &#125; const months = locale.shortMonths || generateConfig.locale.getShortMonths!(locale.locale); const options: &#123; label: string; value: number &#125;[] = []; for (let index = start; index &lt;= end; index += 1) &#123; options.push(&#123; label: months[index], value: index, &#125;); &#125; return ( &lt;Select size=&#123;fullscreen ? undefined : &#x27;small&#x27;&#125; className=&#123;`$&#123;prefixCls&#125;-month-select`&#125; value=&#123;month&#125; options=&#123;options&#125; onChange=&#123;newMonth =&gt; &#123; onChange(generateConfig.setMonth(value, newMonth)); &#125;&#125; getPopupContainer=&#123;() =&gt; divRef!.current!&#125; /&gt; );&#125; 模式切换采用了按钮组的形式，调用了模式切换函数： 1234567891011121314151617// 日历模式切换function ModeSwitch&lt;DateType&gt;(props: ModeSwitchProps&lt;DateType&gt;) &#123; const &#123; prefixCls, locale, mode, fullscreen, onModeChange &#125; = props; return ( &lt;Group onChange=&#123;(&#123; target: &#123; value &#125; &#125;) =&gt; &#123; onModeChange(value); &#125;&#125; value=&#123;mode&#125; size=&#123;fullscreen ? undefined : &#x27;small&#x27;&#125; className=&#123;`$&#123;prefixCls&#125;-mode-switch`&#125; &gt; &lt;Button value=&quot;month&quot;&gt;&#123;locale.month&#125;&lt;/Button&gt; &lt;Button value=&quot;year&quot;&gt;&#123;locale.year&#125;&lt;/Button&gt; &lt;/Group&gt; );&#125; 总结： ① 它山之石可以攻玉，要善于利用工具或者已有的组件进行封装，比如文中提到的lodash rc-util rc-picker等。 ② 导出组件的同时，需要把对应的componentNameProps也导出，便于其它使用者采用这个组件的类型和代码提示。 ③ _interopRequireDefault是在rc-util/lib/hooks/useMergedState里面看到的，这个方法可以在es6环境下使用common.js的模块，其内部实现也就是给需要引入的cjs模块添加一个default属性，可以支持es6的使用。 123getFixedDate: function getFixedDate(string) &#123; return (0, _moment.default)(string, &#x27;YYYY-MM-DD&#x27;);&#125;, ④ 这种写法是在rc-picker/lib/generate/moment函数中看到，_moment.default是一个函数，前面执行逗号表达式返回这个函数，后面再传参调用此函数。","tags":[]},{"title":"antd源码解析之Anchor","date":"2021-06-19T15:12:00.000Z","path":"2021/06/19/antd_anchor/","text":"Anchor锚点定位跳转，早期前端刀耕火种时代使用的是&lt;a&gt;标签的href属性做锚点跳转，固定模式下有点类似于固钉Affix，事实也确实如此。 API参数 1234567891011121314151617181920212223242526export interface AnchorProps &#123; prefixCls?: string; className?: string; style?: React.CSSProperties; children?: React.ReactNode; /** 距离窗口顶部达到指定偏移量后触发 */ offsetTop?: number; /** 锚点区域边界 */ bounds?: number; /** 固定模式 */ affix?: boolean; /** affix=&#123;false&#125; 时是否显示小圆点 */ showInkInFixed?: boolean; /** 指定滚动的容器 */ getContainer?: () =&gt; AnchorContainer; /** 自定义高亮锚点 */ getCurrentAnchor?: () =&gt; string; onClick?: ( e: React.MouseEvent&lt;HTMLElement&gt;, link: &#123; title: React.ReactNode; href: string &#125;, ) =&gt; void; /** 锚点滚动偏移量，默认与 offsetTop 相同 */ targetOffset?: number; /** 监听锚点链接改变 */ onChange?: (currentActiveLink: string) =&gt; void;&#125; render函数以及对应的Element 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061render = () =&gt; &#123; const &#123; getPrefixCls, direction &#125; = this.context; const &#123; prefixCls: customizePrefixCls, className = &#x27;&#x27;, style, offsetTop, affix, showInkInFixed, children, &#125; = this.props; const &#123; activeLink &#125; = this.state; const prefixCls = getPrefixCls(&#x27;anchor&#x27;, customizePrefixCls); this.prefixCls = prefixCls; const inkClass = classNames(`$&#123;prefixCls&#125;-ink-ball`, &#123; visible: activeLink, &#125;); const wrapperClass = classNames( `$&#123;prefixCls&#125;-wrapper`, &#123; [`$&#123;prefixCls&#125;-rtl`]: direction === &#x27;rtl&#x27; &#125;, className, ); const anchorClass = classNames(prefixCls, &#123; fixed: !affix &amp;&amp; !showInkInFixed, &#125;); const wrapperStyle = &#123; maxHeight: offsetTop ? `calc(100vh - $&#123;offsetTop&#125;px)` : &#x27;100vh&#x27;, ...style, &#125;; const anchorContent = ( &lt;div ref=&#123;this.wrapperRef&#125; className=&#123;wrapperClass&#125; style=&#123;wrapperStyle&#125;&gt; &lt;div className=&#123;anchorClass&#125;&gt; &lt;div className=&#123;`$&#123;prefixCls&#125;-ink`&#125;&gt; &lt;span className=&#123;inkClass&#125; ref=&#123;this.saveInkNode&#125; /&gt; &lt;/div&gt; &#123;children&#125; &lt;/div&gt; &lt;/div&gt; ); return ( &lt;AnchorContext.Provider value=&#123;&#123; registerLink: this.registerLink, unregisterLink: this.unregisterLink, activeLink: this.state.activeLink, scrollTo: this.handleScrollTo, onClick: this.props.onClick, &#125;&#125; &gt; &#123;!affix ? ( anchorContent ) : ( &lt;Affix offsetTop=&#123;offsetTop&#125; target=&#123;this.getContainer&#125;&gt; &#123;anchorContent&#125; &lt;/Affix&gt; )&#125; &lt;/AnchorContext.Provider&gt; );&#125;; 这里载入了一些antd专有的样式和用户自定义的样式，固定模式下引用了Affix组件包装，多组件之间使用Context进行通信，共享了一些状态和函数。 生命周期函数 123456789101112131415161718192021222324componentDidMount() &#123; this.scrollContainer = this.getContainer(); this.scrollEvent = addEventListener(this.scrollContainer, &#x27;scroll&#x27;, this.handleScroll); this.handleScroll();&#125;componentDidUpdate() &#123; if (this.scrollEvent) &#123; const currentContainer = this.getContainer(); if (this.scrollContainer !== currentContainer) &#123; this.scrollContainer = currentContainer; this.scrollEvent.remove(); this.scrollEvent = addEventListener(this.scrollContainer, &#x27;scroll&#x27;, this.handleScroll); this.handleScroll(); &#125; &#125; this.updateInk();&#125;componentWillUnmount() &#123; if (this.scrollEvent) &#123; this.scrollEvent.remove(); &#125;&#125; ①组件初始化对指定容器元素（默认为window）添加滚动事件监听，并执行handleScroll（默认也会执行一次）。②当调用setState状态更新也就是当前链接activeLink发生变动触发componentDidUpdate函数，函数中判断滚动的容器是否发生变动，做相应的处理后调用handleScroll和updateInk函数。 Context中的函数 12345678910111213141516171819202122232425262728293031323334353637383940// ContextregisterLink = (link: string) =&gt; &#123; if (!this.links.includes(link)) &#123; this.links.push(link); &#125;&#125;;unregisterLink = (link: string) =&gt; &#123; const index = this.links.indexOf(link); if (index !== -1) &#123; this.links.splice(index, 1); &#125;&#125;;handleScrollTo = (link: string) =&gt; &#123; const &#123; offsetTop, targetOffset &#125; = this.props; this.setCurrentActiveLink(link); const container = this.getContainer(); const scrollTop = getScroll(container, true); const sharpLinkMatch = sharpMatcherRegx.exec(link); if (!sharpLinkMatch) &#123; return; &#125; const targetElement = document.getElementById(sharpLinkMatch[1]); if (!targetElement) &#123; return; &#125; const eleOffsetTop = getOffsetTop(targetElement, container); let y = scrollTop + eleOffsetTop; y -= targetOffset !== undefined ? targetOffset : offsetTop || 0; this.animating = true; scrollTo(y, &#123; callback: () =&gt; &#123; this.animating = false; &#125;, getContainer: this.getContainer, &#125;);&#125;; registerLink和unregisterLink函数主要作用是添加和移除锚点项队列links，handleScrollTo函数作用是对Link传过来的href属性找到需要滚动的元素，计算滚动的top值调用scrollTo滚动到对应的位置，这一小段应该配合子元素的解析食用效果更佳。 1234567891011121314151617function getOffsetTop(element: HTMLElement, container: AnchorContainer): number &#123; if (!element.getClientRects().length) &#123; return 0; &#125; const rect = element.getBoundingClientRect(); if (rect.width || rect.height) &#123; if (container === window) &#123; container = element.ownerDocument!.documentElement!; return rect.top - container.clientTop; &#125; return rect.top - (container as HTMLElement).getBoundingClientRect().top; &#125; return rect.top;&#125; 这个函数用于获取点击锚点后关联元素距离容器元素的top值，getBoundingClientRect()方法返回元素的大小及其相对于视口的位置（bottom、height、left、right、top、width、x、y），所以rect.top - container.clientTop就是锚点关联元素相对于容器元素的top值，接下来看子组件AnchorLink。 子组件AnchorLink 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556componentDidMount() &#123; this.context.registerLink(this.props.href);&#125;componentDidUpdate(&#123; href: prevHref &#125;: AnchorLinkProps) &#123; const &#123; href &#125; = this.props; if (prevHref !== href) &#123; this.context.unregisterLink(prevHref); this.context.registerLink(href); &#125;&#125;componentWillUnmount() &#123; this.context.unregisterLink(this.props.href);&#125;handleClick = (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; &#123; const &#123; scrollTo, onClick &#125; = this.context; const &#123; href, title &#125; = this.props; onClick?.(e, &#123; title, href &#125;); scrollTo(href);&#125;;renderAnchorLink = (&#123; getPrefixCls &#125;: ConfigConsumerProps) =&gt; &#123; const &#123; prefixCls: customizePrefixCls, href, title, children, className, target &#125; = this.props; const prefixCls = getPrefixCls(&#x27;anchor&#x27;, customizePrefixCls); const active = this.context.activeLink === href; const wrapperClassName = classNames( `$&#123;prefixCls&#125;-link`, &#123; [`$&#123;prefixCls&#125;-link-active`]: active, &#125;, className, ); const titleClassName = classNames(`$&#123;prefixCls&#125;-link-title`, &#123; [`$&#123;prefixCls&#125;-link-title-active`]: active, &#125;); return ( &lt;div className=&#123;wrapperClassName&#125;&gt; &lt;a className=&#123;titleClassName&#125; href=&#123;href&#125; title=&#123;typeof title === &#x27;string&#x27; ? title : &#x27;&#x27;&#125; target=&#123;target&#125; onClick=&#123;this.handleClick&#125; &gt; &#123;title&#125; &lt;/a&gt; &#123;children&#125; &lt;/div&gt; );&#125;;render() &#123; return &lt;ConfigConsumer&gt;&#123;this.renderAnchorLink&#125;&lt;/ConfigConsumer&gt;;&#125; 子组件作为Context的消费者，初始化的时候调用this.context.registerLink把传入props的href属性添加到锚点队列中，组件状态更新对比前后两个href差异并做添加移除操作，点击锚点元素后出触发handleClick并在内调用onClick回调和父级的handleScrollTo函数，做对应的滚动处理。 总结：当共享的属性和方法较多的情况下，可使用Context进行父子组件间的通信；element.getBoundingClientRect()方法可以获取元素相对于视口的位置信息。","tags":[]},{"title":"antd源码解析之Affix","date":"2021-06-14T08:30:00.000Z","path":"2021/06/14/antd_affix/","text":"Affix 固钉，就是固定在页面的某个地方，类似于样式中的固定布局。 API参数 先看组件可以传入什么参数使用 12345678910111213141516export interface AffixProps &#123; /** 距离窗口顶部达到指定偏移量后触发 */ offsetTop?: number; /** 距离窗口底部达到指定偏移量后触发 */ offsetBottom?: number; style?: React.CSSProperties; /** 固定状态改变时触发的回调函数 */ onChange?: (affixed?: boolean) =&gt; void; /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */ target?: () =&gt; Window | HTMLElement | null; /** 样式命名空间，传入可覆盖antd命名空间&#x27;ant-|ant&#x27; */ prefixCls?: string; /** 覆写class类名 */ className?: string; children: React.ReactNode;&#125; render函数 1234567891011121314151617181920212223242526272829render = () =&gt; &#123; const &#123; getPrefixCls &#125; = this.context; const &#123; affixStyle, placeholderStyle &#125; = this.state; const &#123; prefixCls, children &#125; = this.props; const className = classNames(&#123; [getPrefixCls(&#x27;affix&#x27;, prefixCls)]: !!affixStyle, &#125;); let props = omit(this.props, [&#x27;prefixCls&#x27;, &#x27;offsetTop&#x27;, &#x27;offsetBottom&#x27;, &#x27;target&#x27;, &#x27;onChange&#x27;]); return ( &lt;ResizeObserver onResize=&#123;() =&gt; &#123; this.updatePosition(); &#125;&#125; &gt; &lt;div &#123;...props&#125; ref=&#123;this.savePlaceholderNode&#125;&gt; &#123;affixStyle &amp;&amp; &lt;div style=&#123;placeholderStyle&#125; aria-hidden=&quot;true&quot; /&gt;&#125; &lt;div className=&#123;className&#125; ref=&#123;this.saveFixedNode&#125; style=&#123;affixStyle&#125;&gt; &lt;ResizeObserver onResize=&#123;() =&gt; &#123; this.updatePosition(); &#125;&#125; &gt; &#123;children&#125; &lt;/ResizeObserver&gt; &lt;/div&gt; &lt;/div&gt; &lt;/ResizeObserver&gt; );&#125;; 这里做了一些默认样式的加载，固定初始位置等，利用ResizeObserver组件来监听元素位置、大小的变化。 组件生命周期函数执行 12345678910111213141516171819202122232425262728293031323334353637383940414243componentDidMount() &#123; const targetFunc = this.getTargetFunc(); if (targetFunc) &#123; this.timeout = setTimeout(() =&gt; &#123; addObserveTarget(targetFunc(), this); this.updatePosition(); &#125;); &#125;&#125;componentDidUpdate(prevProps: AffixProps) &#123; const &#123; prevTarget &#125; = this.state; const targetFunc = this.getTargetFunc(); let newTarget = null; if (targetFunc) &#123; newTarget = targetFunc() || null; &#125; if (prevTarget !== newTarget) &#123; removeObserveTarget(this); if (newTarget) &#123; addObserveTarget(newTarget, this); this.updatePosition(); &#125; this.setState(&#123; prevTarget: newTarget &#125;); &#125; if ( prevProps.offsetTop !== this.props.offsetTop || prevProps.offsetBottom !== this.props.offsetBottom ) &#123; this.updatePosition(); &#125; this.measure();&#125;componentWillUnmount() &#123; clearTimeout(this.timeout); removeObserveTarget(this); (this.updatePosition as any).cancel(); (this.lazyUpdatePosition as any).cancel();&#125; ① 组件初始化时addObserveTarget函数给target元素添加了滚动事件监听（不传入target参数相当于给window添加滚动监听），该函数内部调用lazyUpdatePosition函数用于判断事件触发后组件的top、bottom值是否变化，使用装饰器语法在位置更新的函数上做了节流处理，并调用updatePosition函数初始化一些组件状态AffixStyle与placeholderStyle等。 ② 状态更新触发componentDidUpdate函数，对比前后的target元素，如果发生变动则移除之前的监听并添加新的监听然后更新位置，否则直接更新位置，然后调用measure函数。 ③ 触发组件卸载函数，清空定时器，移除一些副作用的操作。 measure函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556measure = () =&gt; &#123; const &#123; status, lastAffix &#125; = this.state; const &#123; onChange &#125; = this.props; const targetFunc = this.getTargetFunc(); if (status !== AffixStatus.Prepare || !this.fixedNode || !this.placeholderNode || !targetFunc) &#123; return; &#125; const offsetTop = this.getOffsetTop(); const offsetBottom = this.getOffsetBottom(); const targetNode = targetFunc(); if (!targetNode) &#123; return; &#125; const newState: Partial&lt;AffixState&gt; = &#123; status: AffixStatus.None, &#125;; const targetRect = getTargetRect(targetNode); const placeholderReact = getTargetRect(this.placeholderNode); const fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop); const fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom); console.log(targetRect, placeholderReact, fixedTop, fixedBottom, &#x27;123456&#x27;) if (fixedTop !== undefined) &#123; newState.affixStyle = &#123; position: &#x27;fixed&#x27;, top: fixedTop, width: placeholderReact.width, height: placeholderReact.height, &#125;; newState.placeholderStyle = &#123; width: placeholderReact.width, height: placeholderReact.height, &#125;; &#125; else if (fixedBottom !== undefined) &#123; newState.affixStyle = &#123; position: &#x27;fixed&#x27;, bottom: fixedBottom, width: placeholderReact.width, height: placeholderReact.height, &#125;; newState.placeholderStyle = &#123; width: placeholderReact.width, height: placeholderReact.height, &#125;; &#125; newState.lastAffix = !!newState.affixStyle; if (onChange &amp;&amp; lastAffix !== newState.lastAffix) &#123; onChange(newState.lastAffix); &#125; this.setState(newState as AffixState);&#125;; 函数中主要计算对应的top和bottom值，保存到状态affixStyle中用于组件渲染，通过lastAffix来判断是否调用回调函数onChange 总结：组件设计中，可以利用数组队列维护一个事件池，如源码中的addObserveTarget函数；采用装饰器语法对某些频繁触发的函数进行节流操作，从而达到组件优化的作用。","tags":[]},{"title":"前端自动化部署方案一","date":"2021-06-02T14:30:00.000Z","path":"2021/06/02/自动化部署一/","text":"在印象中，使用window server服务器的工作模式都是，本地项目打包，然后远程window服务器，手动复制生成环境下的项目文件到对应的服务器文件夹下，然后，在飞速发展的今天，自动化操作已经成为日常工作中的主流，这里给还在用window serverd的伙伴提供一种自动化解决方案，该方案本站点也正在使用。 window当然不像Linux那样，可以直接通过ssh传输，可以直接远程操作服务器执行shell命令来操作服务器，由于大部分旧版本的window server系统没有内置SSH服务，所以需要借助这个工具包Win32-OpenSSH，下载解压并进入到C:\\Program Files\\OpenSSH-Win64，在当前目录执行命令powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1安装SSH服务。 服务端 设置服务自动启动并启动服务： 12sc config sshd start= autonet start sshd 会生成目录和配置文件：C:\\ProgramData\\ssh C:\\Users\\账户名\\.ssh（这两个是隐藏文件） 这里SSH服务的用户是基于window的系统用户。 客户端 win10系统是自带SSH服务的，可以在应用和功能的可选功能中添加OpenSSH服务。 登录SSH服务： 1ssh administrator@your_server_ip 报错：WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 这里C:\\Users\\Administrator\\.ssh去除当前登录IP的记录。 退出： 1exit/logout/关掉 Node项目部署： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const &#123;NodeSSH&#125; = require(&#x27;node-ssh&#x27;)const ssh = new NodeSSH()const config = &#123; host: &#x27;xxx.xxx.xxx.xxx&#x27;, username: &#x27;administrator&#x27;, password: &#x27;xxx&#x27;, /** 本地目录 */ localDir: &#x27;./build&#x27;, /** 远程目录 */ remoteDir: &#x27;/Project/testPro/mockProject&#x27;, /** 终端命令 */ command: &#x27;cd C:/Project/testPro &amp;&amp; rmdir mockProject /s/q &amp;&amp; mkdir mockProject&#x27;&#125;// 清除服务器缓存function clearCache()&#123; return new Promise((resolve, reject) =&gt; &#123; ssh.execCommand(config.command).then(function(result) &#123; if(result.stderr) &#123; reject(result.stderr) &#125; else &#123; resolve(&#123;code: 1&#125;) &#125; &#125;) &#125;)&#125;// 上传文件function uploadDir() &#123; return new Promise((resolve, reject) =&gt; &#123; ssh.putDirectory(config.localDir, config.remoteDir).then(function()&#123; resolve(&#123;code: 1&#125;) &#125;, function(error)&#123; reject(error) &#125;) &#125;)&#125;//connect sftpssh.connect(&#123; ...config, port: 22, tryKeyboard: true, onKeyboardInteractive: (name, instructions, instructionsLang, prompts, finish) =&gt; &#123; if (prompts.length &gt; 0 &amp;&amp; prompts[0].prompt.toLowerCase().includes(&#x27;password&#x27;)) &#123; finish([config.password]) &#125; &#125; &#125;).then(async function() &#123; console.log(&#x27;connect success!&#x27;) console.log(&#x27;cache clearing...&#x27;) //...清除服务器的旧文件数据 const clearRes = await clearCache() //...上传文件 if(clearRes[&#x27;code&#x27;] === 1) &#123; console.log(&#x27;clear success!&#x27;) console.log(&#x27;uploading...&#x27;) const uploadRes = await uploadDir() if(uploadRes[&#x27;code&#x27;] === 1) &#123; console.log(&#x27;upload success!&#x27;) process.exit(1) &#125; else &#123; console.log(&#x27;Error:&#x27;, uploadRes) process.exit(0) &#125; &#125; else &#123; console.log(&#x27;Error:&#x27;, clearRes) process.exit(0) &#125;&#125;) 当然，这里也可以按照Linux系统一样上传压缩文件解压处理，不过得借助unzip工具包， 安装后将bin目录下的unzip.exe文件放在C:\\Windows目录下，就可以执行unzip命令了。","tags":[]},{"title":"作业调度和缺页中断","date":"2021-05-05T03:24:00.000Z","path":"2021/05/05/中断和作业/","text":"作业调度和缺页中断是操作系统课程中两个重点的考查内容，今天看到看到几道操作系统的题目，在这里回顾和复习一下对应的一些知识。 首先，简单理解一些课程中的专业词汇： 缺页中断：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 肯定有些吃瓜同学会问，页是个什么东西？为了方便理解，你可以把它看成是书本的页，本书可以看做是物理存储器，而书中所有的文字可以看做的存储的单元块，页就是方便管理这些单元块的。 对存储器进行分页管理，可以更好的利用磁盘中的碎片，提高磁盘的利用率，因为分页的地址在逻辑上是连续的，而在物理上是非连续的。 作业调度：作业是计算机用户交给操作系统的执行单位，作业调度是操作系统对计算机资源的合理分配方式，常见的有五种调度方式： (1) FCFS：先到先服务，即按照到达顺序先来先服务的方法，此方法是非抢占式的。 (2) SJF：短作业优先调度，即按照执行时间短的优先，当到达时间不同时，将新来的执行时间和之前的剩余时间对比，短的优先（就可能存在抢占了）。 (3) 非抢占优先级：突出优先级，优先级大的优先，执行时间少的优先。 (4) RR：固定时间片，非抢占轮转调度，固定一个程序一次只能运行一个时间片，再按到达时间，先来先执行。 (5) 抢占轮转调度：同时考虑优先级、时间片、到达先后。 另外还有两个需要了解的概念： (1) 周转时间：从任务到达时间到任务执行完毕所用的时间。 (2) 等待时间：任务到达后等待的所有时间相加。 (3) 带权周转时间：周转时间与运行时间的比值，即单位运行时间下的周转时间值。 下面是举栗子时间 例一 按照题目的问答我们纵向来解答，即按照不同的周转算法来回答不同的问题： (1) 按照上面先来先服务的概念，执行顺序是: 1(0-10), 2(10-11), 3(11-13), 4(13-14) (2) 按照上面RR固定时间片的概念，执行顺序是: 1(0-1), 2(1-2), 3(2-3), 4(3-4), 1(4-5), 3(5-6), 1(6-14) (3) 按照上面非抢占式优先级算法的概念，执行顺序是: 1(0-10), 4(10-11), 3(11-13), 2(13-14) 例二 (1) 按照上面先来先服务的概念，执行顺序和周转时间如下图 (2) 按照上面短作业优先作业的概念，执行顺序和周转时间如下图 例三 对于如下的页面访问序列：1，2，3，4，1，2，5，1，2，3，4，5；当内存块数为3时，试问：使用FIFO、LRU置换算法产生的缺页中断是多少？（所有内存开始时都是空的，凡是第一次用到的页面都产生一次缺页中断） (1) FIFO先进先出 (2) LRU最近最久未使用","tags":[]},{"title":"什么是哈夫曼树","date":"2021-05-01T08:45:00.000Z","path":"2021/05/01/哈夫曼树/","text":"今天看到一道题，是这样描述的： 设给定一个权值集合W=(3，5，7，9，11)，要求根据给定的权值集合构造一棵哈夫曼树并计算哈夫曼树的带权路径长度WPL？ 就以这道题为基准，让我们来看看哈夫曼树是怎么一回事。 首先，哈夫曼树是一个叫做哈夫曼博士发明的，可以利用结点权重和路径长度，通过树的带权路径长度(WPL)，来求出最优二叉树。 1. 树的路径 如上图中的树所示，结点A到结点E的路径为A, B, E。 2. 路径长度 如上图中的树所示，结点A到结点D之间有两条边，所以AD的路径长度为2。 3. 结点的带权路径长度 如上图中的树所示，假设结点D的权重是3，从根结点到D的路径长度是2，所以结点D的带权路径长度3*2=6。 4. 树的带权路径长度WPL 如上图中的树所示，假设结点C的权重是2，结点D的权重是3，结点E的权重是5；我们再看路径长度，结点C的路径长度为1，结点D和结点D的路径长度都为2，所以树的带权路径长度WPL = 1*2 + 2*3 + 2*5 = 18。 5. 构建哈夫曼树（最优二叉树） 所谓最优二叉树就是带权路径长度最小的树，所以不是随便构建一棵树都是哈夫曼树，根据上面的WPL求值方法，我们可以推断：在构建二叉树的时候，只需要把结点权重小的往根结点上靠，这样的树计算出来的WPL往往是最小的，这棵树也就是哈夫曼树。 5.1 借助队列，构建深林 接下来回到上面的题目来，题目给出了对应的权值集合(3, 5, 7, 9, 11)，我们先构建深林（把每一个结点当做一颗独立的树），借助队列来构建对应的树 5.2 取两个结点，生成子树 左侧借助队列的形式从小到大存储对应权重的结点，按权重由小到大的顺序排列，取权重最小的结点2, 3，以权重的和5为父结点生成一棵树。 5.3 从队列中删除选中的结点，插入新的结点 把上一步中选中的两个结点从队列中删除，并插入上面新生成的父结点，新的队列按从小到大排序，然后重5.2的操作。 5.4 当新插入的结点不在队列第一个元素的下面，应生成一个新的子树 接下来挑选7, 8，生成新的父结点15，放入队列中排序后处于最下面的位置，而此时选择两个结点并没有选中新生成的结点15，而是选中9和11，遇到这种情况时，我们应该考虑在原有树的外部，重新生成一颗新的子树，然后重复5.2的步骤，再把两颗子树通过生成父结点，然后可以根据树的带权路径长度算法算出WPL的值（WPL=78） 其实哈夫曼树在生活中有广泛的应用，比如通信领域的哈夫曼编码，计算机程序中的哈夫曼编码等等。","tags":[{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"}]},{"title":"与时间对话，2021节点","date":"2021-02-25T13:20:01.000Z","path":"2021/02/25/与时间对话/","text":"前言：凡过往，皆序章；凡当下，皆美好；凡未来，皆可期。 本来这篇文章原计划于春节假期在家完成，但种种的种种…就不赘述，前言即大纲，开始行文。 记得上一次写总结是在一八年的时候，也是在这里，与自己对话，与过去对话，也与未来对话，所以今天的标题就是：与时间对话。在二零二一这个节点上，也算是工作了四年了吧。回望过去，一六年底，剑未佩妥的来到广州，先后经历了良星、英虎、摘星者等等，技术从JS/JQuery、Angularjs、React/Vue再到React，现在想想，依旧是剑未佩妥，我想这把剑应该是透明的看不见吧。 然而，在这样的路径下，我好像在一直不断地追框架，一直不断地学框架，而四年过去了，有些框架可以说是已死，比如曾以为经久不衰的JQuery，比如开启前端开发革命性模式的框架AngularJs，现在都已经无人问津，那么接下来呢？会不会出现新的框架？会不会在几年之后React/Vue也会死？甚至前端开发岗位会不会被自动化所取代？我想，这些是我必须要思考的问题。 当然，期间也有小插曲，比如：离职半年的全心考研，那是我对书本文化知识的再一次追求，对期待进入更高知识殿堂的又一次尝试。有遗憾也有小确幸，英语水平的进步、专业课的认识以及本专之差的体会，也为我之后一次性通过学位英语打下坚实的基础，再比如坑爹的九零后和摘星者的年会，有昏暗也有欣喜，愿昏暗化坦途，愿欣喜化动力，永远也不要停下前进的脚步。 疫情之下，每个人都忧心忡忡，各行各业也面临巨大挑战，没有办法，于是三月份回到广州工作，来到一家电商公司，工作了一个月研发部整体被裁，不过后来也发现，是项目不想养自己的团队而选择外包出去。在这之后，有幸的来到当下，有幸的遇到了一群快乐可爱并且技术能力非常牛的小伙伴，在这里拥抱了新版本的React，在这里挑战了之前没有遇到过的难题，可能说做出来的不是最优解，但也是如期圆满完成既定任务，后期还需要不断地迭代。其实，这不就恰似我们的生活吗，生活的过程，也是一个不断地遇到问题，解决问题的过程；是一个不断探索未知世界的过程；是一个不断深化自己世界观、人生观、价值观的过程，只要沉下心来，办法总比困难多。 时间再次往前翻，回顾这里过去的文字，总体概括为两个字：“记录”，记录一些应用案例，记录一些工作中遇到的问题，记录一些使用过的技术概念，很少有经过自己深度思考或者说是有深度的文章，以前，我可能追求一周一月要更新多少篇文字，我想之后，应该要更加追求质而不是量，更多的加入自己的思考，多问几个是什么（原理上是什么），为什么（为什么要这样设计），怎么样（这样设计有什么效益），形成有自己深度思考的文章，而不仅仅是复制、借鉴和记录。 往后，要重点打造自己的核心竞争力，更加注重全局观和整体观的培养，打造自己的架构能力，更多的是要从团队上、业务上去考虑问题。培养自己的快速学习能力，即可以快速运用新技术到项目中的能力，从整体出发，从全局出发，这是往后甚至以后很长一段时间需要做的事。当下最应该做的是褪去懒散，可以给自己定一个小目标，比如：研究生学历提升计划、一辆小车子、一笔自己的存款…当然，更切实际的就是，打造自己的构建组件库的能力，学习一些构建组件库的课程；培养自己的全栈技能，具体体现在学完华为全栈课程第三期；把已有的技能书籍和文学书籍看完吧，不要再让它吃灰了。 加油吧，青年！往后的日子还很长，多的是快乐和美好；我想，在春暖花开之际，在木棉绽放之乡，等一个更好的自己，等风又等你。","tags":[{"name":"人生","slug":"人生","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"RN搭建环境出现的问题集合","date":"2021-02-22T13:45:00.000Z","path":"2021/02/22/RN问题集合/","text":"前言：使用React Native开发最好保持较为稳定的VPN环境，搭配Expo托管，配合Mac开发环境食用更佳，不然，可能就会像如下情况 1. 由于墙的原因，可以尝试手动安装app 由于国内网络环境问题，按钮expo工具包异常，可能会出现下面所示的错误： ExpoKit builds constantly failing due to \"getaddrinfo ENOTFOUND d1wp6m56sqw74a.cloudfront.net\" 我们可以尝试下载对应的apk，放置目录：G:\\AndroidSDK\\platform-tools，手动安装 1adb install app_name.apk 2. 模拟器需要调用硬件加速，而电脑设置关闭了 模拟器需要调用硬件加速，而你的电脑默认关闭了硬件加速，则出现以下错误： emulator: ERROR: x86 emulation currently requires hardware acceleration!Please ensure Intel HAXM is properly installed and usable.CPU acceleration status: HAX kernel module is not installed! 需要在安卓SDK找到intelhaxm-android.exe安装，还可能需要在Boise里面开启VT设置（Virtualization Technology） 3. gradle工具包版本太低 java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.reflection.ReflectionCache java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7 错误原因：gradle版本太低，修改gradle-wrapper.properties文件 12345distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-6.3-all.zip 4.模拟器无响应或者相应时间过长 Couldn't start project on Android: Error running adb: It took too long to start the Android emulator: Pixel_3a. You can try starting the emulator manually from the terminal 打开模拟器时间过长，可以尝试手动打开 到安卓SDK的emulator目录下使用emulator -avd Pixel_3a打开对应名称的模拟器 使用emulator -list-avds查看所有模拟器列表 最后，放弃安卓studio模拟器吧，用夜神都比较香。","tags":[]},{"title":"Vue仿支付宝密码输入弹框","date":"2020-11-23T13:04:00.000Z","path":"2020/11/23/vue密码输入框/","text":"上一篇文章，我们使用react来模拟了类似移动端的这种密码输入效果，见详见链接，在这篇中，我们使用vue来实现类似的效果，思路基本和上一篇类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div class=&quot;code-wrapper&quot;&gt; &lt;div class=&quot;code-item&quot; v-for=&quot;(index, item) in number&quot; :key=&quot;index&quot;&gt; &#123;&#123; code[item] &#125;&#125; &lt;/div&gt; &lt;input class=&quot;code-input&quot; v-model=&quot;code&quot; :maxlength=&quot;number&quot; @input=&quot;inputOn&quot; type=&quot;text&quot; oninput=&quot;if(value.length&gt;5)value=value.slice(0,6)&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; code: &quot;&quot;, number: 6, &#125;; &#125;, methods: &#123; inputOn() &#123; // 发送 // if (this.code.length &gt;= this.number) &#123; // this.$emit(&#x27;senCode&#x27;, this.code) // &#125; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt; .code-wrapper &#123; position: relative; width: 100%; display: flex; justify-content: space-between; font-weight: bold; .code-item &#123; width: 1.82rem; height: 1.82rem; line-height: 1.09rem; border-bottom: 0.02rem solid #333; text-align: center; font-size: 1rem; font-weight: normal; &#125; .code-input &#123; height: 1.09rem; position: absolute; outline: none; color: transparent; text-shadow: 0 0 0 transparent; width: 200%; margin-left: -100%; border: none; background: none; -webkit-appearance: none; &#125; &#125;&lt;/style&gt; 简单的密码输入弹框案例完成，详见在线演示","tags":[]},{"title":"react仿支付宝密码输入弹框","date":"2020-11-12T14:12:00.000Z","path":"2020/11/12/react密码输入弹框/","text":"经常看到移动端的密码输入框包括微信、支付宝都很美观，这里使用react简单的模拟了一个类似的输入弹框。 先说一下思路：密码一般都是六位，在视觉上给每个数字加上边框看起来似乎是留个单独的input，其实不然，下面代码的实现通过一个input做输入，然后把输入的位数渲染到带边框的容器中，这样是实现了类似的效果。 类型Vue的案例实现见上面一篇文章。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// MyModal.tsximport React, &#123; useState &#125; from &quot;react&quot;;import &#123; Modal, Button, Input &#125; from &quot;antd&quot;;import &quot;./index.css&quot;;const MyModal: React.FC&lt;&#123;&#125;&gt; = (props) =&gt; &#123; const [visible, setVisible] = useState&lt;boolean&gt;(false); const [loading, setLoading] = useState&lt;boolean&gt;(false); const [code, setCode] = useState&lt;string&gt;(&quot;&quot;); const [number, setNumber] = useState&lt;number[]&gt;([0, 1, 2, 3, 4, 5]); const onChange = (e: any) =&gt; &#123; let v = e.target.value; setCode(v); &#125;; const handleConfirm = () =&gt; &#123; setVisible(false); &#125;; const handleCancel = () =&gt; &#123; setVisible(false); &#125;; return ( &lt;div&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; setVisible(true)&#125;&gt; 点击弹框 &lt;/Button&gt; &lt;Modal width=&#123;704&#125; title=&quot;确认支付&quot; visible=&#123;visible&#125; onOk=&#123;handleConfirm&#125; onCancel=&#123;handleCancel&#125; destroyOnClose=&#123;true&#125; maskClosable=&#123;false&#125; cancelText=&quot;取消&quot; okText=&quot;确认&quot; confirmLoading=&#123;loading&#125; &gt; &lt;div className=&quot;payContainer&quot;&gt; &lt;p className=&quot;title&quot;&gt;请输入支付密码&lt;/p&gt; &lt;div className=&quot;inputBox&quot;&gt; &#123;number.map((item, index) =&gt; ( &lt;div className=&quot;codeItem&quot; key=&#123;index&#125;&gt; &#123;code[index]&#125; &lt;/div&gt; ))&#125; &lt;Input.Password className=&quot;codeInput&quot; value=&#123;code&#125; maxLength=&#123;number.length&#125; onChange=&#123;onChange&#125; visibilityToggle=&#123;false&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Modal&gt; &lt;/div&gt; );&#125;;export default MyModal; css样式文件处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445.payContainer &#123; margin: 90px 0; text-align: center;&#125;.title &#123; font-size: 14px; font-weight: 400; color: #6b778c; margin-bottom: 24px;&#125;.inputBox &#123; position: relative; width: 336px; margin: 0 auto; display: flex; justify-content: space-between; font-weight: bold;&#125;.codeItem &#123; width: 48px; height: 48px; line-height: 48px; text-align: center; background: #ffffff; border: 1px solid #ebecf0; font-size: 26px;&#125;.codeInput &#123; height: 48px; position: absolute; outline: none; color: transparent; caret-color: #ebecf0; font-size: 28px; padding: 0 14px; letter-spacing: 48px; width: 336px; border: none; background: none; -webkit-appearance: none;&#125;.codeInput:focus &#123; border: none !important; box-shadow: 0 0 0 0 #fff;&#125; 简单的密码输入弹框案例完成，详见在线演示","tags":[]},{"title":"代码改错分支，如何挽救","date":"2020-11-06T13:40:00.000Z","path":"2020/11/06/代码改错分支/","text":"有时候，会出现代码提交在错误的分支或者在错误的分支上修改，如果代码已经推送，可以采取版本回退释放暂存的方法；如果代码仅仅是提交，可以采取选择commit来操作。 代码只是做了commit提交操作 以下的操作可以使Git把当前分支上的修改转移到另一个分支上： 1.获取本次commit的ID （会获取到一个长id如：50734f7dfbaf1401b095ce658efa3d5a2fhjfb1d） 以下命令可以直接获取最新的commit ID： 12// 获取最新的commit idgit rev-parse HEAD 以下命令可以获取git的所有提交日志： 12// 获取所有提交日志，commit后面的那串为所找的idgit log 2.切换到新分支 1git checkout newBranch 3.选择对应的commit进行操作 1git cherry-pick 50734f7dfbaf1401b095ce658efa3d5a2fhjfb1d 4.所有修改过的代码已提交到了当前新分支，git push 就好 代码push到新的分支 以下的操作可以使Git版本回退并操作暂存的改变： 1.利用git log查看版本并回退 1git reset 目标版本号 2.暂存变更 1git stash 3.切换到对应的分支 4.释放暂存 1git stash pop","tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Git/"}]},{"title":"formily的几个核心概念","date":"2020-10-23T14:06:00.000Z","path":"2020/10/23/formily核心概念/","text":"1、JOSN Schema描述 formily 是阿里推出的一套动态化表单的解决方案，用于解决传统模式下写动态表带时代码冗余大、性能低、可维护性差的问题，formily 表单采用标准的 JSON Schema 进性描述，可简单的理解为规范化的 JSON 用于描述 form 表单，比如，下面几个字段规范的定义： type: 字段的数据类型，可以是简单或者复杂数据类型； properties：对象属性，通俗用于对象嵌套描述； x-rules: 字段校验属性，Array类型，支持通用的必填、正则校验、函数校验以及错误信息提示； x-component：字段组件属性，可注入对于的表单组件，相当于FormItem，比如Input、Select等，也可以是CustomComponent，通过渲染层注入组件即可； x-component-props：用于x-component中指定的组件的属性，相当于FormItem的属性。 （因文章篇幅有限，这里仅列举部分伪代码，详细代码见文章底部链接） 一个简单的 Formily 表单可写成如下： 12345678910111213141516171819202122// jsx&lt;SchemaForm labelCol=&#123;24&#125; wrapperCol=&#123;24&#125; components=&#123;&#123; Input, Select, CheckboxGroup: Checkbox.Group, RadioGroup: Radio.Group, RangePicker: DatePicker.RangePicker, Upload &#125;&#125; schema=&#123;simpleSchema&#125; onSubmit=&#123;(values) =&gt; &#123; console.log(values); &#125;&#125;&gt; &lt;FormButtonGroup offset=&#123;0&#125;&gt; &lt;Submit&gt;查询&lt;/Submit&gt; &lt;Reset&gt;重置&lt;/Reset&gt; &lt;/FormButtonGroup&gt;&lt;/SchemaForm&gt; Schema 文件描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// schemaexport const simpleSchema = &#123; type: &quot;object&quot;, properties: &#123; input: &#123; type: &quot;string&quot;, title: &quot;输入&quot;, required: true, &quot;x-component&quot;: &quot;Input&quot;, &quot;x-component-props&quot;: &#123; placeholder: &quot;请输入&quot; &#125; &#125;, select: &#123; type: &quot;number&quot;, title: &quot;下拉选&quot;, required: true, &quot;x-component-props&quot;: &#123; placeholder: &quot;请选择&quot; &#125;, enum: [ &#123; label: &quot;选项一&quot;, value: 1 &#125;, &#123; label: &quot;选项二&quot;, value: 2 &#125; ], &quot;x-component&quot;: &quot;select&quot; &#125;, radio: &#123; title: &quot;单选&quot;, &quot;x-component&quot;: &quot;RadioGroup&quot;, enum: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] &#125;, checkbox: &#123; title: &quot;复选&quot;, &quot;x-component&quot;: &quot;CheckboxGroup&quot;, enum: [ &#123; label: &quot;One&quot;, value: 1 &#125;, &#123; label: &quot;Two&quot;, value: 2 &#125;, &#123; label: &quot;Three&quot;, value: 3 &#125; ] &#125;, dateRange: &#123; type: &quot;object&quot;, title: &quot;时间范围&quot;, required: true, properties: &#123; &quot;[start,end]&quot;: &#123; // title: &quot;RangePicker&quot;, &quot;x-component&quot;: &quot;RangePicker&quot;, &quot;x-component-props&quot;: &#123; placeholder: [&quot;开始时间&quot;, &quot;结束时间&quot;] &#125; &#125; &#125; &#125;, upload: &#123; type: &quot;array&quot;, title: &quot;图片&quot;, &quot;x-component-props&quot;: &#123; listType: &quot;picture-card&quot;, action: &quot;https://www.mocky.io/v2/5cc8019d300000980a055e76&quot; &#125;, &quot;x-component&quot;: &quot;upload&quot;, description: &quot;仅支持图片类数据上传&quot; &#125; &#125;&#125;; 2、表单的生命周期/状态 在formily中，一切的联动操作都源自生命周期函数，可分为表单的生命周期函数和表单字段的操作，在表单的 effects 中实现对于的逻辑操作： 1234567891011121314151617181920212223242526272829// jsx&lt;SchemaForm labelCol=&#123;24&#125; wrapperCol=&#123;24&#125; components=&#123;&#123; Input, Select, &#125;&#125; schema=&#123;basicSchema&#125; actions=&#123;basicAction&#125; effects=&#123;($, &#123; setFieldState &#125;) =&gt; &#123; $(&quot;onFieldValueChange&quot;, &quot;classType&quot;).subscribe((parentState) =&gt; &#123; setFieldState(&quot;currentToggle&quot;, (state) =&gt; &#123; state.visible = parentState.value; &#125;); setFieldState(&quot;currentStatus&quot;, (state) =&gt; &#123; state.value = parentState.value ? &quot;显示&quot; : &quot;隐藏&quot;; &#125;); &#125;); &#125;&#125; onSubmit=&#123;(values) =&gt; &#123; console.log(values); &#125;&#125;&gt; &lt;FormButtonGroup offset=&#123;0&#125;&gt; &lt;Submit&gt;查询&lt;/Submit&gt; &lt;Reset&gt;重置&lt;/Reset&gt; &lt;/FormButtonGroup&gt;&lt;/SchemaForm&gt; Schema 文件描述： 123456789101112131415161718192021222324252627282930313233343536// schmemaexport const basicSchema = &#123; type: &quot;object&quot;, properties: &#123; classType: &#123; type: &quot;number&quot;, enum: [ &#123; label: &quot;显示&quot;, value: 1 &#125;, &#123; label: &quot;隐藏&quot;, value: 0 &#125; ], title: &quot;联动①&quot;, required: true, default: 1, &quot;x-component&quot;: &quot;select&quot;, description: &quot;利用生命周期做联动&quot; &#125;, currentToggle: &#123; type: &quot;string&quot;, title: &quot;联动①组件&quot;, required: true, &quot;x-component&quot;: &quot;Input&quot; &#125;, currentStatus: &#123; type: &quot;string&quot;, title: &quot;联动①状态&quot;, required: true, &quot;x-component&quot;: &quot;Input&quot; &#125;, &#125;&#125;; 如上述案例所示，我们在 SchemaForm 的 effects 中通过订阅生命周期函数来监听字段状态的变化，从而达到表单联动的效果；以上是一种写法，触发生命周期还有另一种写法，通过解构出 FormEffectHooks 对象： 123456789101112131415161718// jsximport &#123; FormEffectHooks, createFormActions &#125; from &#x27;@formily/next&#x27;const &#123; onFieldValueChange$, onFormInit$ &#125; = FormEffectHooksconst &#123; setFieldState, getFieldState &#125; = createFormActions()// 表单初始化完成后，执行将字段aa的值修改为123onFormInit$().subscribe(() =&gt; &#123; setFieldValue(&#x27;aa&#x27;, 123)&#125;)// 当字段bb的值发生变化后，修改字段cc的显示隐藏状态onFieldValueChange$(&#x27;bb&#x27;).subscribe( fieldState =&gt; &#123; // fieldState为bb的当前状态值 setFieldState(&#x27;cc&#x27;, state =&gt; &#123; // state为cc的当前状态值，根据字段bb的值是否为123来决定cc的隐藏属性。 state.visible = fieldState.value === 123 &#125;)&#125;) 表单的生命周期函数有很多种，详见官方文档，一些常用的生命周期函数如下： 常量名 常量值 描述 Hook 返回值 ON_FORM_SUBMIT onFormSubmit 表单提交时触发 onFormSubmit$ FormState ON_FORM_RESET onFormReset 表单重置时触发 onFormReset$ FormState ON_FIELD_CHANGE onFieldChange 字段状态发生变化时触发 onFieldChange$ FieldState ON_FIELD_INPUT_CHANGE onFieldInputChange 字段输入事件触发时触发 onFieldInputChange$ FieldState ON_FIELD_VALUE_CHANGE onFieldValueChange 字段值变化时触发 onFieldValueChange$ FieldState 3、表单操作actions/effects 12345678910111213// jsx// 片段一$(&quot;onFieldValueChange&quot;, &quot;classType&quot;).subscribe((parentState) =&gt; &#123; setFieldState(&quot;currentToggle&quot;, (state) =&gt; &#123; state.visible = parentState.value; &#125;);&#125;);// 片段二onFieldValueChange$(&#x27;bb&#x27;).subscribe( fieldState =&gt; &#123; setFieldState(&#x27;cc&#x27;, state =&gt; &#123; state.visible = fieldState.value === 123 &#125;)&#125;) 上面只演示了两段伪代码片段，详情功能可参考上一小节表单的生命周期的代码，我们只需要知道：所有的联动操作都需要在effects实现，而操作Form API都通过actions来控制，详细接口参考文档链接。 4、表单的路径系统 表单的路径系统相当于CSS中的选择器，可以通过路径系统来匹配需要操作的字段；这里的匹配方式大概可分为两种，一种是通配符匹配，另一种是target目标匹配。 4.1 通配符匹配 12345678910// 通配符匹配 匹配array字段下任意字段之后是aa的字段（array -&gt; 任意 -&gt; aa）onFieldValueChange$(&#x27;array.*.aa&#x27;).subscribe((parentState) =&gt; &#123; // ...&#125;)// 通配符匹配 当aa字段值改变后匹配所有的bb、cc、dd字段onFieldValueChange$(&#x27;aa&#x27;).subscribe((&#123; name, value &#125;) =&gt; &#123; setFieldState(&#x27;*(bb,cc,dd)&#x27;, state =&gt; &#123; state.visible = value &#125;)&#125;) 4.2 target目标匹配 target 相邻查找 prevPath.[].fieldName代表当前行字段 prevPath.[+].fieldName代表下一行字段 prevPath.[-].fieldName代表上一行字段 prevPath.[+2].fieldName代表下下一行字段 prevPath.[-2].fieldName代表上上一行字段 一次可以继续往下递增或者递减 target 向前路径查找 .path.a.b代表基于当前字段路径往后计算 …path.a.b代表往前计算相对路径 …path.a.b代表继续往前计算相对路径 以此类推 5、x-linkages属性简单联动 上面说到，一切的联动都源自生命周期，而 x-linkages 用于在协议层描述简单联动，注意，这个只是简单联动，它无法描述异步联动，也无法描述联动过程中的各种复杂数据处理，以下是一个简单的联动案例。 123456789101112131415&lt;SchemaForm labelCol=&#123;24&#125; wrapperCol=&#123;24&#125; components=&#123;components&#125; schema=&#123;basicSchema&#125; actions=&#123;basicAction&#125; onSubmit=&#123;(values) =&gt; &#123; console.log(values); &#125;&#125;&gt; &lt;FormButtonGroup offset=&#123;0&#125;&gt; &lt;Submit&gt;查询&lt;/Submit&gt; &lt;Reset&gt;重置&lt;/Reset&gt; &lt;/FormButtonGroup&gt;&lt;/SchemaForm&gt; Schema描述文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export const basicSchema = &#123; type: &quot;object&quot;, properties: &#123; linkTwo: &#123; type: &quot;number&quot;, enum: [ &#123; label: &quot;联动②显示&quot;, value: 1 &#125;, &#123; label: &quot;联动②隐藏&quot;, value: 0 &#125;, &#123; label: &quot;联动②控制schema的title字段&quot;, value: 3 &#125; ], title: &quot;联动②&quot;, required: true, default: 1, &quot;x-component&quot;: &quot;select&quot;, &quot;x-linkages&quot;: [ &#123; type: &quot;value:visible&quot;, target: &quot;linkTwoEle&quot;, condition: &quot;&#123;&#123; $value === 1 || $value === 3 &#125;&#125;&quot; &#125;, &#123; type: &quot;value:schema&quot;, target: &quot;linkTwoEle&quot;, condition: &quot;&#123;&#123; $value === 3 &#125;&#125;&quot;, //当值为3时发生联动 schema: &#123; title: &quot;这是联动的标题&quot; &#125; &#125; ], description: &quot;利用 x-linkages 属性做联动，这个只是简单联动，它无法描述异步联动，也无法描述联动过程中的各种复杂数据处理。&quot; &#125;, linkTwoEle: &#123; type: &quot;object&quot;, title: &quot;联动②组件&quot;, required: true, properties: &#123; &quot;[start,end]&quot;: &#123; // title: &quot;RangePicker&quot;, &quot;x-component&quot;: &quot;RangePicker&quot;, &quot;x-component-props&quot;: &#123; placeholder: [&quot;开始时间&quot;, &quot;结束时间&quot;] &#125; &#125; &#125; &#125;, &#125;&#125;; 这里 link 联动的 Type 类型主要有三种： value:state，由值变化控制指定字段的状态 value:visible，由值变化控制指定字段显示隐藏 相当于 value:state 的一种特例情况，即 state.visible value:schema，由值变化控制指定字段的 schema. 相当于 value:state 的一种特例情况，即 state.props condition 为link联动触发的条件，target 为上小节描述的target目标匹配。 6、表单的扩展机制（自定义生命周期、自定义扩展状态、自定义校验规则、自定义组件） 6.1 自定义生命周期: 自定义事件派发 自定义事件大概可分为两种：一是通过 createFormActions 全局派发事件，二是在 effects 逻辑联动中通过 notify 来派发事件。 1234567891011121314151617181920212223242526272829const extendAction = createFormActions();// 全局自定义事件extendAction.dispatch(&quot;customEvent1&quot;, &#123; value: 666, text: &quot;全局的payload&quot; &#125;);const myFormily = () =&gt; ( &lt;SchemaForm labelCol=&#123;24&#125; wrapperCol=&#123;24&#125; components=&#123;components&#125; schema=&#123;extendSchema&#125; actions=&#123;extendAction&#125; effects=&#123;($, &#123; notify &#125;) =&gt; &#123; // effect派发自定义事件 $(&quot;onFieldValueChange&quot;, &quot;a2&quot;).subscribe((parentState) =&gt; &#123; notify(&quot;customEvent2&quot;, parentState); &#125;); &#125;&#125; onSubmit=&#123;(values) =&gt; &#123; console.log(values); &#125;&#125; &gt; &lt;FormButtonGroup offset=&#123;0&#125;&gt; &lt;Submit&gt;查询&lt;/Submit&gt; &lt;Reset&gt;重置&lt;/Reset&gt; &lt;/FormButtonGroup&gt; &lt;/SchemaForm&gt;);export default myFormily; 派发事件之后，需要在自定义组件内通过 useFormEffects 监听自定义事件 123456789// 组件内通过 useFormEffects 监听自定义事件useFormEffects(($, &#123; notify, setFieldState, getFieldState &#125;) =&gt; &#123; $(&quot;customEvent1&quot;).subscribe((payload) =&gt; &#123; console.log(payload); &#125;); $(&quot;customEvent2&quot;).subscribe((payload) =&gt; &#123; console.log(payload); &#125;);&#125;); 6.2 自定义扩展状态：自定义formily组件状态 表单的自定义状态在自定义组件中使用的比较多，类似于 react Hook 的形式，仅有两种形式： 123456789101112import &#123; useFieldState, useFormState &#125; from &#x27;@formily/next&#x27;;//为当前组件对应的字段中添加自定义的状态字段extendState1和extendState2.const [state, setFieldState] = useFieldState(&#123; extendState1: &#x27;something&#x27;, extendState2: &#x27;something&#x27;&#125;)//为当前组件所在的表单中添加自定义的状态字段extendState1和extendState2.const [formState, setFormState] = useFormState(&#123; extendState1: &#x27;something&#x27;, extendState2: &#x27;something&#x27;&#125;) 自定义状态字段和系统提供的状态字段一致，自定义状态改变会也触发 onFieldChange 或 onFormChange 事件。 6.3 自定义组件: 自定义字段组件和虚拟布局组件 Formily 可以通过自定义组件来满足更加复杂的业务需求，通过给组件添加 isFieldComponent 属性即可，一个简单的字段组件如下： 1234567891011121314151617181920212223import React from &quot;react&quot;;import &#123; useFormEffects, useFieldState &#125; from &quot;@formily/antd&quot;;const CustomFieldComponent = (props) =&gt; &#123; const &#123; value, schema, className, editable, path, mutators, form &#125; = props; //获取”x-component-props&quot;的属性值 const componentProps = schema.getExtendsComponentProps() || &#123;&#125;; return ( &lt;div&gt; &lt;h3 style=&#123;&#123; fontSize: 14 &#125;&#125;&gt;这是自定义字段组件描述&lt;/h3&gt; &lt;input value=&#123;value || &quot;&quot;&#125; onChange=&#123;(e) =&gt; mutators.change(e.target.value)&#125; /&gt; &lt;/div&gt; );&#125;;CustomFieldComponent.isFieldComponent = true;export default CustomFieldComponent; 当然，Formily 也提供 registerVirtualBox 方法自定义虚拟组件，主要用于表单布局方面： 123456789// 注册virtual组件 一般用于布局registerVirtualBox(&quot;CustomLayout&quot;, (&#123; children, schema &#125;) =&gt; &#123; return ( &lt;div style=&#123;&#123; border: &quot;1px solid red&quot;, padding: 10 &#125;&#125;&gt; &#123;children&#125; &#123;schema[&quot;x-component-props&quot;][&quot;say&quot;]&#125; &lt;/div&gt; );&#125;); 组件定义好后，可以通过局部注册、全局注册、全局批量扩展三种方式注入到Formily表单系统中 12345678//局部实例注册&lt;SchemaForm components=&#123;&#123; CustomComponent, CustomFieldComponent &#125;&#125;/&gt;//全局注册registerFormField(&#x27;CustomComponent2&#x27;, connect()(CustomComponent))//全局批量扩展registerFormFields(&#123; CustomComponent3: connect()(CustomComponent) &#125;) 6.4 自定义校验：自定义x-rules校验、自定义函数验证 在校验中，Formily也提供两种校验方式，一种是直接在schema中定义 x-rules 校验，另一种是通过自定义校验函数来校验，后一种方式常用于校验函数复用。 12345678910import &#123; registerValidationRules&#125; from &quot;@formily/antd&quot;;// 自定义函数校验registerValidationRules(&#123; customRule2: (value) =&gt; &#123; return value === &quot;123&quot; ? &quot;不能等于123&quot; : &quot;&quot;; &#125;&#125;); Schema描述文件 12345678910111213141516171819202122232425export const extendSchema = &#123; type: &quot;object&quot;, properties: &#123; a1: &#123; type: &quot;number&quot;, title: &quot;x-rules校验&quot;, required: true, &quot;x-component&quot;: &quot;input&quot;, &quot;x-rules&quot;: &#123; validator: (value) =&gt; &#123; return value === &quot;123&quot; ? &quot;不能等于123&quot; : &quot;&quot;; &#125; &#125; &#125;, a3: &#123; type: &quot;string&quot;, title: &quot;自定义函数校验&quot;, required: true, &quot;x-component&quot;: &quot;Input&quot;, &quot;x-rules&quot;: &#123; customRule2: true &#125; &#125;, &#125;&#125;; github案例详见 github仓库 在线演示案例详见 codesandbox案例","tags":[]},{"title":"JS常见的数据格式处理","date":"2020-08-15T14:55:00.000Z","path":"2020/08/15/数据处理/","text":"开发中后台项目的时候，前端最多的就是 JS 的数据处理，过滤、转换、合并等等，这里收集了工作中常见的数据处理的方式，并持续更新。 数组对象去重 1234567891011121314151617181920212223let params = [ &#123; id: 1, name: &#x27;Lina&#x27; &#125;, &#123; id: 2, name:&#x27;Bob&#x27; &#125;, &#123; id:1, name:&#x27;Lina&#x27; &#125;]let resultParams = Object.values(params.reduce((item, next) =&gt; &#123; item[next.id] = next return item&#125;,&#123;&#125;))console.log(resultParams)// [&#123;id: 1, name: &#x27;Lina&#x27;&#125;,&#123;id: 2, name: &#x27;Bob&#x27;&#125;] 数组对象过滤 1234567891011121314151617181920212223let paramsList = [ &#123; id: 1, name: &#x27;Lina&#x27;, isEnable: true &#125;, &#123; id: 2, name: &#x27;Bob&#x27;, isEnable: false &#125;, &#123; id: 3, name: &#x27;Tom&#x27;, isEnable: true &#125;]let enableList = paramsList.filter(_item =&gt; _item.isEnable)console.log(enableList)// [&#123;id: 1, name: &#x27;Lina&#x27;, isEnable: true&#125;, &#123;id: 3, name: &#x27;Tom&#x27;, isEnable: true&#125;] 对象转换为数组 1234567let o = &#123;id: 1, name: &#x27;Lina&#x27;&#125;Object.values(o)Object.keys(o)// [&quot;id&quot;, &quot;name&quot;]// [1, &quot;Lina&quot;] 数组对象转为大对象 12345678let attrArrayWithObj = [&#123;aa: &#x27;11&#x27;, bb: &#x27;22&#x27;, cc: &#x27;33&#x27;&#125;]let attrWithObj = &#123;&#125;for(let t of attrArrayWithObj )&#123; attrWithObj = &#123;...attrWithObj, ...t&#125;&#125;// &#123;aa: &quot;11&quot;, bb: &quot;22&quot;, cc: &quot;33&quot;&#125; 提取数组对象中特定的值作为一个数组 12345678910111213141516171819let arr = [ &#123; &#x27;id&#x27;: &#x27;1&#x27;, &#x27;name&#x27;: &#x27;小红&#x27;, &#125;, &#123; &#x27;id&#x27;: &#x27;2&#x27;, &#x27;name: &#x27;小白&#x27;, &#125;, &#123; &#x27;id&#x27;: &#x27;3&#x27;, &#x27;name&#x27;: &#x27;小黄&#x27;, &#125;];// 使用map()生成数组let new_arr = arr.map(obj =&gt; &#123;return obj.name&#125;)// 输出 [&#x27;小红&#x27;,&#x27;小白&#x27;,&#x27;小黄&#x27;] SKU组合算法（用于商品或购物） 1234567891011121314151617181920212223242526/** * @description SUK组合 * @param &#123;[[],[]..]&#125; chunks 传入不同的属性值数组进行组合 */const SKUCombine = (arr: any[]) =&gt; &#123; if(arr.length)&#123; if (arr[0].children) arr = arr.map((item: any) =&gt; &#123; return item = item.children &#125;) if (arr.length === 1) return arr[0] else &#123; let arrySon = [] arr[0].forEach((_: any, index: React.ReactText) =&gt; &#123; arr[1].forEach((_: any, index1: React.ReactText) =&gt; &#123; arrySon.push([].concat(arr[0][index], arr[1][index1])) &#125;) &#125;) arr[0] = arrySon arr.splice(1, 1) // 递归 return SKUCombine(arr) &#125; &#125;&#125; 找出数组对象中符合条件的某项的某个值 12345678910111213141516171819let arr = [ &#123; id: 1, name: &#x27;Lina&#x27; &#125;, &#123; id: 2, name:&#x27;Bob&#x27; &#125;, &#123; id:3, name:&#x27;Tom&#x27; &#125;]arr.find(__item =&gt; __item.name===&#x27;Tom&#x27;).id// 3 数组对象按属性对object分类 1234567891011121314151617181920let people = [ &#123; name: &#x27;Alice&#x27;, age: 21 &#125;, &#123; name: &#x27;Max&#x27;, age: 20 &#125;, &#123; name: &#x27;Jane&#x27;, age: 20 &#125;]function groupBy(objectArray, property) &#123; return objectArray.reduce(function (acc, obj) &#123; let key = obj[property]; if (!acc[key]) &#123; acc[key] = [] &#125; acc[key].push(obj) return acc &#125;, &#123;&#125;)&#125;let groupedPeople = groupBy(people, &#x27;age&#x27;)// &#123; 20: [&#123; name: &#x27;Max&#x27;, age: 20 &#125;,&#123; name: &#x27;Jane&#x27;, age: 20 &#125;], 21: &#123; name: &#x27;Alice&#x27;, age: 21 &#125; &#125; 一维数组转为键值对象 123456789101112let arr = [11,22,33,44,55,66]arr.reduce((a, b, idx) =&gt;&#123; if (idx % 2) &#123; a[Math.ceil(idx / 2) - 1].lat = b return a &#125; else return [...a, &#123;lng: b&#125;]&#125;,[])// [&#123;lng: 11, lat: 22&#125;,// &#123;lng: 33, lat: 44&#125;,// &#123;lng: 55, lat: 66&#125;] 二维数组转为一维数组 1234567let flattened = [[0, 1], [2, 3], [4, 5]].reduce( function(a, b) &#123; return a.concat(b); &#125;, []);// flattened is [0, 1, 2, 3, 4, 5] js 数组过滤空值（undefined、null、&quot;&quot;、0、false、NaN） 1const arr = [undefined, null, &quot;&quot;, 0, false, NaN, 1, 2].filter(Boolean); 向上递归找所有父级 1234567891011121314151617181920212223/** * arr1: 树形数组； * id: 指定的id * */function familyTree (arr1, id) &#123; var temp = [] var forFn = function (arr, id) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; var item = arr[i] if (item.id === id) &#123; temp.push(item) forFn(arr1, item.parentId) break &#125; else &#123; if (item.children) &#123; forFn(item.children, id) &#125; &#125; &#125; &#125; forFn(arr1, id) return temp&#125; 借助lodash和moment.js获取日期段的每一天 1234567891011121314151617181920212223242526272829303132333435// 先安装moment// npm i moment// 再安装Lodash，可以用它内部封装好的方法，简单实用// npm i lodashconst moment = require(&quot;moment&quot;);const _ = require(&quot;lodash&quot;);// 假设需要查询2019-06-25至2019-12-31号之间每一天的00:00至23:59这个时间段的数据// 将时间转换为moment时间格式const start = &quot;2019-06-25&quot;; // 开始时间const start_time = moment(start);console.log(moment(start_time)); // moment(&quot;2019-06-25T00:00:00.000&quot;)const end = &quot;2019-12-31&quot;;const end_time = moment(end).endOf(&quot;d&quot;);console.log(end_time); // endOf(&quot;d&quot;)为当天的结束时间 moment(&quot;2019-12-31T23:59:59.999&quot;)// 开始计算这两个时间段相差的天数const diff_times = end_time.diff(start_time,&quot;d&quot;);console.log(diff_times); // 189// lodash中内置的循环器，可以指定循环次数// 再定义一个数组，用来存放相差的每一天日期const arr = [];_.times(diff_times, i =&gt; &#123; //每次重新初始化开始时间，因为我碰到了深拷贝的问题 const new_start_time = moment(start_time); //数组下标从０开始，可以用它进行每次的天数递增 arr.push(new_start_time.add(i, &quot;days&quot;).format(&quot;YYYY-MM-DD&quot;));&#125;);console.log(arr);/* [ &#x27;2019-06-25&#x27;,&#x27;2019-06-26&#x27;,&#x27;2019-06-27&#x27;,&#x27;2019-06-28&#x27;, ...] */ 同时检验字符串和中文字符数 123456789101112131415/** * maxByte: number 最大字符数 * */export const validatorByte = (rule, value, callback, maxByte: number) =&gt; &#123; try &#123; let str = value str = str.replace(/[\\u4e00-\\u9fa5]/g, &#x27;OO&#x27;) if(str.length &gt; maxByte) throw new Error(`最多输入$&#123;maxByte&#125;个字符，$&#123;Math.floor(maxByte / 2)&#125;个汉字`); else callback() &#125; catch (err) &#123; callback(err) &#125;&#125; 判断一个字符串是否为数字 简单的判断字符串是否为数字的方法就是利用isNaN(),如果返回true,则该字符串不为数字，否则为数字","tags":[]},{"title":"hexo生产下异常处理（持续更新）","date":"2020-08-14T13:54:00.000Z","path":"2020/08/14/hexo异常/","text":"一、样式缺失的问题 在hexo g生成站点文件的时候，经常会出现样式丢失的问题，当你去查看css目录下的文件，可能会发现生成的文件为0kb，空内容，可参考以下解决方式： 打开根目录的配置文件_config.yml 把 15 行的 url 改成htpps开头的仓库名,比如: https://github.com/xxxx/xxx.github.io.git 把 16 行的 root 改成 /myBlog.github.io/ 即 /你的项目仓库名/ 然后重新部署 hexo g &amp;&amp; hexo d 要注意的是，如果你的站点不是托管在 github 等页面服务上，而是复制到自己的服务器上，请把步骤 2 的 root 改为 / 二、升级最新的 hexo 版本后报 Cannot read property ‘groupBy’ of undefined 由于最新的版本移除内部的 lodash 依赖，所有使用了 lodash 函数的情况下可能会报类似的错误，可参考以下解决方式： 在 hexo 文件目录下安装 loadsh npm install lodash 进入 scripts 目录（不存在则创建），新建一个 js 文件（名称无所谓），写入如下内容: 12345const _ = require(&#x27;lodash&#x27;);hexo.extend.filter.register(&#x27;template_locals&#x27;, locals =&gt; &#123; locals._ = _;&#125;); 本方式参考 github Issues 三、node14 和旧版 hexo 不兼容问题 1234567(node:3908) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)(node:3908) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency(node:3908) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency(node:3908) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency(node:3908) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency(node:3908) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency 解决方式：使用npm-check把所有的 npm 依赖更新为最新版本，hexo 新版已经对兼容问题做了处理。","tags":[]},{"title":"useContext留言板案例","date":"2020-08-02T03:54:00.000Z","path":"2020/08/02/useContext案例/","text":"react Hook 提供 useContext 函数，方便深层次嵌套组件在不使用状态管理器的情况下实现组件间的数据共享，不需要再像之前使用 Customer 消费者函数来获取数据。当我们需要修改 context 的数据时，只需要通过 context 传递一个函数即可。 在父组件中，通过 Provider 提供数据，并在创建 context 时候声明一个用于修改数据的函数。 12345678910111213141516171819202122232425262728293031323334353637383940// postPage.tsximport React, &#123; useState, createContext &#125; from &quot;react&quot;;import &#123; Card &#125; from &quot;antd&quot;;import Comments from &quot;./comments&quot;;export const CommentContext = createContext(&#123; name: &quot;&quot;, comments: &quot;&quot;, onChangeContext: (values: any) =&gt; &#123;&#125;&#125;);const PostPage: React.FC&lt;&#123;&#125;&gt; = props =&gt; &#123; const [contextData, setContextData] = useState(&#123; name: &quot;&quot;, comments: &quot;&quot; &#125;); const onChangeContext = (v: any) =&gt; &#123; console.log(&quot;执行了改变共享Context数据&quot;, v); setContextData(&#123; ...contextData, ...v &#125;); &#125;; const values: any = &#123; ...contextData, onChangeContext &#125;; return ( &lt;div&gt; &lt;Card title=&quot;文章评论&quot;&gt; &lt;CommentContext.Provider value=&#123;values&#125;&gt; &lt;Comments /&gt; &lt;/CommentContext.Provider&gt; &lt;/Card&gt; &lt;/div&gt; );&#125;;export default PostPage; 在子组件中显示一个表单，用于提交留言信息，导入父组件中声明的 context 对象，调用 context 中的函数传入对于的表单数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// comments.tsximport React, &#123; useContext &#125; from &quot;react&quot;;import &#123; Button, Card, Form, Input &#125; from &quot;antd&quot;;import &#123; CommentContext &#125; from &quot;./postPage&quot;;import ShowComments from &quot;./showComments&quot;;const layout = &#123; labelCol: &#123; span: 4 &#125;, wrapperCol: &#123; span: 16 &#125;&#125;;const tailLayout = &#123; wrapperCol: &#123; offset: 4, span: 16 &#125;&#125;;const Comments: React.FC&lt;&#123;&#125;&gt; = props =&gt; &#123; const &#123; onChangeContext &#125; = useContext(CommentContext); const onFinish = (values: any) =&gt; &#123; onChangeContext(&#123; comments: values.comment, name: values.username &#125;); console.log(&quot;Success:&quot;, values); &#125;; return ( &lt;div&gt; &lt;Card title=&quot;评论显示&quot;&gt; &lt;ShowComments /&gt; &lt;/Card&gt; &lt;Card title=&quot;留下足迹&quot;&gt; &lt;Form &#123;...layout&#125; name=&quot;comments&quot; onFinish=&#123;onFinish&#125;&gt; &lt;Form.Item label=&quot;用户&quot; name=&quot;username&quot; rules=&#123;[&#123; required: true, message: &quot;Please input your username!&quot; &#125;]&#125; &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label=&quot;评论&quot; name=&quot;comment&quot; rules=&#123;[&#123; required: true, message: &quot;Please input your comment!&quot; &#125;]&#125; &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item &#123;...tailLayout&#125;&gt; &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt; 提交 &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/Card&gt; &lt;/div&gt; );&#125;;export default Comments; 最后在评论显示区显示对于的内容。 1234567891011121314151617// showComments.tsximport React, &#123; useContext &#125; from &quot;react&quot;;import &#123; CommentContext &#125; from &quot;./postPage&quot;;const ShowComments: React.FC&lt;&#123;&#125;&gt; = props =&gt; &#123; const &#123; name, comments &#125; = useContext(CommentContext); return ( &lt;div&gt; &lt;p&gt;&#123;name &amp;&amp; comments &amp;&amp; `$&#123;name&#125;：$&#123;comments&#125;`&#125;&lt;/p&gt; &lt;/div&gt; );&#125;;export default ShowComments;","tags":[{"name":"hook","slug":"hook","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/hook/"}]},{"title":"ts别名和类型断言","date":"2020-07-26T11:53:00.000Z","path":"2020/07/26/ts别名和类型断言/","text":"Typescript 通过 type关键字来做别名，结合联合类型能够更加灵活地使用；另外提供类型断言，其语法是：&lt;类型&gt;值 或者 值 as 类型；类型断言并不是类型转换，是在已知多个类型的情况下我们把它断言的更加具体一些，所以类型断言是不能够断言联合类型中没有的类型。 12345678910111213141516171819202122232425262728293031323334353637383940// 通过type关键字 做别名type PlusType = (x: number, y: number) =&gt; numberfunction sum(x: number, y: number): number &#123; return x + y&#125;const sum2: PlusType = sum// 给函数或者联合类型做别名type NameResolve = () =&gt; stringtype NameOrResolver = string | NameResolvefunction getName(n: NameOrResolver): string&#123; if(typeof n === &#x27;string&#x27;)&#123; return n &#125;else &#123; return n() &#125;&#125;// 类型断言// 不能够断言联合类型中没有的类型function getLength(input: string|number): number&#123; // const str = input as String // if(str.length)&#123; // return str.length // &#125;else&#123; // const number = input as Number // return number.toString().length // &#125; /* 更加简单的写法 */ if((&lt;string&gt;input).length)&#123; return (&lt;string&gt;input).length &#125;else&#123; return input.toString().length &#125;&#125;","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Typescript/"}]},{"title":"ts的Class类与接口","date":"2020-07-19T14:12:00.000Z","path":"2020/07/19/ts的class与接口/","text":"Typescript 的 class 类是 js 中类的超集，在原有 js 标准 class 基础上，提供更加丰富的修饰符，默认情况下，所有的属性类型都是 public，可以自由访问，另外提供只允许在 class 内部访问的 private 修饰符，它和 protected 区别在于 protected 可以在其子类实例中访问；另外还提供了只读修饰符 readonly 和可通过类名来访问的静态属性 static 修饰符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// es6中的class类class Animal &#123; // 另外的四类属性修饰符 // protected private readonly static public name: string; constructor(name: string)&#123; this.name = name &#125; run()&#123; return `$&#123;this.name&#125; is running` &#125;&#125;const snake = new Animal(&#x27;Lina&#x27;)console.log(snake.run())class Dog extends Animal &#123; bark()&#123; return `$&#123;this.name&#125; is barking` &#125;&#125;const erha = new Dog(&#x27;erha&#x27;)console.log(erha.run())console.log(erha.bark())class Cat extends Animal &#123; constructor(name)&#123; super(name) &#125; run()&#123; return &#x27;Meow, &#x27; + super.run() &#125;&#125;const mao = new Cat(&#x27;maomao&#x27;)console.log(mao.run())// class与接口interface Radio &#123; switchRadio(): void;&#125;interface Battery &#123; checkBatteryStatus();&#125;interface RadioWithBattery extends Radio&#123; checkBatteryStatus();&#125;class Car implements Radio&#123; switchRadio()&#123; // do something &#125;&#125;class CellPhone implements RadioWithBattery&#123; switchRadio()&#123; // do something &#125; checkBatteryStatus()&#123; // do something &#125;&#125;","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Typescript/"}]},{"title":"ts interface接口、函数和类型推断","date":"2020-07-12T12:12:00.000Z","path":"2020/07/12/ts接口函数类型推断/","text":"Typescript 提供接口，使用接口可以更加集中的维护文件中使用的数据类型，便于数据类型文件的模块化。 12345678910111213141516171819202122232425262728293031323334353637383940414243// interface接口 age为可选参数interface IPerson &#123; readonly id: number; name:string; age?:number;&#125;let user: IPerson = &#123; id: 1, name: &#x27;Tom&#x27;,&#125;// 函数 参数可选function add(x: number, y: number, z?: number)&#123; if(typeof z === &#x27;number&#x27;) return x + y + z else return x + y&#125;let result = add(2, 3, 5)// 函数 参数默认值function add(x: number, y: number, z: number = 5)&#123; if(typeof z === &#x27;number&#x27;) return x + y + z else return x + y&#125;let result = add(2, 3)// 函数 定义返回值类型const add = function(x: number, y: number, z: number = 10): number &#123; if(typeof z === &#x27;number&#x27;)&#123; return x + y + z &#125;else&#123; return x + y &#125;&#125;// 使用箭头函数 定义参数类型 参数可选 返回值类型const add2: (x: number, y: number, z?: number) =&gt; number = add","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Typescript/"}]},{"title":"Typescript枚举类型Enum","date":"2020-07-05T13:48:00.000Z","path":"2020/07/05/Typescript枚举类型Enum/","text":"Typescript 的枚举类型是对 JavaScript 标准数据类型的扩展对于熟悉C语言的开发者来说，枚举类型并不陌生，它是一系列数值集合，我们可以更很方便维护一组数据集。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 数字枚举// 数字会有向下自增的功能 默认首项是0enum Direction &#123; Up = 1, Down, Left, Right&#125;console.log(Direction.Down) // 2// 字符串枚举enum Direction &#123; Up = &#x27;Up&#x27;, Down = &#x27;Down&#x27;, Left = &#x27;Left&#x27;, Right = &#x27;RIGHT&#x27;,&#125;const value = &#x27;Up&#x27;if(value===Direction.Up)&#123; console.log(&#x27;go Up!&#x27;)&#125;// 编译成js后var Direction;(function (Direction) &#123; Direction[&quot;Up&quot;] = &quot;Up&quot;; Direction[&quot;Down&quot;] = &quot;Down&quot;; Direction[&quot;Left&quot;] = &quot;Left&quot;; Direction[&quot;Right&quot;] = &quot;RIGHT&quot;;&#125;)(Direction || (Direction = &#123;&#125;));var value = &#x27;Up&#x27;;if (value === Direction.Up) console.log(&#x27;go Up!&#x27;);// 给枚举加上常量控制const enum Direction &#123; Up = &#x27;Up&#x27;, Down = &#x27;Down&#x27;, Left = &#x27;Left&#x27;, Right = &#x27;RIGHT&#x27;,&#125;const value = &#x27;Up&#x27;if(value===Direction.Up)&#123; console.log(&#x27;go Up!&#x27;)&#125;// 编译成js后var value = &#x27;Up&#x27;;if (value === &quot;Up&quot; /* Up */) &#123; console.log(&#x27;go Up!&#x27;);&#125;/** 可见，const常量有助于提高代码性能。**/","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Typescript/"}]},{"title":"Typescript基础类型","date":"2020-06-28T14:00:00.000Z","path":"2020/06/28/Typescript基础类型/","text":"Typescript 是 JavaScript 的超集，它的使用可以更加规范Js编码时的数据类型，并且配合相应的 IDE，在组件复用的时候也具有更加智能的提示，下面来看下 Typescript 的一些基本类型。 12345678910111213141516171819202122232425let isChecked: boolean = true let age: number = 23let binaryNumber: number = 0b1111let firstName: string = &#x27;Bob&#x27;let message: string = `Hi, $&#123;firstName&#125;, age is $&#123;age&#125;`let u: undefined = undefinedlet n: null = null// 注意： undefined和null是任何基础类型的子类型let num: number = undefinedlet notSure: any = 4notSure = &quot;maybe it is a string&quot;notSure = true// 联合类型let numberOrString: number | string = 10numberOrString = &#x27;abc&#x27;// 数组和元组let arrOfNumber: number[] = [1, 2, 4]let user: [string, number] = [&#x27;Tom&#x27;, 2]","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Typescript/"}]},{"title":"useEffect实现计时器效果","date":"2020-06-20T15:00:00.000Z","path":"2020/06/20/useEffect计时器/","text":"在React以前的版本中，各类生命周期函数的提供，在给我们灵活的操作组件带来便利的同时，也造成了某些生命周期函数利用率低，代码冗余的现象，所以在后来的版本中，基于函数式组件React提供了React Hook的操作，使得函数是组件更加灵活，下面就是利用useEffect来实现的一个计时器效果。 12345678910111213141516171819202122232425262728293031323334353637import React, &#123;useState,useEffect&#125; from &#x27;react&#x27;;let timeChange; //声明定时器const Timer = () =&gt; &#123; const [current, setCurrent] = useState(0); // timer const [time, setTime] = useState(5); // timer useEffect(() =&gt; &#123; clearInterval(timeChange) &#125;, []) useEffect(() =&gt; &#123; console.log(current) if(current === 1) runTimerJump() &#125;, [current]) useEffect(() =&gt; &#123; if(time === 0)&#123; clearInterval(timeChange) setTime(5) console.log(&#x27;倒计时完毕！&#x27;) &#125; &#125;, [time]) const runTimerJump = () =&gt; &#123; timeChange = setInterval(() =&gt; setTime(t =&gt; --t), 1000) &#125; return ( &lt;&gt; &lt;p&gt; &lt;span&gt;&#123;time&#125;s 后执行对应的操作&lt;/span&gt; &lt;br /&gt; &lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;()=&gt;setCurrent(1)&#125;&gt;点击开启&lt;/button&gt;&lt;/p&gt; &lt;/&gt; )&#125;export default Timer","tags":[{"name":"hook","slug":"hook","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/hook/"}]},{"title":"react Hook上手","date":"2020-05-31T02:54:00.000Z","path":"2020/05/31/react_hook/","text":"Hook 是 React 16.8的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 1. useState 使用这个 hook 可以方便我们在函数组件中操作 state，下面例子演示和如何使用 useState 来操作基本类型、数组、对象、函数不同类型的 state。 1234567891011121314151617181920212223242526272829303132import React, &#123; useState &#125; from &#x27;react&#x27;;const Index = () =&gt; &#123; const [count,setCount] = useState(0) const [obj,setObj] = useState(&#123;name:&#x27;Lisi&#x27;&#125;) const [arr,setArr] = useState([1,2,3]) const [func,setFunc] = useState(()=&gt;&#123; return &#123;name: &#x27;func&#x27;&#125; &#125;) return ( &lt;div&gt; &lt;p&gt;count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;+1&lt;/button&gt; &lt;p&gt;name: &#123;obj.name&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setObj(&#123;name:&#x27;Mazi&#x27;&#125;)&#125;&gt;changeObjectName1&lt;/button&gt; &lt;button onClick=&#123;()=&gt;setObj(&#123; ...obj, name: &#x27;Loali&#x27; &#125;)&#125;&gt;changeObjectName2&lt;/button&gt; &lt;button onClick=&#123;()=&gt;setObj(Object.assign(&#123;&#125;,obj,&#123;name:&#x27;Lili&#x27;&#125;))&#125;&gt;changeObjectName3&lt;/button&gt; &lt;p&gt;Array: &#123;arr&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setArr(()=&gt;&#123; arr.push(4) return [...arr] &#125;)&#125;&gt;changeArray&lt;/button&gt; &lt;p&gt;func: &#123;func.name&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setFunc(&#123;name:&#x27;function&#x27;&#125;)&#125;&gt;changeFuncion&lt;/button&gt; &lt;/div&gt; )&#125;export default Index 注意的是，在设置 state 时候，对于数组、对象的设置应该返回一个新的数组或者对象，而对于函数设置，相当于设置函数的返回值类型。 2. useEffect 此方法用于执行相应的副作用（DOM操作、数据请求、组件更新），相当于 class 组件中的 componentDidMount、componentDidUpdate、componentWillUnmount，它采用闭包的形式，可以获取 state 和 props 在组件内部执行，在组件挂载之后执行可以达到无阻塞更新的目的。 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;const Index = () =&gt; &#123; const [count,setCount]=useState(0) useEffect(()=&gt;&#123; console.log(count) &#125;,[count]) useEffect(()=&gt;&#123; // state改变时，不执行，当离开组件时，就会执行 console.log(count) &#125;,[]) return ( &lt;div&gt; &lt;p&gt;count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; )&#125;export default Index 3. useContext 此方法接收一个 context 对象（React.createContext的返回值）并返回该 context 的当前值。当前的context值由上层组件中距离当前组件最近的&lt;MyContext.Provider&gt;的value prop决定。 12345678910111213141516171819202122232425import React, &#123; useState, useContext, createContext &#125; from &#x27;react&#x27;;const MyContext = createContext();const ChildContext = ()=&gt; &#123; let count = useContext(MyContext) return (&lt;h3&gt;&#123;count&#125;&lt;/h3&gt;)&#125;const Index = () =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;MyContext.Provider value=&#123;count&#125;&gt; &lt;ChildContext&gt;&lt;/ChildContext&gt; &lt;/MyContext.Provider&gt; &lt;button onClick=&#123;()=&gt;&#123; setCount(count + 1) &#125;&#125;&gt;button&lt;/button&gt; &lt;/div&gt; )&#125;export default Index 4. useRef 此方法返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 12345678910111213141516171819import React, &#123; useState, useContext, createContext &#125; from &#x27;react&#x27;;const TextInputWithFocusButton = () =&gt; &#123; const inputEl = useRef(null) const onButtonClick = () =&gt; &#123; // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); &#125; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;获取Input焦点&lt;/button&gt; &lt;/&gt; );&#125;export default Index 我们可使用 useRef 可以很方便的保存任何可变值；还可以结合 ref 对象以&lt;div ref=&#123;myRef&#125; /&gt;形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点 5. useMemo 此方法利用 js 的 Memoization 缓存机制把计算的值以 key 的形式保存在内存中，当下次在需要用到这个值的时候直接从内存中读取，而不需要在进行计算，以到达优化运行速度的目的，使用方法和 useEffect 差不多，该方法在渲染期间执行，请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。 我们可以对比一下该方法和 useEffect 的执行顺序，我们可以看到先执行 useMemo 函数，再执行 useEffect 函数。 12345678910111213141516171819202122232425import React, &#123; useState, useEffect, useMemo &#125; from &#x27;react&#x27;;const Index = () =&gt; &#123; const [count, setCount] = useState(0) useEffect(()=&gt;&#123; console.log(&#x27;effect&#x27;) &#125;) useMemo(()=&gt;&#123; console.log(&#x27;Memo&#x27;) &#125;) // Memo // effect return ( &lt;div&gt; &lt;p&gt;count:&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123; setCount(count + 1) console.log(count) &#125;&#125;&gt;buttonCount&lt;/button&gt; &lt;/div&gt; )&#125;export default Index 如果我们给它的第二个参数传入空数组，此时不更新任何状态，但要注意的是，state 的数据是改变的，只是没有更新到页面上而已，这就会导致下面代码运行的问题，当我们监听多个状态时，不监听的那个状态被改变，再触发监听的状态改变的时候，不监听的那个状态值也一并会从缓存中取出来更新到页面上。 1234567891011121314151617181920212223242526import React, &#123; useState, useMemo &#125; from &#x27;react&#x27;;const Index = () =&gt; &#123; const [count, setCount] = useState(0) const [num, setNum] = useState(0) let res = useMemo(()=&gt;&#123; return &#123; count, num &#125; &#125;,[count]) return ( &lt;div&gt; &lt;p&gt;count:&#123;res.count&#125;; num:&#123;res.num&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123; setCount(count + 1) console.log(count) &#125;&#125;&gt;buttonCount&lt;/button&gt; &lt;button onClick=&#123;()=&gt;&#123; setNum(num + 1) console.log(num) &#125;&#125;&gt;buttonNum&lt;/button&gt; &lt;/div&gt; )&#125;export default Index 当遇到需要在父子使用对应的缓存机制的时候，只需要在子组件中对父组件传过来的 props 值进行 useMemo 控制就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 父组件Index.jsimport React, &#123; useState, useMemo &#125; from &#x27;react&#x27;;import ChildMome from &#x27;./ChildMome.js&#x27;;const Index = () =&gt; &#123; const [count, setCount] = useState(0) const [num, setNum] = useState(0) let res = useMemo(()=&gt;&#123; return &#123; count, num &#125; &#125;,[count, num]) return ( &lt;div&gt; &lt;ChildMome c=&#123;count&#125; n=&#123;num&#125; /&gt; &lt;p&gt;count:&#123;res.count&#125;; num:&#123;res.num&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123; setCount(count + 1) console.log(count) &#125;&#125;&gt;buttonCount&lt;/button&gt; &lt;button onClick=&#123;()=&gt;&#123; setNum(num + 1) console.log(num) &#125;&#125;&gt;buttonNum&lt;/button&gt; &lt;/div&gt; )&#125;export default Index// 子组件ChildMome.jsimport React, &#123; useMemo &#125; from &#x27;react&#x27;;const ChildMome = (&#123;c, n&#125;) =&gt; &#123; let childRes = useMemo(()=&gt;&#123; return &#123; c, n &#125; &#125;,[c, n]) return ( &lt;div&gt; &lt;h3&gt;Child Memonization&lt;/h3&gt; &lt;p&gt;c:&#123;childRes.c&#125; ;n:&#123;childRes.n&#125;&lt;/p&gt; &lt;/div&gt; )&#125;export default ChildMome 6. useCallback 和 useMemo 功能类似，局部用到缓存机制，但与其不同的是，这个方法用来缓存一个函数，该函数可以通过方法的返回值来执行，通常用来控制组件什么时候更新。 123456789101112131415161718192021222324import React, &#123; useState, useCallback &#125; from &#x27;react&#x27;;const Index = () =&gt; &#123; const [count, setCount] = useState(0) let callback = useCallback(()=&gt;&#123; console.log(count) return count &#125;) // 第二个参数传空数组不监听任何数据 return ( &lt;div&gt; &lt;p&gt;count:&#123;count&#125;;&lt;/p&gt; &lt;h4&gt;&#123;callback()&#125;&lt;/h4&gt; &lt;button onClick=&#123;()=&gt;&#123; setCount(count + 1) console.log(count) &#125;&#125;&gt;buttonCount&lt;/button&gt; &lt;/div&gt; )&#125;export default Index","tags":[{"name":"hook","slug":"hook","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/hook/"}]},{"title":"react生命周期流程和事件处理","date":"2020-05-15T08:55:00.000Z","path":"2020/05/15/react生命周期/","text":"组件从创建到被销毁的过程称为组件的生命周期，React的生命周期可分为三个阶段：挂载阶段、更新阶段、卸载阶段。不同的生命周期阶段对应了不同的生命周期函数。 挂载阶段 这个阶段组件被创建，执行初始化，并挂载到DOM中，流程依次是：（1）constructor（2）componentWillMount（3）render（4）componentDidMount constructor 这是ES6 class中的构造方法，组件被创建就会调用组件的构造方法，这个方法会传入一个props参数，此参数是父组件传入的参数对象，如果父组件没有传入对应的属性而组件自身定义了默认属性，那么这个props指向的就是组件的默认属性，必须要在这个方法中首先调用super(props)才能保证props传入组件使用。 在这里，类的数据类型就是函数，类本身就指向构造函数，假设有个类为A，所以通过typeof检测A的数据类型是function，而这条语句A === A.prototype.constructor结果也是true的。当有个class类为B，继承自A，此时在子类B中调用super()相当于A.prototype.constructor.call(this)，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例；这只是super做为函数调用的时候，当它做为对象使用的时候，相当于指向父类的原型A.prototype。 componentWillMount 组件挂载前调用，且只会被调用一次，此方法中使用this.setState()不会引起组件的重新渲染。 render 这是定义组件必须要使用的方法，可以根据state和props返回一个React元素，注意，它只是一个纯函数，不能在内部执行有副作用的操作，也不负责DOM的渲染。 componentDidMount 组件挂载完之后调用，且只会被调用一次，这时候DOM已经在页面挂载了，因此依赖DOM的操作可以在这里完成，还可以用于向服务端请求数据，在这调用this.setState()会引起组件的重新渲染。 更新阶段 组件挂载到DOM之后，组件的props和state会引起组件的更新，更新阶段的生命周期有：（1）componentWillReceiveProps（2）shouldComponentUpdate（3）componentWillUpdate（4）render（5）componentDidUpdate componentWillReceiveProps 这个方法只在props引起的组件更新过程中才会起作用，而单纯的state引起的组件更新是不会触发的，方法的参数nextProps是父组件传递给当前组件新的Props，也就是说，当父组件render方法被调用，引起组件的更新，但此时并不能保证传递给子组件的props发生改变，也有可能和之前的props相等，因此，在此方法中通常需要对比nextProps和this.props来决定是否执行后续操作。 shouldComponentUpdate 这个方法决定是否继续执行更新过程，默认返回true，组件会继续更新，当返回false时，后续的（3）（4）（5）将不会执行，一般通过nextProps、nextState和当前的props、state对比来减少组件不必要的渲染，从而优化性能。 componentWillUpdate 组件更新前执行的操作，一般很少用到，由于方法冗余，在后续版本逐渐移除，并且推出了函数组件操作状态的hook。注意（2）（3）方法中不能使用setState，否则会引起循环调用问题，render永远无法被调用，组件无法正常渲染。 componentDidUpdate 组件更新后调用，可以作为操作更新后的DOM的地方，参数prevProps、prevState代表更新前的props和state。 卸载阶段 组件卸载过程只有一个生命周期函数：componentWillUnmount，在个方法在组件卸载前调用，通常执行一些清理操作，比如清除定时器，清除手动创建爱你的DOM元素等。 在React中，事件的命名采用驼峰命名法，事件响应函数必须以对象的形式赋值给事件属性，其实，React事件和DOM事件在使用上几乎没啥差别，但需要注意以下两点： DOM事件中可以通过回调函数返回false来阻止事件的默认行为，而在React中，必须要显式的调用事件对象的preventDefault方法来阻止事件的默认行为。 如果在某些场景下必须要用到DOM提供的原生事件，可以通过React事件对象的nativeEvent属性获取。 下面我们来看下在React中定义时间处理函数的几种方式： 1.使用箭头函数 1234567891011121314151617181920class Mycomponent extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; number: 0 &#125; &#125; handleClick(e)&#123; const &#123; number &#125; = this.state this.setState(&#123; number: ++number &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;div&gt;&#123;this.state.number&#125;&lt;/div&gt; &lt;button onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 由上面的案例可以看出，我们是可以直接在事件处理的大括号内直接定义函数语句，但这样最大的问题是，当代码逻辑比较复杂的时候，一方面是代码区块看起来比较混乱臃肿；另一方面，在每次render调用的时候，都会重新创建一个新的事件处理函数，给程序带来额外的开销，因为任何一个状态的变更都会引起组件的重新渲染。不过，大多数情况下是不必考虑这点性能问题的。 2.使用组件方法绑定this 123456789101112131415161718192021222324252627282930313233343536373839class Mycomponent extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; number: 0, list: [1,4,5], current: 1 &#125; this.handleClickOne = this.handleClickOne.bind(this) &#125; handleClickOne(e)&#123; const &#123; number &#125; = this.state this.setState(&#123; number: ++number &#125;) &#125; handleClickTow(item ,e)&#123; this.setState(&#123; current: item &#125;) &#125; render()&#123; const &#123; number, current, list &#125; = this.state return( &lt;div&gt; &lt;div&gt;&#123;number&#125;&lt;/div&gt; &#123;/*无参的情况*/&#125; &lt;button onClick=&#123;this.handleClickOne&#125;&gt;点击1&lt;/button&gt; &#123;/*有参的情况，事件属性值中绑定this*/&#125; &lt;h2&gt;&#123;current&#125;&lt;/h2&gt; &#123; list.map((item)=&gt;( &lt;p onClick=&#123;this.handleClickTwo.bind(this,item)&#125;&gt;&#123;item&#125;&lt;/p&gt; )) &#125; &lt;/div&gt; ) &#125;&#125; 这样的写法写起来麻烦，而且存在和方式一同样的问题。 3.属性初始化语法 12345678910111213141516import React, &#123;useState&#125; from &#x27;react&#x27;;const MyComponent = () =&gt; &#123; const [number, setNumber] = useState(0) const handleClick = () =&gt; &#123; setNumber(++number) &#125; return &lt;div&gt; &lt;div&gt;&#123;number&#125;&lt;/div&gt; &lt;button onClick=&#123;handleClick&#125;&gt;点击&lt;/button&gt; &lt;/div&gt;&#125;export default MyComponent 此方法结合ES7中的属性初始化语法和React Hook用法，不用手动绑定this，也没有重复渲染的问题，代码简洁可观，是现阶段（2020-6）广泛采用的一种方式。","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"重学前端一之构建自己的前端知识体系","date":"2020-05-02T01:05:00.000Z","path":"2020/05/02/重学一知识图谱/","text":"一方面，随着近几年前端的飞速发展，各种框架应用层出不穷；另一方面，学校中并没有与之对应的专业训练，使得很多开发者们面对新机会的时候措手不及，这种现象在哲学层面称之为“新事物”，新事物往往是具有远大光明和前景的事物，因此，想要不被前端的波涛汹涌冲垮，就需要构建自己的知识体系，不管框架怎么变，前端的基础知识体系是不变的。 这里是重学前端，是基于winter老师重学前端系列课程的一个总结体会集合，希望对你我在前端查漏补缺上有一定的帮助。 以前我们的学习都是零散的学习，由点及面，然后就马不停蹄地运用于工作中，这其中就难免会遗漏很多的知识点，而在工作中不经常用的那部分其实也忘的差不多了，然而我们构建知识框架，则是从面到点，从整体把握知识体系，并逐个击破。 以上就是整理的一个HTML和CSS的知识体系图谱。 HTML 我们把HTML的标签分为六类 文档类标签：它是描述文档自身信息的一些标签，比如：title、meta、style、base等。 语义标签类：扩展了文本，语义的表述，比如：header、aside、article等。 链接类型：提供文档内到文档外的链接。 替换类型：引入图片、视频、音频替换自身的标签。 表单：用户用户输入或者选择项的标签。 表格：用户表格布局或者显示表格的标签。 CSS CSS是从语言和功能上面来说，语言上面有@rule，比如@media、@import、@page等，还有我们的各类选择器和单位；功能上面可以从布局文档流、效果绘制和动画交互来讲，包括标准流、flex布局、边框效果，文字阴影、逐帧动画和过渡动画等等。 以上就是整理的JavaScript的知识体系图谱。 JavaScript 上面这样的划分正好符合一般的编程规律：用一定词法和语法，来表达一定的语义，从而来操作运行时。而运行时有符合程序的定义：程序=数据结构+算法。数据结构又分为类型和实例，类型就是其中的基本数据类型和复杂数据类型（也叫引用数据类型），实例就是其中的一些内置对象了，执行过程就是算法约定的一些执行机制，包括事件机制，宏微任务等。文法里面的词法和语法是一一对应的，这在Javascript标准中是有详细规定的。 以上是整理的浏览器原理及API的图谱。 浏览器原理及API 浏览器从浏览器的设计流程出发，按照解析、渲染DOM树、操作CSSOM、计算CSS、渲染绘制这样来梳理，然后包括一些重要的浏览器内置API，比如：事件、DOM、浏览器API等等，这些都是工作中必定常用到的。","tags":[{"name":"重学前端","slug":"重学前端","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/"}]},{"title":"JS的浅拷贝和深拷贝","date":"2020-04-25T06:55:00.000Z","path":"2020/04/25/js浅拷贝深拷贝/","text":"JS浅拷贝和深拷贝在平时工作中可能不是很在意，但是相信大家都知道 Vue.js 和 react.js 等框架，这里面的 state 、 props 处理的时候就涉及到这个拷贝，这些框架都是数据驱动视图，也就是说数据模型的变更相应的页面视图也会改变，试想一下，如果后台返回的数据是一个多级的对象，而你只是对它浅拷贝和其他处理后用在多处地方，当这个拷贝对象深层级做了变更后，原对象的深层级其实也一样变更了，这就不是我们想要的。比如下面这个例子： 123456let obj = &#123; a: 10, b: [1, 2, 3], c: &#123; x: 100 &#125;, d: /^[0-9]&#123;8&#125;$/&#125;; 然后我们对其实行浅拷贝，实现浅拷贝有下面两种方式： 12345678910// ES6let obj2 = &#123;...obj&#125;;// ES5let obj2 = &#123;&#125;;for(key in obj)&#123; if(!obj.hasOwnProperty(key)) break; obj2[key] = obj[key];&#125;console.log(obj2); 此时我们在控制台打印出来，并看不出什么问题，我们在控制台做进一步处理，对拷贝的对象的第三层的 x 属性做更改， 12obj2.c.x = 123;console.log(obj,obj2); 我们发现，obj 和 obj2 的 x 属性都发生了变更，究其原因，是因为浅拷贝只是拷贝它的第二级数据，对于复杂类型的拷贝就只是拷贝它的引用，也就是地址，在上面案例中也就是 obj 和 obj2 它们的 c 属性都指向同一个地址，而这个地址所存储的是一个对象，当对象被修改，自然地另一个引用也会变更，如何来解决这个问题呢？我们就需要使用到深克隆。 123let obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2);// &#123;a: 10, b: [1, 2, 3], c: &#123;x: 100&#125;&#125;, d: &#123;&#125;&#125; 我们使用了 JSON 对象所提供的方法把原对象转换为字符串，然后再转成 json 对象，这样可以很简单的实现大部分常规对象的深拷贝，但是存在弊端，会发现对象中的正则在转成字符串的时候是一个空对象，不仅仅是正则，还有 null 、 Date 和 Function 也会改变，所以需要通过遍历来封装一个深拷贝函数，然后对这几种特殊的类型特殊处理。 123456789101112131415function deepClone(obj)&#123; if(obj === null) return null; if(typeof(obj) !== &#x27;object&#x27;) return obj; if(obj instanceof RegExp) return new RegExp(obj); if(obj instanceof Date) return new Date(obj); // 不直接创建空对象 这样是为了创建和参数对象类型一致的实例 let newObj = new obj.constructor; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; // 递归调用 newObj[key] = deepClone(obj[key]); &#125; &#125; return newObj;&#125; 然后，我们可以深层次判断克隆对象是否和原有对象相等了，结果显然，它们不是同一个东西。 1234let obj2 = deepClone(obj);console.log(obj === obj2); // falseconsole.log(obj.b === obj2.b); // falseconsole.log(obj.d === obj2.d); // false","tags":[{"name":"拷贝","slug":"拷贝","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E6%8B%B7%E8%B4%9D/"}]},{"title":"三篇文章解决工作中遇到的git问题","date":"2020-04-09T13:31:00.000Z","path":"2020/04/09/git查缺补漏/","text":"当前，git由于其分布式控制、元数据存储方式、没有全局版本号、更优的储存算法、对网络的依赖性不强等优势，成为很多公司的代码控制工具，结合前两篇文章，可以说能解决工作中的大部分git问题。 第一篇 如何把项目托管到git Coding 第二篇 git项目管理流程 在此基础上查缺补漏，总结和加深，往下看； 这一条命令，调用图形界面查看所有提交记录，也可以直接在这个图形界面上进行操作； 123$ gitk -all# 或者说$ gitk -a 关于分支的操作，查看本地分支，查看所有分支，查看远程分支； 123456# 查看本地分支$ git branch# 查看所有分支$ git branch -a# 查看远程分支$ git branch -r 同步远程分支； 1$ git fetch 合并某个分支，前提是你要切换到需要合并的那个分支，比如说把B分支合并到A分支，需要先切换到A分支，再执行下面的命令； 1$ git merge B 下面是关于放弃修改操作； 对于未使用git add缓存代码，可以使用如下命令放弃指定文件的修改； 12$ git checkout -- filepathname# 放弃readme文件修改 git checkout -- readme.md 放弃所有文件的修改可以使用； 1$ git checkout . 对于已经使用了git add缓存了代码，可以使用如下命令放弃指定文件的缓存； 12$ git reset HEAD filepathname# 例 git reset HEAD readme.md 放弃所有文件的修改缓存可以使用； 1$ git reset HEAD . 对于已经用git commit提交了代码，可以使用如下命令来回退到上一次commit的状态； 1$ git reset --hard HEAD^ 使用如下命令可以用来回退到任意版本； 1$ git reset --hard commitid 当然，这个提交ID commitid 是通过git log命令来查看。","tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Git/"}]},{"title":"Vue CLi配置请求代理解决跨域问题","date":"2020-04-07T13:23:00.000Z","path":"2020/04/07/vueCli跨域/","text":"同源策略，跨域，不管是工作还是面试都是不可回避的问题，在vue cli中，是如何来解决跨域问题的? vue cli 可以在 vue.config.js 中配置 webpack 相关信息，可以利用 webpack 请求代理来解决此问题。 12345678910111213141516171819// vue.config.jsmodule.exports = &#123; runtimeCompiler: true, publicPath: &#x27;/&#x27;, // 设置打包文件相对路径 devServer: &#123; // port: 8071, // 自定义启动端口 // open: true, // 配置自动启动浏览器 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://127.0.0.1:8100/&#x27;, // 对应自己的接口 changeOrigin: true, ws: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;,&#125; 接下来配置 axios 请求； 12345678910// main.jsaxios.defaults.timeout = 5000 // 请求超时axios.defaults.baseURL = &#x27;/api/&#x27; // api 即上面 vue.config.js 中配置的地址// 发送请求axios.post(&#x27;/postData/&#x27;, &#123; // 请求：http://localhost:8080/api/postData name: &#x27;cedric&#x27;,&#125;).then((res) =&gt; &#123; console.log(res.data)&#125;) 生产环境下，只需要修改 axios 配置即可，其余不需要改变； 12345678910// 生产环境axios.defaults.timeout = 5000 // 请求超时axios.defaults.baseURL = &#x27;http://api.demourl.com/&#x27;// 页面中axios的请求保持不变：axios.post(&#x27;/postData/&#x27;, &#123; name: &#x27;cedric&#x27;,&#125;).then((res) =&gt; &#123; console.log(res.data)&#125;) 再补充一个 axios 配置时候遇到的一个小问题，在调用后台 delete 方法的时候总是报403/401的错误，究其原因，是在配置 axios 请求头的时候把 token 用这种方式给写死了，这就导致传到后台的 token 还是上一次的旧 token 1axios.defaults.headers[&#x27;token&#x27;] = sessionStorage.getItem(&#x27;token&#x27;); 解决办法是需进行请求拦截，这样就可以获取到实时的 token 了 12345axios.interceptors.request.use(req =&gt;&#123; let token = sessionStorage.getItem(&#x27;token&#x27;) || &#x27;&#x27;; req.headers.common[&#x27;token&#x27;] = token return req;&#125;)","tags":[]},{"title":"未知宽度的容器实现宽高等比例适应","date":"2020-04-02T13:30:00.000Z","path":"2020/04/02/padding百分比的作用/","text":"在开发小程序的时候，遇到一个这样的需求，页面使用栅格布局，显示很多小方块，这些小方块随着移动端宽高等比自适应，问题是栅格布局的元素宽度使用百分比，是不固定的，因此，看似不起眼的 padding 属性起到了至关重要的作用。 首先需要知道，一个元素的 padding，如果值是一个百分比，那这个百分比是相对于其父元素的宽度而言的，即使对于 padding-bottom 和 padding-top 也是如此。 另外，在计算 overflow 时，是将元素的内容区域（即 width / height 对应的区域）和 Padding 区域一起计算的。换句话说，即使将元素的 overflow 设置为 hidden，“溢出”到 padding 区域的内容也会照常显示。 简单的栅格布局代码 12345678910111213141516171819202122&lt;View className=&#x27;wrap&#x27;&gt; &lt;View className=&#x27;at-row at-row__justify--around select-box&#x27;&gt; &lt;View className=&#x27;at-col at-col-3&#x27;&gt; &lt;View className=&#x27;select-item&#x27;&gt; &lt;Text&gt;项目一&lt;/Text&gt; &lt;/View&gt; &lt;Text className=&#x27;sub-title&#x27;&gt;描述&lt;/Text&gt; &lt;/View&gt; &lt;View className=&#x27;at-col at-col-3&#x27;&gt; &lt;View className=&#x27;select-item&#x27;&gt; &lt;Text&gt;项目二&lt;/Text&gt; &lt;/View&gt; &lt;Text className=&#x27;sub-title&#x27;&gt;描述&lt;/Text&gt; &lt;/View&gt; &lt;View className=&#x27;at-col at-col-3&#x27;&gt; &lt;View className=&#x27;select-item&#x27;&gt; &lt;Text&gt;项目三&lt;/Text&gt; &lt;/View&gt; &lt;Text className=&#x27;sub-title&#x27;&gt;描述&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&lt;/View&gt; padding属性设置为百分比，相对于宽度的百分比而言，从而实现宽高等比的效果 12345678910111213141516.search-character-box &#123; width: 100%;&#125;.select-box&#123; color: #000; &amp; .select-item&#123; background-color: #5199ff; ::before&#123; content: &quot;&quot;; display: inline-block; padding-bottom: 100%; /*padding的百分比作用*/ width: .1px; vertical-align: middle; &#125; &#125;&#125;","tags":[]},{"title":"项目集成腾讯IM即时通讯相关问题","date":"2020-03-31T13:03:00.000Z","path":"2020/03/31/即时通讯IM/","text":"本文是基于web平台对接腾讯IM的一些体会和总结，对于没有对接IM经验或者是刚接触IM项目的小伙伴来说，看到这么多可选的平台，这么丰富的接口和看似如此庞大的项目，你的心里可能会发怵，但是，当你看到这篇文章的时候，你应该会心一笑，因为这里整理了web端跑通整个demo对接的基本流程和一些问题，话不多说，继续往下看。 腾讯IM提供在线demo和本地demo，在线demo可以查看官方案例的最完整的功能，本地demo是供本地开发调试时使用，以web平台为例，去SDK下载区下载对应平台的demo，如果是Web（通用）平台找到这个H5/dist/debug/GenerateTestUserSig.js目录，把文件中的SDKAPPID和SECRETKEY项换成自己的，在项目目录下安装依赖npm install，启动本地项目npm start，注意，官方不推荐直接访问http://localhost:8080，而是在项目的dist目录下直接打开index.html，这时候我们可以在user0-user29中随便登陆一个了，重新打开一次，再登录一个账户，两个账户就可以即时通讯，至此，官方demo在本地跑起来了。那么，我们如何集成SDK到我们自己的web项目呢？ 目前，很多前端web项目都采用MV*框架，比如官方的demo就采用Vue+ElementUI技术，因此，先安装SDK依赖 1234// IM Web SDKnpm install tim-js-sdk --save// 发送图片、文件等消息需要的 COS SDKnpm install cos-js-sdk-v5 --save 为了实现模块化，我们新建tim.js文件作为tim模块独立出来，引入对应的包，并导出tim 1234567891011121314151617import TIM from &#x27;tim-js-sdk&#x27;;import COS from &quot;cos-js-sdk-v5&quot;;let options = &#123; SDKAppID: 0 // 接入时需要将0替换为您的即时通信 IM 应用的 SDKAppID&#125;;// 创建 SDK 实例，`TIM.create()`方法对于同一个 `SDKAppID` 只会返回同一份实例let tim = TIM.create(options); // SDK 实例通常用 tim 表示// 设置 SDK 日志输出级别，详细分级请参见 setLogLevel 接口的说明tim.setLogLevel(0); // 普通级别，日志量较多，接入时建议使用// tim.setLogLevel(1); // release 级别，SDK 输出关键信息，生产环境时建议使用// 注册 COS SDK 插件tim.registerPlugin(&#123;&#x27;cos-js-sdk&#x27;: COS&#125;);export default tim 为了能在本地登录账户，需要利用客户端计算UserSig生成签名，再配上userID，就可以登录到IM系统，这里需要借助官方demo的两个文件GenerateTestUserSig.js和lib-generate-test-usersig.min.js来生成签名，由于模块化开发，需要对GenerateTestUserSig.js进行修改 12345678910//首先导入lib-generate-test-usersig.min.jsimport LibGenerateTestUserSig from &#x27;./lib-generate-test-usersig.min&#x27;//......//修改lib的调用方法，官方案例是注入在window里面new window.LibGenerateTestUserSig(...)var generator = new LibGenerateTestUserSig(SDKAPPID, SECRETKEY, EXPIRETIME);//......//导出export &#123; genTestUserSig&#125; 为了方便后续使用，我们可以在window和Vue中全局注入tim 12345678//main.jsimport tim from &#x27;./tim&#x27;import TIM from &#x27;tim-js-sdk&#x27;window.tim = timwindow.TIM = TIMVue.prototype.tim = timVue.prototype.TIM = TIM 接下来需要添加事件监听，查看所有的事件绑定，执行登录操作，顺便提下退出操作 123456789101112//登录tim.login(&#123;userID: &#x27;your userID&#x27;, userSig: &#x27;your userSig&#x27;&#125;).then((imRespone)=&gt;&#123; console.log(imResponse.data); // 登录成功&#125;).catch((imError)=&gt;&#123; console.warn(&#x27;login error:&#x27;, imError); // 登录失败的相关信息&#125;)//退出tim.logout().then((imResponse)=&gt;&#123; console.log(imResponse.data); // 退出成功&#125;).catch((imError)=&gt;&#123; console.warn(&#x27;logout error:&#x27;, imError);&#125;); 登录之后我们可以获取会话列表，获取每个会话下面的消息列表，其中涉及到的数据状态和细节操作是比较复杂的，先看看文本中的表情处理，这里简要说下思路。 12345678910//emojiMap.jsexport const emojiUrl = &#x27;https://imgcache.qq.com/open/qcloud/tim/assets/emoji/&#x27;export const emojiMap = &#123; &#x27;[调皮]&#x27;: &#x27;emoji_113@2x.png&#x27;, &#x27;[龇牙]&#x27;: &#x27;emoji_141@2x.png&#x27;&#125;export const emojiName = [ &#x27;[龇牙]&#x27;, &#x27;[调皮]&#x27;] 据官方demo来看，所有的表情都是图片的映射，比如’[微笑]'的图片链接’https://imgcache.qq.com/open/qcloud/tim/assets/emoji/emoji_49@2x.png’，只需要更改结尾，拼凑图片链接即可，点击显示所有表情供选择的时候，是通过遍历所有映射放入img标签显示的，发送消息的时候，我们选择了某个表情，只需要把对于的emojiName比如’[微笑]'追加到文本消息里就行。接下来是接收带有表情的文本消息解析的问题，官方给出了解析代码，只需要导入emoji映射，再把这个解析函数导出就可以了。 然后就是发送文件信息，获取对应的文件DOM，调用发送文件消息的接口即可，显示的时候只需要显示文件名和文件大小即可，然后点击下载，可参考下面三个函数 123456789101112131415161718192021222324252627282930313233size() &#123; const size = this.payload.fileSize if (size &gt; 1024) &#123; if (size / 1024 &gt; 1024) &#123; return `$&#123;this.toFixed(size / 1024 / 1024)&#125; Mb` &#125; return `$&#123;this.toFixed(size / 1024)&#125; Kb` &#125; return `$&#123;this.toFixed(size)&#125;B`&#125;,toFixed(number, precision = 2) &#123; return number.toFixed(precision)&#125;downloadFile() &#123; // 浏览器支持fetch则用blob下载，避免浏览器点击a标签，跳转到新页面预览的行为 if (window.fetch) &#123; fetch(this.fileUrl) .then(res =&gt; res.blob()) .then(blob =&gt; &#123; let a = document.createElement(&#x27;a&#x27;) let url = window.URL.createObjectURL(blob) a.href = url a.download = this.fileName a.click() &#125;) &#125; else &#123; let a = document.createElement(&#x27;a&#x27;) a.href = this.fileUrl a.target = &#x27;_blank&#x27; a.download = this.filename a.click() &#125;&#125; 图片消息和文件消息大同小异，需要注意的是这里图片消息是可以点击放大缩小旋转查看的，下面贴上官方demo中写的图片操作，经供参考，icon是Iview的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;template&gt; &lt;div class=&quot;image-previewer-wrapper&quot; v-show=&quot;showPreviewer&quot; @mousewheel=&quot;handleMouseWheel&quot;&gt; &lt;div class=&quot;image-wrapper&quot;&gt; &lt;img class=&quot;image-preview&quot; :style=&quot;&#123;transform: `scale($&#123;zoom&#125;) rotate($&#123;rotate&#125;deg)`&#125;&quot; :src=&quot;previewUrl&quot; @click=&quot;close&quot; /&gt; &lt;/div&gt; &lt;Icon type=&quot;md-close&quot; class=&quot;close-button&quot; @click=&quot;close&quot; /&gt; &lt;Icon type=&quot;md-arrow-back&quot; class=&quot;prev-button&quot; @click=&quot;goPrev&quot; /&gt; &lt;Icon type=&quot;md-arrow-forward&quot; class=&quot;next-button&quot; @click=&quot;goNext&quot;&gt;&lt;/Icon&gt; &lt;div class=&quot;actions-bar&quot;&gt; &lt;Icon type=&quot;ios-remove-circle-outline&quot; @click=&quot;zoomOut&quot;&gt;&lt;/Icon&gt; &lt;Icon type=&quot;ios-add-circle-outline&quot; @click=&quot;zoomIn&quot;&gt;&lt;/Icon&gt; &lt;Icon type=&quot;md-undo&quot; @click=&quot;rotateLeft&quot;&gt;&lt;/Icon&gt; &lt;Icon type=&quot;md-redo&quot; @click=&quot;rotateRight&quot;&gt;&lt;/Icon&gt; &lt;span class=&quot;image-counter&quot;&gt;&#123;&#123;index+1&#125;&#125; / &#123;&#123;imgUrlList.length&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; name: &#x27;ImagePreviewer&#x27;, data() &#123; return &#123; url: &#x27;&#x27;, index: 0, visible: false, zoom: 1, rotate: 0, minZoom: 0.1 &#125; &#125;, computed: &#123; ...mapGetters([&#x27;imgUrlList&#x27;]), showPreviewer() &#123; return this.url.length &gt; 0 &amp;&amp; this.visible &#125;, imageStyle() &#123; return &#123; transform: `scale($&#123;this.zoom&#125;);` &#125; &#125;, previewUrl() &#123; return this.formatUrl(this.imgUrlList[this.index]) &#125; &#125;, mounted() &#123; this.$bus.$on(&#x27;image-preview&#x27;, this.handlePreview) &#125;, methods: &#123; handlePreview(&#123; url &#125;) &#123; this.url = url this.index = this.imgUrlList.findIndex(item =&gt; item === url) this.visible = true &#125;, handleMouseWheel(event) &#123; if (event.wheelDelta &gt; 0) &#123; this.zoomIn() &#125; else &#123; this.zoomOut() &#125; &#125;, zoomIn() &#123; this.zoom += 0.1 &#125;, zoomOut() &#123; this.zoom = this.zoom - 0.1 &gt; this.minZoom ? this.zoom - 0.1 : this.minZoom &#125;, close() &#123; Object.assign(this, &#123; zoom: 1 &#125;) this.visible = false &#125;, rotateLeft() &#123; this.rotate -= 90 &#125;, rotateRight() &#123; this.rotate += 90 &#125;, goNext() &#123; this.index = (this.index + 1) % this.imgUrlList.length &#125;, goPrev() &#123; this.index = this.index - 1 &gt;= 0 ? this.index - 1 : this.imgUrlList.length - 1 &#125;, formatUrl(url) &#123; if (!url) &#123; return &#x27;&#x27; &#125; return url.slice(0, 2) === &#x27;//&#x27; ? `https:$&#123;url&#125;` : url &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.image-previewer-wrapper &#123; position: fixed; width: 100%; left: 0; top: 0; height: 100%; display: flex; justify-content: center; align-items: flex-start; background: rgba(14, 12, 12, 0.7); z-index: 2000; cursor: zoom-out;&#125;.close-button &#123; cursor: pointer; font-size: 28px; color: #000; position: fixed; top: 50px; right: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; padding: 6px;&#125;.image-wrapper &#123; position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;&#125;.image-preview &#123; transition: transform 0.1s ease 0s;&#125;.actions-bar &#123; display: flex; justify-content: space-around; align-items: center; position: fixed; bottom: 50px; left: 50%; margin-left: -100px; padding: 12px; border-radius: 6px; background: rgba(255, 255, 255, 0.8);&#125;.actions-bar i &#123; font-size: 24px; cursor: pointer; margin: 0 6px;&#125;.prev-button,.next-button &#123; position: fixed; cursor: pointer; background: rgba(255, 255, 255, 0.8); border-radius: 50%; font-size: 24px; padding: 12px;&#125;.prev-button &#123; left: 0; top: 50%;&#125;.next-button &#123; right: 0; top: 50%;&#125;.image-counter &#123; background: rgba(20, 18, 20, 0.53); padding: 3px; border-radius: 3px; color: #fff;&#125;&lt;/style&gt;","tags":[{"name":"即时通讯","slug":"即时通讯","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"}]},{"title":"利用浏览器fetch接口下载文件","date":"2020-03-28T12:08:00.000Z","path":"2020/03/28/利用浏览器fetch下载文件/","text":"Fetch API提供了一个 JavaScript 接口，用于访问和操纵HTTP管道的一些具体部分，例如请求和响应。它还提供了一个全局fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 利用浏览器支持fetch下的blob文件类型实现下载，可以很好地避免浏览器点击a标签，跳转到新页面预览的行为。 downloadFile() &#123; if (window.fetch) &#123; fetch(this.fileUrl) .then(res =&gt; res.blob()) .then(blob =&gt; &#123; let a = document.createElement('a') let url = window.URL.createObjectURL(blob) a.href = url a.download = this.fileName a.click() &#125;) &#125; else &#123; let a = document.createElement('a') a.href = this.fileUrl a.target = '_blank' a.download = this.filename a.click() &#125; &#125; ``","tags":[]},{"title":"各端小程序之Taro框架的问题","date":"2020-03-20T12:00:00.000Z","path":"2020/03/20/Taro的相关问题/","text":"Taro，说它不香那是假的，毕竟下面的那段话对于FN developer来说都会心动的。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/京东小程序、快应用、H5、React-Native 等）运行的代码。 ————来自官方文档 Taro基于React的JSX语法下的一套多端开发方案，但在语法上相对于React有所收敛，因为要编译到不同的端平台，为了兼容的最大化，所以某些ES的高级功能可能用不了。所以的项目初始化步骤和Taro规范在Taro官方文档都写明了， 这里就不赘述了，这里说下我接触这个框架的若干问题。 1. 绑定事件和页面跳转 首先在pages目录下新建一个和index文件夹同样的页面test，然后在app.js的config的pages下配置页面 1234pages: [ &#x27;pages/index/index&#x27;, &#x27;pages/test/index&#x27; ], 编辑test页面 123456789101112131415161718import Taro, &#123; Component &#125; from &#x27;@tarojs/taro&#x27;import &#123; View, Text &#125; from &#x27;@tarojs/components&#x27;import &#x27;./index.scss&#x27;export default class Index extends Component &#123; config = &#123; navigationBarTitleText: &#x27;测试页&#x27; &#125; render () &#123; return ( &lt;View className=&#x27;index&#x27;&gt; &lt;Text&gt;Hello test!&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; 然后在index/index.jsx里面导入按钮组件，添加点击事件和方法，在点击事件中使用Taro自带的路由跳转工具 12345678910111213141516171819202122import Taro, &#123; Component &#125; from &#x27;@tarojs/taro&#x27;import &#123; View, Text, Button &#125; from &#x27;@tarojs/components&#x27;import &#x27;./index.scss&#x27;export default class Index extends Component &#123; config = &#123; navigationBarTitleText: &#x27;首页&#x27; &#125; handleClick = (e) =&gt; &#123; Taro.navigateTo(&#123; url: &#x27;/pages/test/index&#x27; &#125;) &#125; render () &#123; return ( &lt;View className=&#x27;index&#x27;&gt; &lt;Text&gt;Hello world!&lt;/Text&gt; &lt;Button size=&#x27;mini&#x27; onClick=&#123;this.handleClick&#125;&gt;点击跳转&lt;/Button&gt; &lt;/View&gt; ) &#125;&#125; 2. 引入自定义组件 首先在src目录下新建components文件夹用于存放所有的自定义组件，新建welcome.jsx，在文件中导入相关组件和类型校验工具 12345678910111213import Taro, &#123; Component &#125; from &#x27;@tarojs/taro&#x27;import &#123; View, Text &#125; from &#x27;@tarojs/components&#x27;import PropTypes from &#x27;prop-types&#x27;export default class Welcome extends Component &#123; render () &#123; return &lt;View&gt;&lt;Text&gt;Hello, &#123;this.props.name&#125;&lt;/Text&gt;&lt;/View&gt; &#125;&#125;Welcome.propTypes = &#123; name: PropTypes.string //接收父级传过来的name属性&#125; 然后在需要使用的页面直接导入使用 1234567891011121314151617181920import Taro, &#123; Component &#125; from &#x27;@tarojs/taro&#x27;import &#123; View, Text &#125; from &#x27;@tarojs/components&#x27;import &#x27;./index.scss&#x27;import Wecome from &#x27;../../components/wecome&#x27;export default class Index extends Component &#123; config = &#123; navigationBarTitleText: &#x27;测试页&#x27; &#125; render () &#123; return ( &lt;View className=&#x27;index&#x27;&gt; &lt;Text&gt;Hello test!&lt;/Text&gt; &lt;Wecome name=&#x27;fed&#x27; /&gt; //传入props &lt;/View&gt; ) &#125;&#125; 如果，组件使用的是小程序的原生组件，就需要在页面中使用usingComponents配置组件 1234567export default class Index extends Component &#123; config = &#123; usingComponents: &#123; &#x27;bar&#x27;: &#x27;../wxComponent/bar&#x27; &#125; &#125;&#125;","tags":[{"name":"Taro","slug":"Taro","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Taro/"}]},{"title":"vue文本域输入屏蔽回车键","date":"2020-03-18T12:38:00.000Z","path":"2020/03/18/Vue屏蔽回车换行/","text":"很多时候，都需要监听键盘事件，比如，在登录的时候，按Enter键可以直接提交登录；又比如，在即时通讯的背景下，消息的实时生成，消息发送窗口的发送按钮通过Enter键是可以触发的，此时文本域的Enter换行操作是禁止的，取而代之的是shift+Enter或者自定义，下面来看看在Vue项目中是如何操作的。 案例采用Iview框架，需要监听键盘按下事件 12&lt;Input v-model=&quot;inputValue&quot; type=&quot;textarea&quot; :rows=&quot;5&quot; :autosize=&quot;false&quot; @keydown.native=&quot;listenKey($event)&quot; placeholder=&quot;请输入消息...&quot; /&gt;&lt;Button @click=&quot;handleSendMessage&quot; size=&quot;small&quot;&gt;发送&lt;/Button&gt; 利用Vue组件的生命周期，在组件挂载之后进行时间监听，组件销毁之后移除事件监听，然后通过点击事件传入的event对象判断键码，从而阻止对应的默认操作 1234567891011121314151617181920212223242526272829303132mounted() &#123; // 绑定enter事件 this.enterKeyup();&#125;,destroyed() &#123; // 销毁enter事件 this.enterKeyupDestroyed();&#125;,methods:&#123; enterKeyupDestroyed() &#123; document.removeEventListener(&quot;keyup&quot;, this.handleSendMessage); &#125;, enterKeyup() &#123; document.addEventListener(&quot;keyup&quot;, this.handleSendMessage); &#125;, handleSendMessage(e)&#123; if (!e.shiftKey &amp;&amp; e.keyCode === 13) &#123; console.log(&#x27;发送&#x27;,e) &#125; &#125;, listenKey(e)&#123; if(!e.shiftKey &amp;&amp; e.keyCode == 13)&#123; e.cancelBubble=true; e.preventDefault(); e.stopPropagation(); &#125; // if (e.keyCode === 13) &#123; // e.preventDefault() // 阻止浏览器默认换行操作 // return false // &#125; &#125;&#125; 除了监听键盘事件外，有时候我们还需要操作页面的滚动事件，比如，在我们QQ、微信聊天的时候，最新消息总是处于消息框中的最底部，而此时滚动条也总是滚动到最底部，我们同样需要借助生命周期函数和DOM操作来实现。 此时，消息框是随着数据的改变而动态变化的 123456789&lt;div class=&quot;body-middle-box&quot; id=&quot;messageBox&quot;&gt; &lt;div class=&quot;message-box&quot;&gt; &lt;div v-for=&quot;(item,index) in currentMessageList&quot; :key=&quot;index&quot; :class=&quot;item.userName===currentConversation.conversationID?&#x27;message-item message-right&#x27;:&#x27;message-item&#x27;&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;https://dev-file.iviewui.com/userinfoPDvn9gKWYihR24SpgC319vXY8qniCqj4/avatar&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;p&gt;&#123;&#123;item.content&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 然后借助声明周期函数，组件挂载后执行滚动操作函数，当数据发生变化引起页面DOM更新后再次调用滚动操作函数，由于Vue是不鼓励直接操作DOM的，需要利用nextTick函数DOM刷新后执行相应的操作，当然，也可以使用Vue提供的refs操作DOM 1234567891011121314mounted() &#123; this.alwaysScrollBottom()&#125;,updated() &#123; this.alwaysScrollBottom()&#125;,methods: &#123; alwaysScrollBottom()&#123; this.$nextTick(() =&gt; &#123; let msg = document.getElementById(&#x27;messageBox&#x27;) // 获取对象 msg.scrollTop = msg.scrollHeight // 滚动高度 &#125;) &#125;&#125;","tags":[]},{"title":"单多行文本溢出显示省略号","date":"2020-03-08T13:38:00.000Z","path":"2020/03/08/文本溢出显示省略号/","text":"很多有时候，我们希望文本溢出的时候通过显示省略号来提示，相信大多数都知道单行文本溢出通过css的文本溢出属性可以设置，那么，这个归纳一下单、多行文本溢出的情况。 一、单行文本 单行溢出，超出部分显示…，前提必须有宽度。 1234width:300px; overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 二、多行文本 12345display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-line-clamp:2;-webkit-box-orient:vertical; 适用范围：因为使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； 注： 1.-webkit-line-clamp用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： 2.display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 3.-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 为了做到更好的兼容性，这时候需要借助伪类元素来实现。 1234567891011121314151617p&#123; position: relative; line-height: 20px; max-height: 40px; overflow: hidden;&#125; p::after&#123; content: &quot;...&quot;; position: absolute; bottombottom: 0; rightright: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(rightright, transparent, #fff 55%); background: -moz-linear-gradient(rightright, transparent, #fff 55%); background: linear-gradient(to rightright, transparent, #fff 55%); &#125; -webkit-line-clamp 是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他外来的WebKit属性。","tags":[{"name":"防抖","slug":"防抖","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E9%98%B2%E6%8A%96/"}]},{"title":"函数的节流和防抖","date":"2019-06-15T14:32:00.000Z","path":"2019/06/15/节流与防抖/","text":"函数防抖：当某事件被持续触发时，一定时间内事件没有再触发，事件处理函数才会执行一次，如果设定的时间到来之前，又重新触发了一次事件，就重新开始计时延迟。总结为一句话，多次触发事件，在最后一次延迟规定时间后执行。 简单的函数防抖代码： 12345678910111213141516function debounce(fn, wait)&#123; let timeout = null; return function()&#123; if(timeout !== null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// handlefunction handle()&#123; console.log(Math.random());&#125;//触发事件window.addEventListener(&#x27;scroll&#x27;, debounce(handle, 1000)); 我们可以看出，当事件scroll触发后1000ms后，执行handle函数，当滚动事件持续触发时，handle函数是不执行的。 ** 案例 **表单输入校验 比如监听输入事件校验邮箱，如果我们每输入一次都要校验邮箱，这就造成了浪费，于是我们可以利用函数防抖，在输入间隔500ms时，进行校验。 123456789101112const reg = /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/; $(&#x27;#email&#x27;).on(&#x27;keyup&#x27;, verfiyEmail());function verifyEmail()&#123; let timer = null; return function()&#123; if(timer !== null) clearTimeout(timer); timer = setTimeout(function()&#123; console.log(&#x27;执行校验&#x27;) &#125;, 500) &#125;&#125; 函数节流 函数节流：当事件持续触发时，保证一定时间段只执行一次的函数。 函数节流主要有两种实现方法：时间戳和定时器的方式。接下来分别实现这两种方式。 函数节流代码（时间戳）： 1234567891011121314151617let throttle = function(fn, delay)&#123; let prev = Date.now(); return function()&#123; let context = this; let args = arguments; let now = Date.now(); if(now - prev &gt;= delay)&#123; fn.apply(context, args); prev = Date.now(); &#125; &#125;;&#125;;function handle()&#123; console.log(Math.random());&#125;window.addEventListener(&#x27;scroll&#x27;, throttle(handle, 1000)); 函数节流代码（定时器）： 12345678910111213141516171819let throttle = function(fn, delay)&#123; let timer = null; return function()&#123; let context = this; let args = arguments; if(!timer)&#123; timer = setTimeout(function()&#123; fn.apply(context, args); timer = null; &#125;, delay); &#125; &#125;&#125;;function handle()&#123; console.log(Math.random())&#125;window.addEventListener(&#x27;scroll&#x27;, throttle(handle, 1000)); 我们可以看出，时间戳方式的节流代码利用闭包，内部函数保存了开始执行时的时间戳，当事件持续触发时，利用先前的时间戳和现在时间戳对比，达到设定的范围执行一次操作函数。定时器方式的节流代码也是类似，在规定的时间段内只维护一个定时器。 ** 案例 **限时秒杀活动 我们有一个限时秒杀按钮，用户一般都会在活动倒计时的时候不断地点击按钮，按常规操作，点击一次按钮我们就提交一次请求，这时候的高并发操作肯定不是我们想要的，此时利用节流可以解决问题。 123456789101112131415161718let btn = ducument.getElementById(&#x27;show&#x27;);function throttle(fn, wait)&#123; let prev = Date.now(); return function()&#123; let now = Date.now(); if(now - prev &gt;= wait)&#123; fn(); prev = Date.now(); &#125; &#125;&#125;function handle()&#123; console.log(&#x27;执行提交操作&#x27;)&#125;btn.onClick = throttle(handle, 1000); 区别：函数节流不管时间触发多频繁，都会保证在规定的时间触发一次；而防抖只是在事件触发的最后一次，在延迟规定的时间后执行函数。","tags":[{"name":"防抖","slug":"防抖","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E9%98%B2%E6%8A%96/"}]},{"title":"mongoose的增删查改","date":"2019-06-03T13:43:00.000Z","path":"2019/06/03/mongoose之增删查改/","text":"专业课上，老师经常告诉我们，数据库的操作无非就是增删查改，即CURD，事实也正是如此，我们接下来看看mongoose操作no SQL数据库MongoDB的CURD。 1.连接数据库 连接数据的详细文档请移步mongoose文档。 then回调模式 假设数据库连接地址为mongodb://localhost:27017/TestDB 假设数据操作模型Model为： 12345678910111213// peopleModel.jslet mongoose = require(&#x27;mongoose&#x27;);let Schema = mongoose.Schema;let PeopleSchema = new Schema(&#123; name: String, age: Number, sex: Number, class: String&#125;);module.exports = mongoose.model(&#x27;People&#x27;, PeopleSchema, &#x27;peopleCollection&#x27;); 1234567891011const mongoose = require(&quot;mongoose&quot;);var mongourl = &#x27;mongodb://localhost:27017/TestDB&#x27;;mongoose.connect(mongourl).then( () =&gt; &#123; console.log(&#x27;连接成功！&#x27;) &#125;, err =&gt; &#123; console.log(&#x27;出错！&#x27;, err); &#125;); on监听模式 12345678910let mongoose = require(&#x27;mongoose&#x27;);let mongoURL = &#x27;mongodb://localhost:27017/TestDB&#x27;;mongoose.connect(mongoURL);mongoose.Promise = global.Promise;let db = mongoose.connection;db.on(&#x27;error&#x27;,console.error.bind(console, &#x27;MongoDB connection error:&#x27;));db.once(&#x27;open&#x27;, function() &#123; // we&#x27;re connected!&#125;); 常见操作条件和API 常见的查询条件 $or 或关系 $nor 或关系取反 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $ne 不等于 $in 在多个值范围内 $nin 不在多个值范围内 $all 匹配数组中多个值 $regex 正则，用于模糊查询 $size 匹配数组大小 $maxDistance 范围查询，距离（基于LBS） $mod 取模运算 $near 邻域查询，查询附近的位置（基于LBS） $exists 字段是否存在 $elemMatch 匹配内数组内的元素 $within 范围查询（基于LBS） $box 范围查询，矩形范围（基于LBS） $center 范围醒询，圆形范围（基于LBS） $centerSphere 范围查询，球形范围（基于LBS） $slice 查询字段集合中的元素（比如从第几个之后，第N到第M个元素 常见的查询API，详细请查看文档 Model.deleteMany() 删除所有文档集合的匹配条件 相当于remove() 参数分别为：条件、操作、回调 Model.deleteOne() 删除匹配条件的文档集合的第一个文档 想当于remove() 参数分别为：条件、回调 Model.find() 查询文档 参数分别为：条件、选择字段、操作、回调 Model.findById() 通过_id字段查询文档 相当于findOne({ _id: id }) 参数分别为：id、选择字段、操作、回调 Model.findByIdAndDelete() 大多数情况使用它 通过_id字段查询文档并删除 相当于findOneAndDelete({ _id: id })的快捷方式 参数分别为：id、操作、回调 Model.findByIdAndRemove() 通过_id字段查询文档并移除 相当于findOneAndRemove({ _id: id })的快捷方式 参数分别为：id、操作、回调 Model.findByIdAndUpdate() 通过_id字段查询文档并更新 相当于findOneAndUpdate({ _id: id }, …) 参数分别为：id、更新字段、操作、回调 Model.findOne() 查询一个文档 参数分别为：条件、选择字段、操作、回调 Model.findOneAndDelete() 查询一个匹配的文档并删除 参数分别为：条件、操作、回调 Model.findOneAndRemove() 查询一个匹配的文档并移除 参数分别为：条件、操作、回调 Model.findOneAndUpdate() 查询一个匹配的文档并更新 参数分别为：条件、更新字段、操作、回调 Model.replaceOne() 覆盖一个已经存在的文档 相当于update() 参数分别为：条件、更新字段、操作、回调 Model.updateMany() 更新多个已经存在的文档 相当于update() 参数分别为：条件、更新字段、操作、回调 Model.updateOne() 更新一个已经存在的文档 相当于update() 参数分别为：条件、更新字段、操作、回调 Model.remove() 移除所有匹配的文档 参数分别为：条件、回调 Model.update() 更新一个文档 参数分别为：条件、更新字段、操作、回调 关于findByIdAndDelete()和findByIdAndRemove()的区别，请移步官方文档。 2.查询数据 1234567891011121314151617181920212223242526272829303132333435363738let express = require(&#x27;express&#x27;);let router = express.Router();let mongoose = require(&#x27;mongoose&#x27;);let People = require(&#x27;../models/peopleModel&#x27;);router.get(&#x27;/&#x27;, function(req, res, next)&#123; // 需使用body-parse中间件获取参数 let filters = &#123; ...req.query &#125;; console.log(filters, &#x27;filter&#x27;); // 要查询的字段 let query = &#123;&#125;; if(filters.name)&#123; query.name = filters.name &#125; if(filters.age)&#123; //查询年龄大于age参数 query.bookInfo = &#123;$gt: filters.age&#125; &#125; People.find(query, null, &#123; limit: filters.pageSize, skip: (filters.pageSize * filters.pageNum), sort:&#x27;-createBy.age&#x27; &#125;, (err, data) =&gt; &#123; //查找所有 if(err)&#123; res.status(500).json(&#123; error: err &#125;); &#125;else&#123; res.json(&#123; code: 1, data: data &#125;); &#125; &#125;)&#125;);module.exports = router; 当前端传相应的数据过来时，这边通过过滤和提取分页字段，利用limit和skip操作来实现数据分页，也可以使用mongoose-paginate插件来简化分页操作，当前端传了对应的筛选字段过来，这边将按对应字段查询结果，并按age值倒序返回。 2.添加数据 添加数据需要用到mongoose的save()方法 12345678910111213141516171819202122232425262728293031let express = require(&#x27;express&#x27;);let router = express.Router();let mongoose = require(&#x27;mongoose&#x27;);let People = require(&#x27;../models/peopleModel&#x27;);router.post(&#x27;/&#x27;, function(req, res, next)&#123; const name = req.body.name, age = req.body.age, sex = req.body.sex, class = req.body.class; const newPeople = new People(&#123; name, age, sex, class &#125;); // 新增保存 newPeople.save((err, data) =&gt; &#123; if(err)&#123; res.status(500).json(&#123; error: err &#125;); &#125;else&#123; res.json(&#123; code: 1, data: data &#125;); &#125; &#125;);&#125;);module.exports = router; 3.修改数据 数据的修改需要用到_id字段，这个字段会在MongoDB数据库每增加一条新的记录时自动生成，也是唯一标识，同时，需要用到findByIdAndUpdate()方法来操作数据更新。 12345678910111213141516171819202122232425262728293031let express = require(&#x27;express&#x27;);let router = express.Router();let mongoose = require(&#x27;mongoose&#x27;);let People = require(&#x27;../models/peopleModel&#x27;);router.post(&#x27;/&#x27;, function(req, res, next)&#123; const _id = req.body._id, name = req.body.name, age = req.body.age, sex = req.body.sex, class = req.body.class; const updateFields = &#123; _id, name, age, sex, class &#125;; // 通过_id更新指定指字段 People.findByIdAndUpdate(&#123;_id, _id&#125;, updateFields, (err, data) =&gt; &#123; if(err)&#123; res.status(500).json(&#123; error: err &#125;); &#125;else&#123; res.json(&#123; code: 1, data: data &#125;) &#125; &#125;);&#125;);module.exports = router; 4.删除数据 数据的删除涉及到单条数据的删除和批量删除，可以通过传单个id字符或者id字符串数组来实现不同的删除功能，需要用到$in条件操作符和remove()方法。 1234567891011121314151617181920212223242526272829let express = require(&#x27;express&#x27;);let router = express.Router();let mongoose = require(&#x27;mongoose&#x27;);let People = require(&#x27;../models/peopleModel&#x27;);router.post(&#x27;/&#x27;, function(req, res, next)&#123; let ids = req.body._id; let condition; if(Array.isArray(ids))&#123; condition = &#123; _id: &#123; $in: ids &#125; &#125; &#125;else&#123; condition = &#123; _id: ids &#125; &#125; People.remove(condition, (err, data) =&gt; &#123; if(err)&#123; res.status(500).json(&#123; error: err &#125;); &#125;else&#123; res.json(&#123; code: 1, data: data &#125;) &#125; &#125;)&#125;);module.exports = router; 至此，mongoose对于MongoDB的增删查改操作案例都实现了，相信大家会对MongoDB的操作有个较好的入门。","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/MongoDB/"}]},{"title":"js多箭头和函数柯里化","date":"2019-05-30T10:43:00.000Z","path":"2019/05/30/js函数柯里化/","text":"高阶函数 高阶函数是至少满足以下条件之一的函数： [ ] 函数可以作为参数被传递； [ ] 函数可以作为返回值输出。 举几个例子，js中的排序函数sort，就是函数作为参数的一个高阶函数。 1234567891011// 从小到大[1,5,8,6,9,0].sort(function(a, b)&#123; return a - b;&#125;)// [0,1,5,6,8,9]//从大到小[1,5,8,6,9,0].sort(function(a, b)&#123; return b - a;&#125;)// [9,8,6,5,1,0] js中判断数据类型的，就是函数作为返回值。 1234567const isType = function(type) &#123; return function(obj) &#123; return object.prototype.toString.call(obj) === `[object $&#123;type&#125;]`; &#125;&#125;let isNumber = isType(&#x27;Number&#x27;);console.log(isNumber(20)); // true 函数柯里化 函数柯里化（function currying）概念最早是由俄国数学家Moses Schönfinkel发明出来，后由数学家Haskell Curry丰富和发展，currying由此得名。 currying又称部分求值。一个currying函数首先会接收一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形式的闭包中 被保存起来。待到函数真正需要求值的时候，之前传入的所以参数都会被一次性用于求值。 下面来看一个最简单的计费函数： 12345678910let totalCost = 0;let billing = function(num)&#123; totalCost += num;&#125;;billing(20);billing(12);billing(64);billing(16);console.log(totalCost); //112 通过这段代码我们可以计算出某时间段的费用，然而这段代码有两个弊端，一是在外部暴露了一个全局变量，容易导致变量污染；二是我们并不关心每天花费多少，并不想每次花费都计算一次，而是 希望在最后需要计算时在全部做计算。接下来我们改进代码，用currying实现效果。 12345678910111213141516171819let totalCost = (function() &#123; let args = []; return function() &#123; if (arguments.length === 0) &#123; let money = 0; for (let i = 0, l = args.length; i &lt; l; i++) &#123; money += args[i]; &#125; return money; &#125; else &#123; [].push.apply(args, arguments); &#125; &#125;&#125;)();totalCost(12);totalCost(62);totalCost(15);console.log(const()); // 89 多箭头函数 多箭头函数其实就是函数柯里化的es6写法，比如我们常见的求和函数，采用高阶函数的写法： 12345678function sum(a)&#123; return function(b)&#123; return a + b; &#125;&#125;let addLater = sum(3);console.log(addLater(5)); //8 采用es6对箭头的写法等价于：let sum = a =&gt; b =&gt; a + b; wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术 简单的理解就是，把第一个参数变量存在了函数（闭包）里面，然后需要n个参数就变成了需要n-1个参数就可以调 用函数了。例如上面的案例： 12let sum = a =&gt; b =&gt; a + b;let sum2 = sum(2); 本来完成sum操作应该是： 1let sum = (a, b) =&gt; x + y; 它需要俩参数，而上面的sum函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 详细解释一下，就是sum函数等价于有了x这个闭包变量的y =&gt; x + y函数。 也因此当a = 2，然后再调用sum2(5)时： 1sum(5) ==== 2 + 5 函数柯里化有两个功能：一是可以惰性求值；二是可以提前传递部分参数。","tags":[{"name":"柯里化","slug":"柯里化","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"}]},{"title":"vue中后台项目的路由嵌套","date":"2019-05-25T14:57:00.000Z","path":"2019/05/25/vue路由嵌套/","text":"在追求速度的今天，我们都是习惯了开箱即用的框架，因为这样，我们只需要在其中添砖加瓦就可以完成一个项目的开发，不用考虑所谓的配置、环境、兼容等等。然而，在使用的时候，我们是否会考虑某些效果的实现原理。比如，接下来要说的中后台管理系统路由的嵌套。 常见的中后台管理系统的布局都是顶部信息栏，左边菜单侧边栏，右边主内容区块，有时候还需要底部页脚区块，通过切换左侧菜单，右侧主内容区变更，而左侧和顶部是不变的，这样的体验也就是常说的SPA应用，当我们登陆超时或者退出登陆时页面跳转到登录页，而此时并没有固定的布局，也就是说跳出了固定的布局渲染区块。 对于上面说到的效果，在react项目里面，可以用到react-router路由嵌套实现，在vue项目里面，可以使用vue-router路由嵌套实现，这里主要阐述vue项目中SPA应用路由嵌套的实现逻辑。 上代码之前先了解一下vue-router嵌套原则，详细配置请移步官方文档。 单层渲染： 当路由匹配到/user/xxx时，渲染User组件 123&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910const User = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;&#125; const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/user/:id&#x27;, component: User &#125;]&#125;) 嵌套渲染： 当路由匹配到/user/xxx时，渲染User组件 12345678910111213141516171819202122232425262728const User = &#123; template: ` &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125;const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/user/:id&#x27;, component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: &#x27;&#x27;, component: UserHome &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &#x27;posts&#x27;, component: UserPosts &#125;] &#125;]&#125;) 了解了嵌套路由规则，接下来，初始化vue-cli脚手架项目，安装vue-router，在vue挂载的DOM下添加router-view: 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; name: &#x27;app&#x27;, data() &#123; return &#123; &#125; &#125;, components: &#123; &#125;, mounted() &#123; &#125;, methods: &#123; &#125;&#125;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; 在main.js文件中使用vue-router: 123456789101112131415import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;import server from &#x27;./plugin&#x27;import router from &#x27;./router&#x27;// 核心插件Vue.use(ElementUI);Vue.use(server);new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 编写公共组件，包含头部、侧边栏和主内容区块的组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div&gt; &lt;!--头部--&gt; &lt;div class=&quot;mdui-appbar mdui-appbar-fixed&quot;&gt; &lt;div class=&quot;mdui-toolbar mdui-color-theme&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;mdui-btn mdui-btn-icon&quot;&gt;&lt;i class=&quot;mdui-icon material-icons&quot;&gt;menu&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#/&quot; class=&quot;mdui-typo-headline&quot;&gt;LOGO&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;mdui-typo-title&quot;&gt;标题&lt;/a&gt; &lt;div class=&quot;mdui-toolbar-spacer&quot;&gt;&lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;mdui-btn mdui-btn-icon&quot; mdui-tooltip=&quot;&#123;content: &#x27;搜索&#x27;&#125;&quot;&gt; &lt;i class=&quot;mdui-icon material-icons&quot;&gt;search&lt;/i&gt; &lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;mdui-btn mdui-btn-icon&quot; mdui-tooltip=&quot;&#123;content: &#x27;刷新&#x27;&#125;&quot;&gt; &lt;i class=&quot;mdui-icon material-icons&quot;&gt;refresh&lt;/i&gt; &lt;/a&gt; &lt;a href=&quot;javascript:;&quot; mdui-dialog=&quot;&#123;target: &#x27;#login-modal&#x27;&#125;&quot; class=&quot;mdui-btn mdui-btn-icon&quot; mdui-tooltip=&quot;&#123;content: &#x27;登陆或注册&#x27;&#125;&quot;&gt; &lt;i class=&quot;mdui-icon material-icons&quot;&gt;transfer_within_a_station&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--头部结束--&gt; &lt;!--侧边栏--&gt; &lt;div class=&quot;mdui-drawer&quot; id=&quot;drawer&quot;&gt; &lt;ul class=&quot;mdui-list&quot; mdui-collapse=&quot;&#123;accordion: true&#125;&quot;&gt; &lt;template v-for=&quot;(item, index) in sideMenu&quot;&gt; &lt;li class=&quot;mdui-collapse-item&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;mdui-collapse-item-header mdui-list-item mdui-ripple&quot;&gt; &lt;i class=&quot;mdui-list-item-icon mdui-icon material-icons&quot;&gt;&#123;&#123;item.icon&#125;&#125;&lt;/i&gt; &lt;div class=&quot;mdui-list-item-content&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;i class=&quot;mdui-collapse-item-arrow mdui-icon material-icons&quot;&gt;keyboard_arrow_down&lt;/i&gt; &lt;/div&gt; &lt;ul class=&quot;mdui-collapse-item-body mdui-list mdui-list-dense&quot;&gt; &lt;template v-for=&quot;(n, i) in item.children&quot;&gt; &lt;li class=&quot;mdui-list-item mdui-ripple&quot; :key=&quot;n.name + i&quot;&gt;&lt;router-link :to=&quot;n.path&quot;&gt;&#123;&#123;n.name&#125;&#125;&lt;/router-link&gt;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--侧边栏结束--&gt; &lt;!--主体内容区块--&gt; &lt;div class=&quot;mdui-container doc-container doc-no-cover&quot;&gt; &lt;router-view/&gt; &lt;/div&gt; &lt;!--主体内容区块结束--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import sideMenu from &quot;../../menuConfig&quot;; export default &#123; name: &quot;layouts&quot;, data() &#123; return &#123; sideMenu: sideMenu, &#125; &#125;, mounted() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 这里使用mdui框架，导入menu菜单配置文件，通过vue遍历生成对应的DOM元素，menuConfig可以自行根据需求配置，然后再主内容区块嵌套&lt;router-view/&gt;。 下面才是重点，不过在重点到来之前我们需要新建router文件夹，并在里面新建index.js配置路由，然后新建page文件用户存放页面模块。 路由配置index.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import Vue from &#x27;vue&#x27;;import VueRouter from &#x27;vue-router&#x27;; import BookLists from &#x27;../pages/bookLists&#x27;;import Login from &#x27;../pages/login&#x27;; import HeaderAside from &#x27;../layouts/HeaderAside&#x27;; let transformRoutes = [&#123; path: &#x27;/login&#x27;, component: Login&#125;,&#123; path: &#x27;/bookLists&#x27;, component: HeaderAside, children: [&#123; // 当 /bookLists 匹配成功， // BookLists 会被渲染在 HeaderAside 的 &lt;router-view&gt; 中 path: &#x27;&#x27;, component: BookLists &#125;]&#125;]; Vue.use(VueRouter); // 导出路由 在 main.js 里使用const router = new VueRouter(&#123; routes: transformRoutes&#125;); /** * 路由拦截 * 权限验证 */router.beforeEach((to, from, next) =&gt;&#123; if (to.path == &quot;/login&quot;) &#123; next(); &#125; else &#123; if (localStorage.getItem(&#x27;token&#x27;)) &#123; next() &#125; else &#123; next(&#123; path: &quot;/login&quot; &#125;) &#125; &#125;&#125;);export default router; 当我们在浏览器输入对应的URL之后，路由拦截器检测本地是否授权存有token，如果存有token即匹配路由，渲染对应的组件，例如，访问/bookLists，路由配置/bookLists，对应在根级挂载点#app渲染HeaderAside组件， 然后在HeaderAside组件中router-view渲染children中的BookLists组件，这样达到了嵌套路由的效果；如果不存在token，此时配置/login，跳转到单层路由渲染，直接在在根级挂载点#app渲染Login组件，因为route不存在children属性， 所以对应的HeaderAside组件中的router-view也不会渲染。这里的路由嵌套transformRoutes是属于硬编码，我们可以根据需求情况分离出一个模块，通过配置文件自动生成，这样达到可扩展的目的。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"express基于JWT实现用户登陆授权","date":"2019-05-19T12:13:00.000Z","path":"2019/05/19/JWTAuthToken/","text":"你是否和我一样，在对接后端大佬的接口时，对于请求头authorization认证感到疑惑； 你是否和我一样，在向node后端领域扩展时，对于用户登陆注册授权感到挠头； 你是否和我一样，在浏览器访问某个页面时，对于访问权限控制感到好奇； 那么，请花上几分钟时间阅读，让下文来帮你解惑。 本文主要通过express来实现用户登陆授权的逻辑，这里的JWT只是一个标准，全称：JSON Web Token。有兴趣的小伙伴可以去官方说明加深了解。 初识JWT 了解http协议的同学都知道，http协议是无状态的，所以就需要客户端在每次请求的时候携带一些标识来表明身份，所以就有了Cookie、Authorization、Token、session_id等，客户端认证访问服务端的模式一般如下： 客户端提交用户信息登陆 服务端验证通过后，存储相关对话信息，生成对应的标识字符（token、Authorization、session_id），返回给客户端 客户端接收服务器返回内容，存储到对应的位置（cookie、localstorage） 客户端每次都携带这个标识字符进行服务端数据请求 服务端根据标识字符校验身份，进行数据处理 JWT字符由三部分组成，例如： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNTU3NzM5NjM1LCJleHAiOjE1NTgzNDQ0MzV9.L4PqLf7PatEf_TVrNG2GgyBlU7YR8iuEoXOOeu7i15g 按照格式排列就是这样Header.Payload.Signature Header: JWT的元数据，一般是一些要加密的json对象，比如&#123;username: 'Tom'&#125; Payload: JWT的负载对象，一般是JWT官方规定的字段，比如exp（过期时间），详见字段说明 Signature: 对前两部分和私有秘钥进行签名 本文案例使用npm包jsonwebtoken，点击查看用法。 项目初始配置 初始化一个express项目，配置数据库连接和加载bodyParser插件。 12345678910111213//connect mongoDBlet mongoose = require(&#x27;mongoose&#x27;);let mongoURL = &#x27;mongodb://localhost/dataBase&#x27;;mongoose.connect(mongoURL);mongoose.Promise = global.Promise;let db = mongoose.connection;db.on(&#x27;error&#x27;,console.error.bind(console, &#x27;MongoDB connection error:&#x27;));let bodyParser = require(&#x27;body-parser&#x27;);// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/jsonapp.use(bodyParser.json()); 用户注册 编写用户model 用于连接数据库的数据Schema模型 12345678910var mongoose = require(&#x27;mongoose&#x27;);var Schema = mongoose.Schema;var AuthSchema = new Schema(&#123; username: String, userpswd: String&#125;);// 参数：导出模块名称、Schema实例、数据表名称module.exports = mongoose.model(&#x27;AuthInfo&#x27;, AuthSchema, &#x27;authinfo&#x27;); 编写注册route 基于restful API的接口路由 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var express = require(&#x27;express&#x27;);var router = express.Router();var bodyParser = require(&#x27;body-parser&#x27;); var mongoose = require(&#x27;mongoose&#x27;);var AuthInfo = require(&#x27;../models/authModel&#x27;); // 导入model模块router.post(&#x27;/&#x27;,function(req, res, next) &#123; console.log(&#x27;open post register&#x27;); var username = req.body.username; var password = req.body.password; //是否合法的参数 if (username == null || username.trim() == &#x27;&#x27; || password == null || password.trim() == &#x27;&#x27;) &#123; res.send(&#123; code: 500, message: &#x27;用户名密码不能为空&#x27; &#125;) return &#125; // md5 var md5String = require(&#x27;crypto&#x27;).createHash(&#x27;md5&#x27;).update(password).digest(&#x27;hex&#x27;); //验证账号是否存在 var queryString = &#123; username: username &#125;; res.set(&#123; &#x27;Content-type&#x27;: &#x27;application/json;charset=utf-8&#x27; &#125;); AuthInfo.findOne(queryString).then(data =&gt;&#123; return new Promise((resolve, reject) =&gt;&#123; if (data) &#123; res.send(&#123; code: 500, message: &#x27;用户已经注册&#x27; &#125;); reject(); &#125; else &#123; resolve(); &#125; &#125;).then(() =&gt;&#123; //保存 return new AuthInfo(&#123; username: username, password: md5String &#125;).save(); &#125;).then(data =&gt;&#123; if (data) &#123; //返回 res.send(&#123; code: 1, message: &#x27;注册成功&#x27; &#125;) return; &#125; // 返回 res.send(&#123; code: 500, message: &#x27;注册失败&#x27; &#125;); &#125;). catch(err =&gt;&#123; // 异常 if (err) &#123; res.status(500).send(err); console.log(err); &#125; &#125;) &#125;)&#125;); module.exports = router; 编写登陆route 基于restful API的接口路由 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var express = require(&#x27;express&#x27;);var router = express.Router();var bodyParser = require(&#x27;body-parser&#x27;); var mongoose = require(&#x27;mongoose&#x27;);var AuthInfo = require(&#x27;../models/authModel&#x27;); router.post(&#x27;/&#x27;,function(req, res, next) &#123; var username = req.body.username; var password = req.body.password; //是否合法的参数 if (username == null || username.trim() == &#x27;&#x27; || password == null || password.trim() == &#x27;&#x27;) &#123; res.send(&#123; code: 500, message: &#x27;用户名密码不能为空&#x27; &#125;) return; &#125; var md5String = require(&#x27;crypto&#x27;).createHash(&#x27;md5&#x27;).update(password).digest(&#x27;hex&#x27;); // md5 //验证账号是否存在 var queryString = &#123; username: username, userpswd: md5String &#125;; res.set(&#123; &#x27;Content-type&#x27;: &#x27;application/json;charset=utf-8&#x27; &#125;); // md5 token var tokenString = require(&#x27;crypto&#x27;).createHash(&#x27;md5&#x27;).update(JSON.stringify(queryString)).digest(&#x27;hex&#x27;); AuthInfo.findOne(queryString).then(data =&gt;&#123; return new Promise((resolve, reject) =&gt;&#123; if (data) &#123; resolve(data); &#125; else &#123; res.send(&#123; code: 500, message: &#x27;用户名或密码错误&#x27; &#125;) reject() &#125; &#125;).then(data =&gt;&#123; console.log(data); res.send(&#123; code: 1, message: &#x27;登陆成功&#x27;, token: tokenString &#125;) &#125;) &#125;). catch(err =&gt;&#123; if (err) &#123; res.status(500).send(err); console.log(err); &#125; &#125;)&#125;); module.exports = router; 这里和注册不同的是我们需要把从前端页面接收到的密码通过MD5转换才能用于数据库查询，因为数据库的密码字段也正是存着MD5转换过后的字符，当查询成功之后，我们还需要通过对刚才登陆的表单字段对象进行字符串转换，然后再通过MD加密后作为token返回给客户端。 上面是一个简单的使用MD5加密的token用户授权案例，并没有使用JWT，然而，使用JWT认证，我们只需要进行少部分的变动 这里我们需要借助npm包： jsonwebtoken，前端方面需要在axios或者fetch的默认headers配置中配置认证信息，比如： axios.defaults.headers['Authorization'] = sessionStorage.getItem(&quot;token&quot;); 注册逻辑不变，我们只需要更改用户登录成功之后的token生成方式为JWT，并且在服务中做路由拦截并对客户端携带过来的认证信息做校验即可。 JWT登陆route改进 12345678910111213141516171819202122232425262728293031323334353637383940var jwt = require(&#x27;jsonwebtoken&#x27;); // 借助 jsonwebtoken// ...AuthInfo.findOne(queryString).then(data =&gt;&#123; return new Promise((resolve, reject) =&gt;&#123; if (data) &#123; resolve(data); &#125; else &#123; res.send(&#123; code: 500, message: &#x27;用户名或密码错误&#x27; &#125;) reject() &#125; &#125;).then(data =&gt;&#123; console.log(data); /***jwt生成token***/ let content = &#123; username: username &#125;; // 要生成token的主题信息 let secretOrPrivateKey = &quot;This is perfect projects.&quot;; // 这是加密的key（密钥） 根据个人自定义 let token = jwt.sign(content, secretOrPrivateKey, &#123; expiresIn: 60 * 60 * 24 * 7 // 一周过期 &#125;); res.send(&#123; code: 1, message: &#x27;登陆成功&#x27;, token: token &#125;) &#125;)&#125;).catch(err =&gt;&#123; if (err) &#123; res.status(500).send(err); console.log(err); &#125;&#125;)// ... JWT项目初始配置改进 123456789101112131415161718192021222324252627282930313233343536var jwt = require(&#x27;jsonwebtoken&#x27;); // 借助 jsonwebtoken// ...let allowCrossDomain = function(req, res, next) &#123; // 响应头设置 添加Methods: OPTIONS、Headers: Authorization res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://localhost:8082&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;GET,PUT,POST,DELETE,OPTIONS&#x27;); res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;content-type,token,id&#x27;); res.header(&quot;Access-Control-Request-Headers&quot;, &quot;content-Type, Authorization&quot;); res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;); next();&#125;;app.use(allowCrossDomain);//添加拦截器app.use(function(req, res, next) &#123; // 获取请求头中的Authorization认证字符 let authorization = req.get(&#x27;Authorization&#x27;); // 排除不需要授权的路由 if (req.path === &#x27;/api/login&#x27;) &#123; next() &#125; else if (req.path === &#x27;/api/register&#x27;) &#123; next(); &#125; else &#123; let secretOrPrivateKey = &quot;This is perfect projects.&quot;; jwt.verify(authorization, secretOrPrivateKey, function(err, decode) &#123; if (err) &#123; // 认证出错 res.status(403).send(&#x27;认证无效，请重新登录。&#x27;); &#125; else &#123; next(); &#125; &#125;) &#125;&#125;)//... JWT认证方案相对于简单token认证方式变动不大，只是变更了token生成方式和用户身份的校验方式，了解JWT认证，对于我们理解前后端交互具有更大的帮助。 本文参考： https://juejin.im/post/5c2a2f5df265da613d7c2a3a#heading-12 http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html","tags":[{"name":"express","slug":"express","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/express/"},{"name":"登陆","slug":"登陆","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%99%BB%E9%99%86/"}]},{"title":"前端异步处理的演进","date":"2019-05-15T14:13:00.000Z","path":"2019/05/15/前端异步处理的演进/","text":"早期的网页都是静态页面，也不存在前后端分离，随着互联网的兴起了网站应用的增加，网站需要更多的和服务器交互，这时候为了实现异步处理，出现了ajax，我们采用setTimeout来模拟服务端请求。 123456789function ajax() &#123; setTimeout(() = &gt;&#123; console.log(&#x27;之前执行&#x27;); &#125;, 2000)&#125;ajax();console.log(&#x27;之后执行&#x27;); 运行代码结果： 123之后执行//-- 2s后之前执行 这并不是我想要的结果，因为代码是自上而下执行，遇到异步请求代码片段延迟执行，而异步代码片段外继续执行，这时候我们可以通过函数做为参数改进代码。 1234567891011function ajax(fn) &#123; setTimeout(() = &gt;&#123; console.log(&#x27;之前执行&#x27;); fn() &#125;, 2000)&#125;ajax(() = &gt;&#123; console.log(&#x27;之后执行&#x27;);&#125;); 运行代码结果： 123//-- 2s后之前执行之后执行 这样虽然暂时是我们想要的效果，但是当应用庞大，后一个请求依赖前一个请求执行的结果时，就容易陷入回调地狱模式。 1234567891011121314151617function ajax(fn) &#123; setTimeout(() = &gt;&#123; console.log(&#x27;之前执行&#x27;); fn() &#125;, 2000)&#125;ajax(() = &gt;&#123; console.log(&#x27;之后执行1&#x27;); ajax(() = &gt;&#123; console.log(&#x27;之后执行2&#x27;); ajax(() = &gt;&#123; console.log(&#x27;之后执行3&#x27;); &#125;); &#125;);&#125;); 运行代码结果： 1234567//-- 2s后之前执行之后执行1之前执行之后执行2之前执行之后执行3 上面这样就陷入了回调地狱，一旦项目过大，就造成难以调试和维护的问题，为了解决回调地狱的问题，Promise出现了。 123456789101112function delay(text) &#123; return new Promise((resolve, reject) = &gt;&#123; setTimeout(() = &gt;&#123; resolve(text); &#125;, 2000) &#125;)&#125;delay(&#x27;hello one&#x27;).then((msg) = &gt;&#123; console.log(msg);&#125;) 运行代码结果： 12//-- 2s后hello one Promise就相当于一个承诺，内部的函数的参数有两个，一个是成功解决resolve，另一个是拒绝reject，显著特征就是then、catch的回调，如上面案例所示，如果想要嵌套执行，就需要多次链式then回调。 123456789101112delay(&#x27;one&#x27;).then((msg) = &gt;&#123; console.log(msg); return delay(&#x27;two&#x27;);&#125;).then((msg) = &gt;&#123; console.log(msg); return delay(&#x27;three&#x27;);&#125;).then((msg) = &gt;&#123; console.log(msg);&#125;).catch(error = &gt;&#123; //捕获代码异常&#125;) 代码执行结果： 1234//-- 2s后onetwothree 这样的代码在很大程度上解决了回调地狱的问题，但是不断地链式回调的代码看起来并不是很优雅，因此出现了async await，它让异步代码看起来和同步代码一样优雅。 12345678910async function start() &#123; const txt1 = await delay(&#x27;one&#x27;); console.log(txt1); const txt2 = await delay(&#x27;two&#x27;); console.log(txt2); const txt3 = await delay(&#x27;three&#x27;); console.log(txt3);&#125;start(); 代码执行结果： 1234//-- 2s后onetwothree","tags":[{"name":"async","slug":"async","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/async/"},{"name":"await","slug":"await","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/await/"},{"name":"异步","slug":"异步","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%BC%82%E6%AD%A5/"},{"name":"promise","slug":"promise","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/promise/"}]},{"title":"VuePress搭建自己专属博客","date":"2019-04-11T14:12:00.000Z","path":"2019/04/11/vuePress搭建自己专属博客/","text":"VuePress 由两部分组成：一部分是支持用 Vue 开发主题的极简静态网站生成器，另一个部分是为书写技术文档而优化的默认主题。在VuePress应用的目录里面，一个.md文件可以生产一个.html文件，文件夹目录下默认访问README.md文件，也就相当于目录下的index.html，所以本地测试环境访问的链接如：http://localhost:8081/bar/barOne.html。 确保你的系统node.js版本 &gt;= 8 环境搭建 安装 全局安装： npm install -g vuepress 创建项目目录： mkdir myproject 初始化项目： cd myproject npm init -y 新建docs文件夹： mkdir docs 新建markdown文件： echo '# Hello VuePress!' &gt; README.md 设置package.json启动： 运行npm run build会生成静态目录dist 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;vuepress dev docs&quot;, &quot;build&quot;: &quot;vuepress build docs&quot; &#125;&#125;````创建.vuepress目录：进入docs文件夹中创建.vuepress目录存放vuePress的相关文件`cd docs``mkdir .vuepress`创建config.js文件：进入.vuepress文件夹中创建config.js文件，config.js是vuePress必要的配置文件，它导出一个js对象`cd .vuepress``type nul&gt;config.js`#### 基本配置**站点信息**config.js配置：config.js文件包含网站的标题，描述，部署信息等配置，其他详细配置见[官方文档](https://vuepress.vuejs.org/zh/config/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)```javascriptmodule.exports = &#123; title: &#x27;Hello VuePress&#x27;, description: &#x27;Just playing around&#x27;&#125; 主题配置 默认主题配置： 进入docs目录，修改README.md文件 1234567891011121314---home: trueheroImage: /hero.pngactionText: 快速上手 →actionLink: /zh/guide/features:- title: 简洁至上 details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。- title: Vue驱动 details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。- title: 高性能 details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。footer: MIT Licensed | Copyright © 2018-present Evan You--- 导航栏配置： 配置config.js，可以使用themeConfig配置给站点添加导航链接，在docs目录下新建about.md和contact.md文件，其他详细配置请查看官方文档 1234567891011module.exports = &#123; themeConfig: &#123; nav: [ &#123; text: &#x27;Home&#x27;, link: &#x27;/&#x27; &#125;, &#123; text: &#x27;foo&#x27;, link: &#x27;/foo/&#x27; &#125;, &#123; text: &#x27;bar&#x27;, link: &#x27;/bar/&#x27; &#125;, &#123; text: &#x27;About&#x27;, link: &#x27;/about&#x27; &#125;, &#123; text: &#x27;Contact&#x27;, link: &#x27;/contact&#x27; &#125;, ] &#125;&#125; 新增其他页面： 为了更好的演示侧边栏效果，新增四个页面，分别在docs目录下新增foo、bar文件夹，foo文件夹里面新建fooOne.md、fooTwo.md、RADME.md文件，新建文件或文件夹可参考上面命令行工具 配置侧边栏： 配置config.js，可以使用sidebar配置给站点添加侧边栏 12345678910111213141516module.exports = &#123; sidebar: &#123; &#x27;/foo/&#x27;: [ &#x27;&#x27;, &#x27;fooOne&#x27;, &#x27;fooTwo&#x27; ], &#x27;/bar/&#x27;: [ &#x27;&#x27;, &#x27;barOne&#x27;, &#x27;barTwo&#x27; ] &#125; &#125;&#125; 搜索配置： 配置config.js，可以使用search配置站点是否禁用启用搜索，可以使用searchMaxSuggestions配置站点搜素显示的结果条数 12345module.exports = &#123; search: true, searchMaxSuggestions: 10 &#125;&#125; 至此，一个简单的vuePress应用基本配置已经完成，最终的config.js文件如下： 123456789101112131415161718192021222324252627module.exports = &#123; title: &#x27;Hello VuePress&#x27;, description: &#x27;Just playing around&#x27;, themeConfig: &#123; nav: [ &#123; text: &#x27;Home&#x27;, link: &#x27;/&#x27; &#125;, &#123; text: &#x27;foo&#x27;, link: &#x27;/foo/&#x27; &#125;, &#123; text: &#x27;bar&#x27;, link: &#x27;/bar/&#x27; &#125;, &#123; text: &#x27;About&#x27;, link: &#x27;/about&#x27; &#125;, &#123; text: &#x27;Contact&#x27;, link: &#x27;/contact&#x27; &#125; ], sidebar: &#123; &#x27;/foo/&#x27;: [ &#x27;&#x27;, &#x27;fooOne&#x27;, &#x27;fooTwo&#x27; ], &#x27;/bar/&#x27;: [ &#x27;&#x27;, &#x27;barOne&#x27;, &#x27;barTwo&#x27; ] &#125;, search: true, searchMaxSuggestions: 10 &#125;&#125; 现在可以运行npm run build构建项目，生产dist目录文件，发布到对应的服务上去了。","tags":[{"name":"vuePress","slug":"vuePress","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vuePress/"}]},{"title":"antd官网描述页面多表单校验","date":"2019-04-08T11:34:00.000Z","path":"2019/04/08/ant页面多表单校验/","text":"问题 在做antd项目时发现，使用Form.create()(xxx)创建的模块里面的Form表单提交前可以使用this.props.form.validateFieldsAndScroll()判断是否校验成功，this.props.form也就是整个页面模块的Form，那么，如果页面上有多个Form，此时再使用this.props.form.validateFieldsAndScroll()判断校验结果就是对整个页面的Form进行判断，并不能够对单个Form校验结果做判断，问题就在此，如何对单个Form做判断？ 解决方法 手动校验，通过对表单元素添加change事件监听，获取表单元素值，手动做校验，这不失为一个方法，但有违react设计的思想。 把表单作为一个组件独立出去，页面通过props传入表单组件需要的值，在表单组件内部单独维护相关逻辑，这也是本文推荐的方式。 案例实现 Form子组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123;Button, Form, Input, Select&#125; from &#x27;antd&#x27;;const FormItem = Form.Item;class Forms extends Component&#123; getItemsValue = ()=&gt;&#123; const val= this.props.form.getFieldsValue(); // 获取from表单的值 return val; &#125; render()&#123; const formItemLayout = &#123; labelCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 8 &#125;, &#125;, wrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16 &#125;, &#125;, &#125;; const &#123; form, initValue1, initValue2, initValueList &#125; = this.props; const &#123; getFieldDecorator &#125; = form; // 校验控件 return( &lt;Form style=&#123;&#123;backgroundColor: &#x27;#fff&#x27;, padding: &#x27;20px&#x27;&#125;&#125;&gt; &lt;FormItem &#123;...formItemLayout&#125; label=&#123;`相关数量`&#125; &gt; &#123;getFieldDecorator(`amount`,&#123; rules: [&#123; message: &#x27;必填字段!&#x27;, required: true &#125;], initialValue: initValue1 ? initValue1 : undefined &#125;)( &lt;Input placeholder=&quot;请输入&quot;/&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem &#123;...formItemLayout&#125; label=&#123;`选择相关名称`&#125; &gt; &#123;getFieldDecorator(`name`,&#123; rules: [&#123; message: &#x27;必填字段!&#x27;, required: false &#125;], initialValue: initValue2 ? initValue2 : undefined &#125;)( &lt;Select placeholder=&quot;请选择&quot; onChange=&#123;this.handleSelectChange&#125; &gt; &#123; initValueList &amp;&amp; initValueList.map((x, i) =&gt; ( &lt;Option value=&#123;x.Id&#125; key=&#123;i&#125;&gt;&#123;x.name&#125;&lt;/Option&gt; )) &#125; &lt;/Select&gt; )&#125; &lt;/FormItem&gt; &lt;/Form&gt; ) &#125;&#125;export default Form.create()(Forms); //创建form实例 Form子组件，接收父组件传过来的初始数据，组件中getItemsValue自定义方法返回表单的值，需要在父组件中调用。 父组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Modal, Button &#125; from &#x27;antd&#x27;;import Forms from &#x27;./Forms&#x27;export default class Modals extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; visible: false, initValue1: 0, initValue2: &#x27;myName&#x27;, initValueList: [&quot;李云龙&quot;, &quot;李荣基&quot;, &quot;李达&quot;] &#125;; &#125; handleClick = () =&gt; &#123; this.setState(&#123; visible: true &#125;) &#125;; handleCreate = () =&gt; &#123; let values = this.formRef.getItemsValue(); // 获取到子组件form的值，做进一步操作 this.setState(&#123; visible: false &#125;) &#125;; render() &#123; return ( &lt;section&gt; &lt;Modal visible=&#123;this.state.visible&#125; title=&quot;编辑&quot; onOk=&#123;this.handleCreate&#125; onCancel=&#123;() =&gt; &#123; this.setState(&#123; visible: false &#125;); &#125;&#125; okText=&quot;保存&quot; cancelText=&quot;取消&quot; &gt; &lt;Forms initValue1=&#123;initValue1&#125; initValue2=&#123;initValue2&#125; initValueList=&#123;initValueList&#125; wrappedComponentRef=&#123;(form) =&gt; this.formRef = form&#125; /&gt; &lt;/Modal&gt; &lt;Button onClick=&#123;()=&gt;&#123; this.handleClick &#125;&#125;&gt;点击弹框&lt;/Button&gt; &lt;/section&gt; ); &#125;&#125; 这里关键的是使用wrappedComponentRef属性拿到这个Form的ref，简单的理解为拿到子组件的form实例，因此，可以在handleCreate函数中通过this.formRef.getItemsValue()调用自子组件的方法获取返回的form值。至此，上面的问题就解决了。 关于wrappedComponentRef的描述详见antd官网描述。","tags":[{"name":"antdesign","slug":"antdesign","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/antdesign/"}]},{"title":"js方法定义不同位置的区别","date":"2019-04-06T13:20:00.000Z","path":"2019/04/06/方法定义位置的区别/","text":"js中，方法定义在构造函数内部，外部以及定义在prototype上的区别。 有时候，我们调用某个对象的某个方法时，会报错：xxx is not function，xxx并不是一个函数，说明这个Object里面不存在这个方法，那么，为什么会没有这个方法，可能是这个Object内部没有定义这个方法,可能是这个函数的原型链上不存在该方法等等，让我想探究一下，方法定义在不同位置，对js函数的区别。 我们先来以下案例： 123456789101112131415161718192021222324function Fn(num)&#123; this.innerAttr = num; this.innerFn = function()&#123; console.log(num) &#125;&#125;;Fn.wrapFn1 = function(num1)&#123; console.log(num1);&#125;;Fn.prototype.wrapFn2 = function(num2)&#123; console.log(num2);&#125;; var fn = new Fn(12);fn.innerFn(); //12fn.wrapFn1(14); // is not functionfn.wrapFn2(16); // 16Fn.innerFn(22); // is not functionFn.wrapFn1(24); // 24Fn.wrapFn2(26); // is not function 我们可以把以上调用方式分为两类，一类是实例化的调用，一类是构造函数调用。 我们可以总结出以下区别： 当方法定义在构造函数内部时，想要调用该方法，只能通过实例化后调用，直接调用会报错xxx is not function。 当方法定义在类（构造函数）时，想要调用该方法，只能通过构造函数调用，其他方式也会报同样错误。 当方法定义在构造函数的prototype上时，只能通过实例化后调用，其他方式也会报同样错误。 当使用new关键字操作new Fn(12);时，来看看js做了哪些操作： 创建空对象； var obj = {}; 完成原型链的构建 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象； obj.proto = Fn.prototype; 改变this的指向 使用新对象调用函数，函数中的this被指向新实例对象： Fn.call(obj); //{}.构造函数(); 执行函数里的代码 将初始化完毕的新对象地址，保存到等号左边的变量中 当我们使用实例化后调用方法时，this指向调用时的实例对象，而这个实例对象继承了构造函数的属性和方法，同时，它的__proto__也指向构造函数的原型，这里解释了1和3中的情况；而2中的情况，通过直接定义在构造函数内部的属性属于私有属性，外部是不能引用的，所以只能通过该构造函数调用，我们可以通过hasOwnProperty()方法判断是否是私有属性。 1、把方法写在原型中比写在构造函数中消耗的内存更小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会再实例中复制一份。而写在类中的方法，实例化的时候会在每一个实例对象中在复制一份，所以消耗的内存更高。因此没有特殊原因，我们一般把属性定义在类中，行为定义在原型中。 2、在构造函数中定义的属性和方法要比原型中定义的属性和方法优先级高，如果定义了同名称的属性和方法，构造函数中的将会覆盖原型中的。","tags":[]},{"title":"import和export模块化功能","date":"2019-04-05T12:20:00.000Z","path":"2019/04/05/import和export模块化功能/","text":"在javascript中一个文件为一个独立的模块，要想在文件外部访问其他文件的内容，需要使用import导入外部模块，使用export导出对应的模块。 1.export命令 下面代码使用export导出变量 123export let name = &quot;Bob&quot;;export let age = 25;export let birthday = &quot;2012-12-05&quot;; 除了上面的写法，我们更推荐下面这种写法 12345let name = &quot;Bob&quot;;let age = 25;let birthday = &quot;2012-12-05&quot;;export &#123; name, age, birthday &#125;; 以上两种写法是等价的，但是我们更推荐第二种，因为第二种写法能更加直观的看出需要输出哪些变量。 export命令除了输出变量之外，还可以输出函数、class类等 123export function sum(x, y)&#123; return x + y;&#125; 除了输出函数本来的名称之外，我们还可以使用as关键字给输出的函数重命名 1234function f1()&#123; //... &#125;function f2()&#123; //... &#125;export &#123; f1 as func1, f2 as func2 &#125; 注意的是export命令规定的是对外输出的接口，必须与模块内部的变量建立一一对应的关系，我们把一个对象想象为一个映射关系，就不难理解了。下面这类写法，就是错误的。 12345678// 报错export 666;// 报错let num = 7;export num;// 报错function f1()&#123; //... &#125; export f1; 2.import命令 使用export定义了对外接口之后，可以使用import加载这个模块 123import &#123; sum &#125; from &#x27;./test.js&#x27;;sum(1, 2); // 3 我们也可以使用as关键字对导入的模块进行重命名 123import &#123; sum as myFun &#125; from &#x27;./test.js&#x27;;myFun(1, 2); // 3 import命令导入的内容是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 123import &#123; a &#125; from &#x27;./test.js&#x27;;a = &#123;&#125;; //报错 但是如果导入的内容是一个对象，我们进行对象属性的改写，这是允许的操作。 123import &#123; obj &#125; from &#x27;./test.js&#x27;;obj.attr1 = 6; //合法 虽然对导入对象的属性改写是合法的，在其他模块中也能读取到这里的改写，但这类操作导致错误难以追踪，为了程序的可维护性，我们建议导入的内容执行只读操作，不轻易做更改。 3.模块的整体加载 除了上面案例中的一一对应加载，我们还可以使用*符号指定一个对象整体加载模块。 1234567// all.jsexport function sum(x, y)&#123; return x + y;&#125;export function multiply(x, y)&#123; return x * y;&#125; 下面整体加载该模块 1234import * as all from &#x27;./all.js&#x27;;all.sum(1, 2); // 3all.multiply(1, 2); // 2 4.export default 到这为止，上面的案例导入时都需要知道内容的名称，使用export default命令，默认导出default名称的内容，我们可以给导入的模块取任意名称。 12345678910111213141516171819202122export default function fn()&#123; // ...&#125;import myfn from &#x27;./test.js&#x27;;``上面代码中，函数名fn在外部是无效的，加载该模块的时候，视匿名函数加载，我们对比一下正常输出和默认输出```javascript// 正常输出export function fn()&#123; //...&#125;import &#123; fn &#125; from &#x27;./test.js&#x27;;// 默认输出export default function fn()&#123; // ...&#125;import myfn from &#x27;./test.js&#x27;; 上面两组代码，使用export default输出时，import导入不需要大括号，而使用export时则需要；export default默认输出时只允许一个输出，而使用export正常输出可以有多个。","tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/ES6/"}]},{"title":"HMTL5 websocket","date":"2019-03-31T12:20:00.000Z","path":"2019/03/31/websocket/","text":"websocket是HTML5提供的一种在单个TCP连接上进行全双工通讯的协议，了解HTTP协议的都应该知道，http协议是无状态的，也就是说服务器不会记录客户端的请求，也不会主动向客户端通信，所以有些网站如果 需要保持和服务端通信，需要采用js轮询的方式不断地向服务的发送请求，这样就浪费了更多的http请求和带宽资源，在websocket API中，浏览器只需要和服务器做一次握手操作，然后，服务器和浏览器就形成了一条 快速通道，两者之间就可以实时自由通信了。 1.连接通信 浏览器通过JavaScript向服务器发出建立WebSocket连接的请求，连接建立以后，客户端和服务器端就可以通过TCP连接直接交换数据。当你获取Web Socket连接后，你可以通过send()方法来向服务器发送数据，并通过onmessage事件来接收服务器返回的数据。 1var Socket = new WebSocket(url, [protocol] ); url: 连接服务的url protocol: 可选，可接收的子协议 2.WebSocket属性 属性 描述 Socket.readyState 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount 只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 3.WebSocket事件 事件 处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 通信关闭时触发 4.WebSocket方法 方法 描述 Socket.send() 使用连接发送数据 Socket.close 连接关闭 WebSocket 实例 WebSocket 协议本质上是一个基于 TCP 的协议。 5.Websocket实例 为了建立一个 WebSocket连接，客户端浏览器首先要向服务器发起一个 HTTP请求，这个请求和通常的 HTTP请求不同，包含了一些附加头信息，其中附加头信息&quot;Upgrade: WebSocket&quot;表明这是一个申请协议升级的 HTTP请求， 服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 6.简单的JavaScript案例 123456789101112131415161718192021222324function websocket()&#123; if(&#x27;Websocket&#x27; in window)&#123; // 打开一个 web socket let ws = new WebSocket(&quot;ws://localhost:1235/server&quot;); ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; let received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125;else&#123; alert(&#x27;Please upgrade your browser！&#x27;) &#125;&#125;","tags":[{"name":"websocket","slug":"websocket","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/websocket/"}]},{"title":"微信授权登陆","date":"2019-02-24T05:23:00.000Z","path":"2019/02/24/微信授权登录/","text":"网站应用接入微信登录可以使用户更加快捷的参与到应用的深层次交互中来，大大降低了用户登陆的繁琐性。网站应用微信登录是基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。所谓OAuth2.0模式简单来说就是：授权码模式，即通过授权方的code换token，登录方通过token获取用户信息，来实现登录的方式。 在前端界面方面，我们需要生成二维码页面，移动端微信跳转确认登陆页；服务端方面，需要添加websocket服务实时响应扫码信息。如上面的时序图，PC页面获取相关信息生成二维码，并连接websocket服务实时响应授权状态，微信扫描二维码跳转至确认登陆页面，微信端页面确认登陆后PC页面监听到websocket服务返回确认登陆的标识，PC页面通过标识调用登陆接口获取token及用户信息，整个流程完成。 本篇案例采用vue emementUi开发，只摘取部分核心代码。 1.PC端页面布局 canvas二维码容器和三种二维码状态遮罩。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!--微信扫码登陆部分--&gt;&lt;div&gt; &lt;div&gt; &lt;div class=&quot;imgWrap&quot;&gt; &lt;div class=&quot;failQr&quot; v-if=&quot;isFailQr&quot;&gt; &lt;span&gt;二维码已失效&lt;/span&gt; &lt;el-button size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;getWxLogin&quot;&gt;点击刷新&lt;/el-button&gt; &lt;/div&gt; &lt;div class=&quot;failQr qrConfirm&quot; v-if=&quot;isConfirm&quot;&gt; &lt;span&gt;扫码成功，等待确认&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;failQr qrConfirm&quot; v-if=&quot;onLogin&quot;&gt; &lt;span&gt;登录成功，正在跳转！&lt;/span&gt; &lt;/div&gt; &lt;!--&lt;img id=&quot;QrCode&quot; src=&quot;http://zhongweipeng.cn/timg.jpg&quot;&gt;--&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt; &lt;p class=&quot;scrpText&quot;&gt;打开手机微信，扫一扫登陆&lt;/p&gt;&lt;/div&gt;&lt;!--部分样式--&gt;&lt;style&gt;.imgWrap&#123; padding: 15px; background-color: #fff; width: 207px; height: 207px; margin: 30px auto 0; position: relative;&#125;.imgWrap canvas&#123; display: block; width: 207px !important; height: 207px !important; margin: 0 auto;&#125;.scrpText&#123; font-size: 12px; color: #fff; text-align: center;&#125;.failQr&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.7); display: flex; flex-direction: column; justify-content: center; align-items: center;&#125;.qrConfirm&#123; background-color: rgba(255, 255, 255, 0.8); color: #0880fd; font-weight: bold;&#125;.failQr span&#123; margin-bottom: 6px;&#125;&lt;/style&gt; 2.PC端JS代码 使用qrcode插件来生成canvas二维码，然后利用二维码code来连接websocket服务，监听授权登录状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import QRCode from &#x27;qrcode&#x27;;export default &#123; data() &#123; return &#123; isFailQr: false, /*失效二维码*/ isConfirm: false, /*扫码成功等待*/ onLogin: false, /*登陆成功*/ failQr_time: 300, /*失效时间*/ qrCode: &#x27;&#x27;, /*微信二维码返回的code*/ &#125;; &#125;, mounted() &#123; this.getWxLogin(); this.handleFailQr(); &#125;, methods: &#123; // 获取后台信息并生成二维码 getWxLogin()&#123; let that = this; this.$axios.get(`/api/getQrInfo`) .then(function (res) &#123; if (res.code) &#123; that.qrCode = res.code; that.$nextTick(() =&gt; &#123; let canvas = document.getElementById(&#x27;canvas&#x27;) QRCode.toCanvas(canvas, res.url, function (error) &#123; if (error) console.error(error); that.getQrCode(); // 连接wss console.log(&#x27;QRCode success!&#x27;); &#125;) &#125;) &#125; else &#123; this.$message(&#123; message: res.msg, type: &#x27;error&#x27;, &#125;); &#125; &#125;) .catch(function (error) &#123; console.log(error); &#125;); this.isFailQr = false; this.handleFailQr(); &#125;, getQrCode()&#123; let that = this; let wsuri = `wss://api.net/wss/$&#123;this.qrCode&#125;`; //带上返回的qrcode连接websocket服务 let websock = new WebSocket(wsuri); websock.onmessage = function(e)&#123; that.websocketOnMessage(e); &#125; // websock.onclose = function(e)&#123; // // websocketclose(e); // &#125; // websock.onopen = function () &#123; // // websocketOpen(); // &#125; //连接发生错误的回调方法 websock.onerror = function () &#123; console.log(&quot;WebSocket连接发生错误&quot;); &#125; &#125;, //数据接收 websocketOnMessage(e)&#123; // console.log(JSON.parse(e.data), &#x27;data&#x27;) let data = JSON.parse(e.data); if(data.action === &quot;scan&quot;)&#123; // 扫码成功 clearInterval(this.failQr_timetimer); this.isFailQr = false; this.isConfirm = true; &#125;else if(data.action === &quot;successLogin&quot;)&#123; // 登录成功 this.onLogin = true; console.log(data, &#x27;登陆成功返回的信息&#x27;); // ... // 执行的登陆操作 保存用户信息token等... // ... &#125; &#125;, //二维码失效操作 handleFailQr()&#123; this.failQr_time = 301; this.failQr_timetimer = setInterval(()=&gt;&#123; this.failQr_time--; if(this.failQr_time &lt;= 0)&#123; this.isFailQr = true; clearInterval(this.failQr_timetimer); &#125; &#125;, 1000); &#125;, &#125;&#125;; 3.h5移动端处理 扫码后跳转的移动页面比较简单，所以这里简略描述一下，授权登录页按钮触发授权登录操作，通过请求回调成功数据判断状态显示。 4.微信端确认登陆，PC端登陆成功 这个步骤其实在服务端过程比较复杂，但是对于用户来说感觉不到什么。首先，微信服务端判断登录成功重定向到登录成功的页面，后台服务端接收到微信服务端登录成功返回的code，后台服务端使用code向微信服务端获取token，后台服务端在是使用token向微信服务端获取用户信息，返回给客户端操作，至此，整个操作完成。","tags":[{"name":"微信","slug":"微信","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%BE%AE%E4%BF%A1/"}]},{"title":"Vuex状态管理模式","date":"2019-02-23T10:43:00.000Z","path":"2019/02/23/vuex状态管理模式/","text":"每一个 Vuex应用的核心就是store，而每一个store又是一个Vue的Store对象的实例，所以我们可以在根组件注入store然后通过this.$store访问的store实例。简单的来说，它也是一个普通的js对象。这一点和redux相似。 1.vuex数据模式 vuex的设计思想借鉴了Flux、Redux、和 The Elm Architecture，所以和redux有许多相似之处，在vuex中，更改state只能通过mutation一种途径，vue组件可以dispatch异步的Action，Action通过commit同步的mutation来更改state，我们也可以通过this.$store来获取单一实例，当需要操作多个状态时，通常使用辅助函数mapState、mapMutations、mapActions，详见官文 2.基本配置 123456789101112const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123;&#125;, getters: &#123;&#125;&#125;) state: 初始全局状态值 mutations: 同步处理状态值 actions: 异步数据流处理 getters: 加工处理状态值 3.模块化 12345678910111213141516171819202122232425// app.jsimport Vue from &#x27;vue&#x27;;import router from &#x27;./router&#x27;;new Vue (&#123; router, store, // ...&#125;).$mount (&#x27;#app&#x27;);// store/index.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import module1 from &#x27;./modules/module1&#x27;import module2 from &#x27;./modules/module2&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; module1, module2 &#125;&#125;) 4.State状态 在组件中获取state 由于vuex存储的状态是响应式的，我们获取状态时都应该使用计算属性。 12345678910111213141516171819202122232425262728293031323334353637383940// 没有注入到根组件import store from &#x27;./store&#x27;const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125;// 注入到根组件，例如3小结案例const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125;// 使用mapState辅助函数 两种方式computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count` countAlias: &#x27;count&#x27;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125;&#125;) computed: mapState([ // 映射 this.count 为 store.state.count &#x27;count&#x27;]) 5.Mutation 更改Vuex中state的唯一方式就是提交mutation，它接受state作为第一个参数。 5.1常用的Mutation方式 1234567891011121314const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;)// 调用store.commit(&#x27;increment&#x27;) 5.2提交参数 12345678910111213141516171819202122// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;// 调用store.commit(&#x27;increment&#x27;, 10)// 对象风格传参store.commit(&#123; type: &#x27;increment&#x27;, amount: 10&#125;)// 调用mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; 5.4组件中调用mutation 所有的store实例都可以通过this.$store获取，这里对这种方式不做过多诠释，主要是使用辅助函数。 12345678910111213141516import &#123; mapMutations &#125; from &#x27;vuex&#x27;export default &#123; // ... methods: &#123; ...mapMutations([ &#x27;increment&#x27;, // 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)` // `mapMutations` 也支持载荷： &#x27;incrementBy&#x27; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)` ]), ...mapMutations(&#123; add: &#x27;increment&#x27; // 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)` &#125;) &#125;&#125; 6.Action Action类似于mutation，但不同的是Action提交的是mutation，Action可以包含异步操作，下面案例在actions中使用commit方法调用mutations的方法实现state的更改。 123456789101112131415161718192021const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state, n) &#123; state.count += n &#125;, redce (state, n) &#123; state.count -= n &#125; &#125;, actions: &#123; addAction(context)&#123; context.commit(&#x27;increment&#x27;,10) &#125;, reduceAction(&#123;commit&#125;)&#123; commit(&#x27;reduce&#x27;, 1) &#125; &#125;,&#125;) 组件内使用actions，我们只需要使用vuex提供的辅助函数（mapMutations和mapActions）即可映射对应的actions。 12345678910111213import &#123; mapMutations, mapActions &#125; from &#x27;vuex&#x27;export default&#123; // ... methods:&#123; ...mapMutations([ &#x27;increment&#x27;,&#x27;reduce&#x27; ]), ...mapActions([ &#x27;addAction&#x27;,&#x27;reduceAction&#x27; ]) &#125;,&#125; 7.Getter 有时我们需要把某些state进行筛选过滤等处理，Getter就派上了用场，想当于组件的计算属性，只有当它依赖的值发生改变时才触发重新计算。 7.1通过属性访问 1234567891011121314151617181920212223const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;...&#x27;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;)// store里面使用store.getters.doneTodos// 组件中使用computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 7.2通过方法访问 1234567891011121314151617181920212223const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;...&#x27;, done: false &#125; ] &#125;, getters: &#123; getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125; &#125;&#125;)// store里面使用store.getters.getTodoById(2)// 组件中使用computed: &#123; doneTodosCount () &#123; return this.$store.getters.getTodoById(2) &#125;&#125; 7.3mapGetters辅助函数 12345678910111213141516171819import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &#x27;doneTodosCount&#x27;, &#x27;anotherGetter&#x27;, // ... ]) &#125;&#125;// 如果想给getter另取一个名字，可以使用对象的形式。mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: &#x27;doneTodosCount&#x27;&#125;)","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"vueCli配置多环境构建项目","date":"2019-01-31T14:53:00.000Z","path":"2019/01/31/vue多环境配置/","text":"如今的前端越来越趋近于自动化，比如：在构建项目时，我们需要对不同环境做出调用不同接口的处理。通常情况下，我们会在封装通用http请求方法的模块里面设置一个标识来表示当前处理哪种环境， 再通过判断标识来决定使用哪个接口。 例如： 12345let env = 0;const domain = env == 0 ? &#x27;test/api/xxx&#x27; : &#x27;api/xxx&#x27;;axios.defaults.baseURL = domain;axios.defaults.withCredentials = true;axios.defaults.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=UTF-8&#x27;; 这种方式容易导致失误，万一哪次打包的时候忘记更改状态，更新到正式环境就导致数据流失，不可预测后果。 如果我们在执行npm run build的时候可以自动选择变更环境，能够更好的使我们减少失误，项目因此更加自动化。 查看vue-cli文档可知，通过配置.env文件实现构建环境的变更。 1.新建公共的构建环境处理文件common.js 12345678910111213141516171819202122// common.jsconst env = (() =&gt; &#123; const ENV = &#123; // 请求url domain: &#x27;&#x27;, &#125; switch (process.env.NODE_ENV) &#123; case &#x27;development&#x27;: ENV.domain = `https://test/api/xxx`; ENV.otherApi = `https://test/otherapi/xxx`; break default: ENV.domain = process.env.API_ENV === &#x27;dev&#x27; ? `https://test/api/xxx` : `https://api/xxx`; ENV.otherApi = process.env.API_ENV === &#x27;dev&#x27; ? `https://test/otherapi/xxx` : `https://otherapi/xxx`; break &#125; return ENV&#125;)()export default env 2.通用的http模块引入common.js 1234import common from &#x27;./common&#x27;const domain = common.domain;const otherApi = common.otherApi; 3.新建.env.development文件 .env.development文件可在package.json的scripts启动开发环境构建命令里面配置参数供vue-cli读取。 12NODE_ENV=developmentAPI_ENV=dev 4.新建.env.product文件 .env.product文件可在package.json的scripts启动生产环境构建命令里面配置参数供vue-cli读取。 12NODE_ENV=productionAPI_ENV=prod 5.package.json配置启动 123456789&#123; // ... &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;vue-cli-service serve --open&quot;, &quot;build&quot;: &quot;vue-cli-service build --mode product&quot;, &quot;build:dev&quot;: &quot;vue-cli-service build --mode development&quot;, &#125; // ...&#125; 通过参数--mode xxx读取对应的配置文件，变更相应的环境变量来构建整个项目。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"vue自定义组件","date":"2019-01-30T12:53:00.000Z","path":"2019/01/30/vue自定义组件/","text":"随着前端开发的日益组件化，前端应用的开发也逐渐成为组件化开发。文本以Element UI为框架，实现一个简单可复用的范围输入组件。 1.组件引入 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;rangeInput style=&quot;width: 300px;&quot; size=&quot;small&quot; start-placeholder=&quot;开始范围&quot; end-placeholder=&quot;止支付总额&quot; separator=&quot;至&quot; type=&quot;number&quot; @handleRangeValue=&quot;getRangeValue&quot; &gt; &lt;/rangeInput&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from &#x27;vue&#x27;import rangeInput from &#x27;./range&#x27;export default &#123; data() &#123; return &#123; &#125; &#125;, mounted()&#123; &#125;, methods: &#123; getRangeValue(startVal, endVal)&#123; console.log(startVal, endVal, &#x27;range value&#x27;) &#125;, &#125;, components: &#123; rangeInput &#125;&#125;&lt;/script&gt; 2.编写组件range.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div class=&quot;ri-wrap&quot;&gt; &lt;el-col :span=&quot;11&quot;&gt; &lt;el-input class=&quot;ri-input&quot; :size=&quot;size&quot; :placeholder=&quot;startPlaceholder&quot; @change=&quot;changeValueRange&quot; v-model=&quot;startRange&quot; :type=&quot;type&quot; &gt; &lt;/el-input&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;2&quot;&gt; &lt;span style=&quot;line-height: 36px;font-size: 14px;padding: 0 5px&quot;&gt;&#123;&#123;separator&#125;&#125;&lt;/span&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;11&quot;&gt; &lt;el-input class=&quot;ri-input&quot; :size=&quot;size&quot; :placeholder=&quot;endPlaceholder&quot; @change=&quot;changeValueRange&quot; v-model=&quot;endRange&quot; :type=&quot;type&quot; &gt; &lt;/el-input&gt; &lt;/el-col&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; startRange: &#x27;&#x27;, endRange: &#x27;&#x27;, type: &#x27;text&#x27;, &#125; &#125;, props: &#123; size: String, startPlaceholder: String, endPlaceholder: String, separator: String, &#125;, mounted() &#123; &#125;, methods: &#123; changeValueRange()&#123; let startRange = this.startRange || 0; let endRange = this.endRange || 0; this.$emit(&#x27;handleRangeValue&#x27;, startRange, endRange) &#125;, &#125; &#125;&lt;/script&gt;&lt;style&gt; .ri-wrap&#123; border-radius: 4px; border: 1px solid #dcdfe6; height: 36px; line-height: 36px; box-sizing: border-box; &#125; .ri-input .el-input__inner&#123; border: none !important; font-size: 14px; &#125;&lt;/style&gt; 组件内通过@change监听input输入的值，通过$emit向父级派发事件handleRangeValue，传递对应的参数，然后在父级监听派发的事件，获取到对应的值。本案例只是一个简单的子向父通信的案例，其实还可以继续扩展，比如：范围校验，样式自定义等等。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"Redux核心概念","date":"2019-01-01T13:43:00.000Z","path":"2019/01/01/redux概念/","text":"一般来说，描述一个state通常通过一个普通的js对象来描述。比如说角色列表模块的state: 123456789101112131415161718&#123; accounts:[ &#123; id: 1, name: &#x27;John&#x27;, enable: true &#125;,&#123; id: 2, name: &#x27;Bob&#x27;, enable: true &#125;,&#123; id: 3, name: &#x27;Lina&#x27;, enable: false &#125; ], subscription: &#x27;管理员&#x27;&#125; 这样写就处于写死的状态，没有任何修改器方法（setter）可以去修改它，对于界面简单，逻辑不复杂的应用没有什么问题，但是对于复杂且庞大的应用，就会出现状态逻辑混乱，难以维护的问题。那么，我们要想更新state，就要发起一个action，这里的Action也是一个普通的js对象，只是用来描述发生了什么，注意这里仅仅是描述。比如： 123&#123;type: &quot;MODIFY_SUBSCRIPT&quot;, text: &quot;用户&quot;&#125;&#123;type: &quot;MODIFY_ACCOUNT&quot;, data: &#123;id: 2, name: &#x27;Toy&#x27;&#125;&#125;&#123;type: &quot;ADD_ACCOUNT&quot;, data: &#123;name: &#x27;Lisa&#x27;, enable: true&#125;&#125; 最后，为了把state和action联系起来，需要开发一些函数，函数接受state和action，这些函数就是reducer，并返回新的state。 12345678910111213141516171819202122232425function changeText(state=&#x27;管理员&#x27;, action)&#123; if(action.type = &quot;MODIFY_SUBSCRIPT&quot;)&#123; state.subscription = action.text return state &#125;else&#123; return state &#125;&#125;function accounts(state=[], action)&#123; switch(action.type)&#123; case &#x27;ADD_ACCOUNT&#x27;: return state.contact([id: 4, name: action.data.name, enable: action.data.enable]) case &#x27;MODIFY_ACCOUNT&#x27;: return state.map((v, i)=&gt;&#123; if(v.id === action.data.id)&#123; v.name = action.data.name v.enable = action.data.enable || true &#125; &#125;) default: return state &#125;&#125; 再使用一个全局reducer来管理调用这些reducer。 123456function globalReducer(state = &#123;&#125;, action)&#123; return&#123; changeText: changeText(state.subscription, action), accounts: accounts(state.accounts, action) &#125;&#125; 以上就是Redux的核心概念，可以看出，Redux没有使用那些晦涩难懂的东西，90%都是纯javascript代码。","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"dva.js中Model小结","date":"2018-12-29T14:36:00.000Z","path":"2018/12/29/dva中的model/","text":"dva.js是一套数据流的解决方案，其结合了redux的redux-saga异步流的处理方式，dva通过model的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的subscriptions。 1.model的基本配置 123456789101112131415export default&#123; namespace: &#x27;myModel&#x27;, state: &#123; &#125;, subscriptions: &#123; &#125;, effects: &#123; &#125;, reducers: &#123; &#125;&#125; namespace: model里面全局的命名空间 state: 初始全局状态值 subscriptions: 数据订阅源 effects: 异步数据流处理 reducers: 同步更新state 2.subscriptions数据订阅 subscriptions可以监听从源头获取数据，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等，这里演示监听浏览器url和键盘数据案例。 12345678910111213141516171819202122232425262728293031/**/ 1.键盘事件subscriptions: &#123; keyEvent(&#123;dispatch&#125;) &#123; key(&#x27;enter&#x27;, () =&gt; &#123; dispatch(&#123;type:&#x27;add&#x27;&#125;) &#125;); &#125;,&#125;/**/ 2.监听普通url（不带参数）subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; if(pathname === &quot;/&quot;)&#123; dispatch(&#123;type: &#x27;add&#x27;&#125;) &#125; &#125; &#125;,&#125;/**/ 3.监听带参数的url（带参数）//匹配带参数的url需要依赖一个npm包 path-to-regexpimport pathToRegexp from &#x27;path-to-regexp&#x27;subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; const reviewMatch = pathToRegexp(&#x27;/user/:id&#x27;).exec(pathname) if (reviewMatch &amp;&amp; reviewMatch[0].includes(&#x27;/user&#x27;) &amp;&amp; reviewMatch[1]) &#123; const id = reviewMatch[1] dispath(&#123;type: &#x27;add&#x27;, payload: &#123; data: id &#125;&#125;) &#125; &#125; &#125;,&#125; 2.reducers同步更新state 这里演示同步更改state数据，和组合state数据（用于下拉加载），假设model初始化了一个state为dateInfo，此时涉及到三种情况：router页面上同步更改state，subscriptions里面更改state和effects里面更改state。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748reducers: &#123; combineData(state, action)&#123; const &#123;payload&#125; = action const &#123;dateInfo&#125; = state if (!payload || !Array.isArray(payload)) return &#123;...state&#125; return &#123; ...state, dateInfo: [...dateInfo, ...payload] &#125; &#125;, change(state, action) &#123; const &#123;payload&#125; = action if (!payload.name) return &#123;...state&#125; return &#123; ...state, [payload.name]: payload.value &#125; &#125;,&#125;/**/ 1.router页面上更改state，需要调用this.props.dispatch()方法//需要在action前加入对应的命名空间this.props.dispatch(&#123; type: &#x27;myModel/change&#x27;, payload: &#123; name: &#x27;count&#x27;, value: 0 &#125;&#125;)/**/ 2.subscriptions里面更改state//直接subscriptions里面的dispatch方法，详细看第2小节dispatch(&#123; type: &#x27;change&#x27;, payload: &#123; name: &#x27;count&#x27;, value: 0 &#125;&#125;)/**/ 3.effects里面更改state//effects里面使用Generator函数实现异步流处理，利用参数的put方法，Generator函数使用详见第3小节yield put(&#123; type: &#x27;change&#x27;, payload: &#123; name: &#x27;count&#x27;, value: 0 &#125;&#125;) 3.effects异步处理数据流 effects用于处理异步数据，采用Generator函数，yield关键字使生成器函数执行暂停，上一个yield执行完毕后在执行下一个yield，假设model初始化了一个state为dateId，此时涉及到三种情况：router页面调用异步处理，subscriptions调用异步处理和effects内部调用。 假设我们导入对应的request请求 1import &#123;getUserLists&#125; from &#x27;../services/getUserLists&#x27; router页面调用和subscriptions调用建立在effects函数之上 123456789101112131415161718192021222324252627/**/ 1.effects函数和effects内部调用//effects采用Generator函数/** * &#123; payload &#125;为调用该异步处理函数时传入的payload函数 比如：this.props.dispatch(&#123;type: &#x27;myModel/getFetchData&#x27;, payload: &#x27;params&#x27;&#125;) * &#123; call &#125;用于执行异步函数，调用异步请求 * &#123; put &#125;触发一个同步请求，reducer里面的action，类似于dispatch * &#123; select &#125;从全局model中选择state 比如: const &#123;dateInfo&#125; = yield select(state =&gt; state.myModel) 也可以是其他命名空间 **/*getUserLists(&#123; payload &#125;, &#123; call, put, select &#125;)&#123; const &#123; dateId &#125; = yield select(state =&gt; state.myModel) const data = yield call(getUserLists, &#x27;get&#x27;, &#123; id: dateId || 0, &#125;) if (!data) return yield put(&#123;type: &#x27;change&#x27;, payload: &#123;name: &#x27;dataInfo&#x27;, value: data&#125;&#125;)&#125;/**/ 2.router页面调用异步处理//使用this.props.dispatch，加上命名空间this.props.dispatch(&#123;type: &#x27;myModel/getUserLists&#x27;, payload: &#x27;params&#x27;&#125;)/**/ 3.subscriptions调用异步处理//使用dispatchdispatch(&#123; type: &#x27;getUserLists&#x27;, payload: &#x27;params&#x27; &#125;) 使用dva.js小结附加 1.避免数组取值报错，对数据进行判断 1234// 假设有数组 arr，需要对其进行遍历Array.isArray(arr) &amp;&amp; arr.length &amp;&amp; arr.map(x =&gt; &#123; // do someting&#125;) 2.JSX语法嵌套 12345678910111213141516// 假设需要在react元素里面嵌套js，js里面返回react元素，react元素里面再使用js//...以上代码省略render()&#123; return( &lt;div&gt; &lt;ul&gt; &#123; Array.isArray(arr) &amp;&amp; arr.length &amp;&amp; arr.map((v, i) =&gt; &#123; return (&lt;li key=&#123;i&#125; style=&#123;&#123;fontSize: &#x27;20px&#x27;, color: `$&#123; v=== &#x27;特定值&#x27; ? &#x27;red&#x27; : &#x27;black&#x27; &#125;`&#125;&#125;&gt;值为&#123;v&#125;&lt;/li&gt;) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; )&#125;//...以下代码省略 3.使用esLint校验的项目应使用===，不然会报warnings 4.sass预处理，封装通用的sass 按照750的设计稿标准 123456$baseFontSize: 7.5;$basisColor: #FFC107;@function pxToVw($px) &#123; @return $px / $baseFontSize * 1vw;&#125; 5.全局定时器的使用 需要在组件挂载完毕的生命周期函数里面调用定时器，需要在组件将要卸载的生命周期函数清除定时器。","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"Router访问权限控制","date":"2018-12-28T14:06:00.000Z","path":"2018/12/28/router权限控制/","text":"在做dva.js项目时，涉及到登陆权限控制，在dva.js中提供了react-router的路由方法来控制路由，由于内置的是第四代react-router，我们还需要使用react-router-dom来更好地适应浏览器运行环境。 一般涉及到用户权限控制的应用都会在用户登陆后生成一个唯一标识，常见的就是token，我们可以在用户登陆成功后在浏览器本地存储或者cookie里面存储该标识，路由匹配时检测该标识后再进行正确匹配，退出则清除相应的数据。 核心代码，私有路由控制，作为一个公共组件。 12345678910111213141516171819202122232425262728293031323334import React from &#x27;react&#x27;;import &#123; Route, Redirect, withRouter &#125; from &#x27;react-router-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;;class PrivateRoute extends React.Component&#123; componentWillMount()&#123; let isAuthenticated = localStorage.getItem(&#x27;token&#x27;) ? true : false; this.setState(&#123; isAuthenticated &#125;) if(!isAuthenticated)&#123; const &#123; history &#125; = this.props; setTimeout(() =&gt; &#123; history.replace(&#x27;/Login&#x27;) &#125;, 1000) &#125; &#125; render()&#123; let &#123; component: Component, path=&quot;/&quot;, exact=false, strict=false &#125; = this.props; return this.state.isAuthenticated ? ( &lt;Route path=&#123;path&#125; exact=&#123;exact&#125; strict=&#123;strict&#125; render=&#123;(props) =&gt; ( &lt;Component &#123;...props&#125; /&gt; )&#125; /&gt; ) : (&quot;请重新登录&quot;) &#125;&#125;PrivateRoute.PropTypes = &#123; path: PropTypes.string.isAuthenticated, exact: PropTypes.bool, strict: PropTypes.bool, component: PropTypes.func.isRequired&#125;export default withRouter(PrivateRoute); 私有路由使用 123456789101112131415161718192021import React from &#x27;react&#x27;;import &#123; Router, Route, Switch &#125; from &#x27;dva/router&#x27;;import App from &#x27;./routes/App&#x27;;import Login from &#x27;./routes/Login&#x27;;import Page from &#x27;./routes/Page&#x27;;import PrivateRoute from &#x27;./components/PrivateRoute&#x27;;function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route path=&quot;/Login&quot; component=&#123;Login&#125; /&gt; &lt;PrivateRoute exact path=&quot;/&quot; component=&#123;App&#125; /&gt; &lt;PrivateRoute path=&quot;/page&quot; component=&#123;Page&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 登陆控制，这里只贴模拟登陆表单的简单代码，逻辑根据需求自行实现。 123456789handleSubmit = () =&gt; &#123; let username = this.usernameInput.state.value let password = this.passwordInput.state.value if(username &amp;&amp; password)&#123; localStorage.setItem(&#x27;token&#x27;, username + password) alert(&#x27;登录成功&#x27;) setTimeout(()=&gt;this.props.history.push(&#x27;/&#x27;), 1500) &#125;&#125; 退出登录，清除相关标识。 12345handleLoginOut = () =&gt; &#123; alert(&#x27;操作成功&#x27;) localStorage.clear() setTimeout(()=&gt;this.props.history.push(&#x27;./Login&#x27;) ,1500)&#125;","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"轻量级数据流方案dva上手","date":"2018-12-09T04:06:00.000Z","path":"2018/12/09/DvaJs上手/","text":"dva是一个轻量级的数据流解决方案，基于redux和redux-saga，还内置react-router和fetch。 dav简化了项目的数据流的构建方式，项目构建流程分为：快速构建项目-&gt;编写路由文件-&gt;注册路由-&gt;编写UI组件文件-&gt;定义Model-&gt;载入Model-&gt;模型和组件connect起来。 一、项目构建 1.快速构建项目 使用工具快速构建项目模板。 1234567$ npm install dva-cli -g$ dva new dva-quickstart$ cd dva-quickstart$ npm start 项目即在本地8000端口启动。 2.编写路由文件 先安装ant和按需加载antd的扩展babel-plugin-import $ npm install antd babel-plugin-import --save 新建路由组件routes/Products.js 1234567import React from &#x27;react&#x27;;const Products = (props) =&gt; ( &lt;h2&gt;List of products&lt;/h2&gt;);exprot default Products; 3.注册路由 编辑router.js 123import Products from &#x27;./routes/Products&#x27;;&lt;Route path=&quot;/Products&quot; exact component=&#123;Products&#125; /&gt; 4.编写UI组件文件 新建UI组件components/ProductList.js 1234567891011121314151617181920212223242526272829303132import React from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;import &#123; Table, Popconfirm, Button &#125; from &#x27;antd&#x27;;const ProductList = (&#123; onDelete, products &#125;) =&gt; &#123; const columns = [&#123; title: &#x27;名称&#x27;, dataIndex: &#x27;name&#x27;, &#125;, &#123; title: &#x27;操作&#x27;, render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title=&quot;Delete?&quot; onConfirm=&#123;() =&gt; onDelete(record.id)&#125;&gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;, &#125;]; return ( &lt;Table dataSource=&#123;products&#125; columns=&#123;columns&#125; /&gt; );&#125;;ProductList.propTypes = &#123; onDelete: PropTypes.func.isRequired, products: PropTypes.array.isRequired,&#125;;export default ProductList; 5.定义Model模型 dva通过model的概念把一个领域的模型管理起来，其中包括同步更新state的reducers，处理异步逻辑的effects，数据源订阅的subscriptions。 新建models/products.js 123456789export default &#123; namespace: &#x27;products&#x27;, state: [], reducers: &#123; &#x27;delete&#x27;(state, &#123; payload: id &#125;) &#123; return state.filter(item =&gt; item.id !== id); &#125;, &#125;,&#125;; namespace 表示在全局 state上的 key state 是初始值，在这里是空数组 reducers 等同于redux里的 reducer，接收 action，同步更新 state 6.载入模块 在index.js里面载入模块 app.model(require('./models/products').default); 7.model连接component dva提供connect方法。编辑routes/Products.js 1234567891011121314151617181920212223import React from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;dva&#x27;;import ProductList from &#x27;../components/ProductList&#x27;;const Products = (&#123; dispatch, products &#125;) =&gt; &#123; function handleDelete(id) &#123; dispatch(&#123; type: &#x27;products/delete&#x27;, payload: id, &#125;); &#125; return ( &lt;div&gt; &lt;h2&gt;List of Products&lt;/h2&gt; &lt;ProductList onDelete=&#123;handleDelete&#125; products=&#123;products&#125; /&gt; &lt;/div&gt; );&#125;;// export default Products;export default connect((&#123; products &#125;) =&gt; (&#123; products,&#125;))(Products); 最后在index.js里面初始化一些数据，一个简单的dva应用完成。 12345678const app = dva(&#123; initialState: &#123; products: [ &#123; name: &#x27;dva&#x27;, id: 1 &#125;, &#123; name: &#x27;antd&#x27;, id: 2 &#125;, ], &#125;, &#125;); 8.打包发布应用 npm run build 二、dva数据流 数据改变的发生通常是通过用户的交互行为或者浏览器行为（如路由跳转）触发的，当此类行为会改变数据的时候会通过dispatch发起一个Action，如果是同步行为直接通过Reducers改变State，如果是异步行为会先触发Effects流向Reducers最后改变State。 2.1.State对象 State通常是一个JavaScript对象，表示某个模型全局的状态数据，可以在模型里面配置相关信息： 123456789101112131415export default&#123; namespace: &#x27;modelname&#x27;, state: &#123; //... &#125;, subscriptions: &#123; //... &#125;, effects: &#123; //... &#125;, reducer: &#123; //... &#125;,&#125; 2.2.Action对象 Action是一个普通JavaScript对象，是改变state的一个行为，也是唯一改变state的途径，想要改变state，需要将Action传入dispatch函数中，该函数是在组件connect模型后通过props传入的。 123this.props.dispatch(&#123;type: &#x27;modelname/xxx&#x27;&#125;).then((v=&#123;&#125;) =&gt; &#123; console.log(v)&#125;) 2.3.dispatch方法 dispatch函数连接路由组件和模型，通过传入Action调用model中的逻辑改变state，Action只是描述了一个行为，dispatch是触发这个行为，而reducers则是如何改变这个行为。 12345678910111213141516171819202122232425262728293031323334353637383940414243// componentthis.props.dispatch(&#123;type: &#x27;modelname/getInfo&#x27;&#125;).then((v=&#123;&#125;) =&gt; &#123; console.log(v)&#125;)// modelexport default&#123; namespace: &#x27;modelname&#x27;, state: &#123; getdate: &#123;&#125;, &#125;, subscriptions: &#123; //... &#125;, effects: &#123; *getInfo(&#123;payload&#125;, &#123;call, put, select&#125;) &#123; const data = yield call(getInfo) if (!data) return yield put(&#123; type: &#x27;change&#x27;, payload: &#123; name: &#x27;getdate&#x27;, value: data &#125; &#125;) return data &#125;, &#125;, reducer: &#123; change(state, action) &#123; const &#123;payload&#125; = action if (!payload || !payload.name) return return &#123; ...state, [payload.name]: payload.value &#125; &#125; &#125;,&#125; 2.4.connect方法 connect函数路由使组件和模型联系起来，可以在connect函数里面传入mapStateToProps函数，用于把model中的state和组件的props一一映射，mapStateToProps函数接收state作为参数，返回一个对象。 12345678910111213class MyComponent extends component&#123; // ...&#125;const mapStateToProps = state =&gt; &#123; return &#123; data1: state.modelname.data1, data2: state.modelname.data2, // ... &#125;&#125;export default connect(mapStateToProps)(MyComponent); 2.5.Reducers reducers可以同步直接更改state，该设计来源于高阶函数reduce，接收两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。 示例详见2.3小结，通过put方法调用reducers的change函数改变state。 2.6.Effects effects可以调用异步操作，获取的异步数据流向reducers然后改变state，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。示例详见2.3小结，函数*getInfo就是一个generator函数的形式， payload是dispatch调用action时传入的参数对象，第二个参数为方法的集合，分别是call、put、select。 call以异步的方式调用异步函数，第二个参数对象可选 const data = yield call(asyncFn, ...args) put用于触发action yield put(&#123; type: 'change', payload: &#123;name: 'getdate', value: data&#125;&#125;) select用于从state中获取数据 const list = yield select(state =&gt; state.list) 2.7.subscriptions subscriptions可以监听数据源，可以简单理解为一个监听器，可以监听路由变化，鼠标，键盘变化，服务器连接变化，状态变化等，这样在其中就可以根据不同的变化做出相应的处理。例如监听路由和click事件： 123456789101112subscriptions: &#123; onClick (&#123;dispatch&#125;) &#123; document.addEventListener(&#x27;click&#x27;,() =&gt; &#123; dispatch (type:&quot;handleClick&quot;) &#125;) &#125;, setupHistory(&#123;dispatch,history&#125;)&#123; history.listen((location) =&gt; &#123; console.log(location) &#125;) &#125;,&#125;","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"ES6实战编程风格","date":"2018-11-17T03:36:00.000Z","path":"2018/11/17/es6编程风格/","text":"与ES5编程方式相比，用ES6方式编程使代码更加高效、易读和易于维护。本章参考ECMAScript6入门教程。 1.let取代var ES6新增两个变量声明方式let和const，其中，let可以完全取代var，且不用担心副作用。 123456789101112if(true)&#123; let num = 2;&#125;for(let i = 0; i &lt; 3; i++)&#123; console.log(i)&#125;if(true)&#123; console.log(num2); let num2 = 5; //Uncaught ReferenceError: num2 is not defined&#125; 上述代码的优势体现在两个方面，一、前两个代码块如果使用var替代，由于var存在变量提升的作用，想当于声明了两个全局变量，这并非初衷；二、第三段代码使用var代替，代码并不会报错，而是输出undefined，这违反了变量先声明后使用的原则。 2.const常量和线程安全 在let和const之中，应该优先使用const，尤其是在全局范围内，应该设置常量，不应该设置变量。 12345678910// 旧方式var a = 1, b = 2, c = 3;// 一般const a = 1;const b = 2;const c = 3;// 最好const [a, b, c] = [1, 2, 3]; 使用const有三个好处：一、const提醒阅读代码的人，该声明的量是常量，不可更改；二、使用const声明的量JavaScript解析会内部优化；三、有利于JavaScript后续多线程实现的安全。 3.模板字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 12const str1 = &#x27;abcde&#x27;;const str2 = `abc + $&#123;val&#125;` 4.结构赋值 使用数组成员对变量进行赋值时，优先使用结构赋值。 1234const arr = [5, 56, 68, 2];const [num1 , num2] = arr;console.log(num1); // 5console.log(num2); // 56 函数的参数如果是对象的成员，优先使用结构赋值。 12345let obj = &#123;id: 1, name: &#x27;bob&#x27;, age: 32&#125;;function printInfo(&#123;name, age&#125;)&#123; console.log(name + age); // bob32&#125;printInfo(obj); 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。 1234function processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 5.对象 对象定义可以使用简洁表达式，属性名可使用属性表达式。 123456789101112let name = &#x27;bobo&#x27;;let color = &#x27;red&#x27;;const obj = &#123; name, color &#125;; // &#123;name: &#x27;bobo&#x27;, color: &#x27;red&#x27;&#125;let lastWord = &#x27;last word&#x27;;const a = &#123; &#x27;first word&#x27;: &#x27;hello&#x27;, [lastWord]: &#x27;world&#x27;&#125;;a[&#x27;first word&#x27;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#x27;last word&#x27;] // &quot;world&quot; 单行定义的对象，最后一个成员不以逗号结尾；多行定义的对象，最后一行用逗号结尾。 123456const obj1 = &#123;id: 1, attr: &#x27;val&#x27;&#125;;const obj2 = &#123; id: 2, name: &#x27;lina&#x27;, classroom: 324,&#125;; 对象的定义尽量静态化，如果非要修改或者添加属性，使用Object.assign()。 123456const obj = &#123; name: &#x27;bob&#x27;, sex: &#x27;man&#x27;&#125;;const obj2 = Object.assign(&#123;id: 1, age: 12&#125;, obj);console.log(obj2.id); // 定义对象的方法时，可以使用简单表达法。 12345678let name = &#x27;bobo&#x27;;const people = &#123; name, age: 65, sayHi(val)&#123; console.log(val); &#125;&#125;; 6.数组 使用扩展运算符...拷贝数组。 123let arr = [1, 3, 4, 9, 45];const copy = [...arr];console.log(copy); // [1, 3, 4, 9, 45] 7.函数 当需要使用立即执行函数、函数表达式、简单的回调函数时可以写成箭头函数的形式。 1234567891011121314(()=&gt;&#123; let variable = 1; //...&#125;)()let fn = () =&gt; &#123; let variable = 1; //...&#125;let btn = document.getElementById(&#x27;btn&#x27;);btn.addEventListener(&#x27;click&#x27;, (e)=&gt;&#123; console.log(e.target);&#125;); 使用默认值语法设置函数参数的默认值。 123function(param1 = 0, param2 = &#123;&#125;)&#123; //...&#125; 8.Map结构 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。 12345678910let arr = [[&#x27;id&#x27;, 34], [&#x27;price&#x27;, 765]];let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key); // id price&#125;for (let value of map.values()) &#123; console.log(value); // 34 765&#125; 9.Class类 用class可以替代ES5中基于构造函数和原型的类的实现，写法简洁便于理解，extends实现类的继承。 1234567891011121314151617181920212223class People&#123; constructor(age, name)&#123; this.age = age; this.name = name; &#125; sayHi()&#123; console.log(`Hello, I am $&#123;this.name&#125;, $&#123;this.age&#125; years old.`); &#125;&#125;class Student extends People&#123; constructor(age, name, role)&#123; super(age, name); this.role = role; &#125; sayRole()&#123; console.log(`I am a $&#123;this.role&#125;.`); &#125;&#125;let xiaoming = new Student(12, &#x27;xiaoming&#x27;, &#x27;Students&#x27;);xiaoming.sayHi(); // Hello, I am xiaoming, 12 years old.xiaoming.sayRole(); // I am a Students. 10.模块 JavaScript提供标准的Module语法，以替代之前的require()。 123456789101112// 导出模块var obj = &#123; attribute: &#x27;value&#x27;, fn: function()&#123; console.log(666); &#125;&#125;;export default obj;// 导入上面的模块import &#123;attribute, fn&#125; from &#x27;module&#x27;;fn(); // 666","tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/ES6/"}]},{"title":"ES6常用的10个特性","date":"2018-11-17T02:01:00.000Z","path":"2018/11/17/ES6常用特性/","text":"1.函数参数默认值 在ES6之前，需要给函数参数设置默认值，通常使用的是短路运算符；使用ES6可以对参数直接赋值。 123function fn(num=10, name=&#x27;user&#x27;)&#123; //...&#125; 2.模板字符串 123var name = &#x27;Bob&#x27;;var speak = `My name is $&#123;name&#125;`;// My name is Bob 3.多行字符串 在ES6之前，多行字符串需要用+号和换行符进行拼接；ES6可以直接把字符放到反引号里面即可。 12345var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same.` 4.结构赋值 在ES6之前，获取对象里面的值需要通过索引或者键值一个一个获取；ES6中的结构赋值可以更加高效的获取。 12345678var obj=&#123; people:&#123; name:&#x27;lili&#x27;,age:18 &#125;&#125;; var &#123;name, age&#125; = obj.people;console.log(name);// lili 5.对象属性简写 在ES6之前，对象必须包含属性和值；ES6中可以直接写变量。 12345var name = &#x27;Bob&#x27;;var speak = function()&#123; //...&#125;;var obj = &#123;name, speak&#125;; 6.箭头函数 在ES6之前，普通函数的this指向调用时所在的对象。 123456function fn()&#123; console.log(this.id);&#125;var id = 1;fn(); // 1fn.call(&#123;id: 6&#125;); // 6 使用ES6的箭头函数，this指向定义时所在的对象，而不是调用时所在的对象。 123456var fn = () =&gt; &#123; console.log(this.id);&#125;;var id = 1;fn(); // 1fn.call(&#123;id: 6&#125;); // 1 7.Promise 不使用ES6的话，需要嵌套多个setTimeout。 123456setTimeout(function()&#123; console.log(&#x27;hello&#x27;); setTimeout(function()&#123; console.log(&#x27;Promise&#x27;); &#125;,1000)&#125;,1000) ES6使用两个then是异步编程串行化。 123456789var wait1s = new Promise(function(resolve, rejecct)&#123; setTimeout(resolve, 1000);&#125;)wait1s.then(function()&#123; console.log(&#x27;hello&#x27;); return wait1s;&#125;).then(function()&#123; console.log(&#x27;Promise&#x27;);&#125;) 8.let和const声明变量 ES6引入新的关键字声明变量和常量let和const，与var的区别如下： var是最近的函数作用域，let是最近的块级作用域，这个要比函数作用域小。 12345678(function()&#123; &#123; var num1 = 666; let num2 = 999; &#125; console.log(num1); // 666 console.log(num2); // Uncaught ReferenceError: num2 is not defined&#125;)() var定义后可以修改，初始化未赋值输出undefined；let定义后修改报错：Uncaught SyntaxError: Identifier ‘xxx’ has already been declared，初始化未赋值输出undefined。 如果在函数的for语句里面使用var定义，var在整个函数内有效；如果使用let定义，let在for语句里面有效，之外无效。 123456789101112(function()&#123; var len = 5; for(var i = 0; i &lt; len; i++ )&#123; console.log(i); // 0,1,2,3,4 &#125; console.log(i); // 5 for(let n = 0; n &lt; len; n++)&#123; console.log(n); // 0,1,2,3,4 &#125; console.log(n); // Uncaught ReferenceError: n is not defined&#125;)() 9.class类 在ES6之前使用构造函数方式。 123456789function People(name, age)&#123; this.name = name; this.age = age; this.speaking = function()&#123; return &#x27;My name is&#x27; + this.name; &#125;;&#125;var boy = new People(&#x27;Bob&#x27;, 18);console.log(boy.speaking()); // &#x27;My name is Bob&#x27; ES6使用class定义类，更加规范。 1234567891011class People&#123; constructor(name, age)&#123; this.name = name; this.age = age; &#125; speaking()&#123; return &#x27;My name is&#x27; + this.name; &#125;&#125;var girl = new People(&#x27;Lina&#x27;, 19);console.log(girl.speaking()); // &#x27;My name is Lina&#x27; 10.模块化 在ES6之前，模块化一般采用Common.js和AMD规范，使用module.exports=&#123;&#125;导出相关的模块，使用var module = require('module.js');引入模块。ES6使用export和import关键字导出和导入模块。 123456789101112// 导出模块var obj = &#123; attribute: &#x27;value&#x27;, fn: function()&#123; console.log(666); &#125;&#125;;export default obj;// 导入上面的模块import &#123;attribute, fn&#125; from &#x27;module&#x27;;fn(); // 666 11.includes()、values()、entries()方法 includes()检测数组是否存在某个元素 12var arr = [1,2,8,6,4]; arr.includes(4); // true ES6新增了与keys()配套的方法values()用于遍历对象的值 1234var obj = &#123;name: &#x27;li&#x27;, age: 23, country: &#x27;USA&#x27;&#125;;Object.values(obj).forEach(function(v)&#123; console.log(v); // li, 23, USA &#125;) entries()用于遍历对象的键和值 1234var obj = &#123;name: &#x27;li&#x27;, age: 23, country: &#x27;USA&#x27;&#125;;Object.entries(obj).forEach(function([k,v])&#123; console.log(k + &quot;|&quot; + v); // name|li, age|23, country|USA&#125;) 12.Async/Await 用Promise实现异步操作需要不断地链式回调，有时候一个异步的操作需要等到另一个异步操作完后才开始执行，这时候就陷入了层层的嵌套中： 1234567891011121314151617181920212223242526// 用nodejs读取两个文件，先读取第一个文件处理后在读取第二个文件。const fs = require(&#x27;fs&#x27;);const readFn = function(fileName)&#123; return new Promise(function(resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if(error) return reject(error); resolve(data); &#125;) &#125;)&#125;;// 假定文件内容为文件名readFn(&#x27;file1.txt&#x27;) // 绝对路径.then(function(data1)&#123; console.log(data1 + &#x27;666&#x27;); // file1.txt666 return data1 + &#x27;666&#x27;;&#125;).then(function(data2)&#123; return readFn(&#x27;file2.txt&#x27;).then(function(data)&#123; console.log(data2 + data); // file1.txt666file2.txt return data2 + data; &#125;)&#125;).then(function(data3)&#123; console.log(data3 + &#x27;999&#x27;); // file1.txt666file2.txt999&#125;).catch(function(err)&#123; console.log(&#x27;error&#x27;);&#125;) async/await是基于Promise实现的，它不能用于普通的回调函数，它使得异步代码看起来像同步代码。 1234567891011121314151617181920const fs = require(&#x27;fs&#x27;);const readFn = function(fileName)&#123; return new Promise(function(resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if(error) return reject(error); resolve(data); &#125;) &#125;)&#125;;const asyncReadFile = async function()&#123; const f1 = await readFn(&#x27;file1.txt&#x27;); const f2 = await readFn(&#x27;file2.txt&#x27;); console.log(f1.toString()); // file1.text console.log(f2.toString()); // file2.text console.log(f1.toString() + f2.toString()); // file1.textfile2.txt&#125;;asyncReadFile();","tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/ES6/"}]},{"title":"git项目管理流程","date":"2018-11-14T14:40:00.000Z","path":"2018/11/14/git项目管理流程/","text":"在git项目管理中，由于要保证项目测试上线的准确性，所以需要一条唯一的完整的分支来连接正式环境，通常该分支只需要一个开发者维护管理，此时master承担了此角色；在保证master不被污染的前提下创建开发者dev分支、测试test分支、个人本地开发分支。 1. 首先clone项目到本地进行开发 1$ git clone [url] 2. 开发完成后提交，git初始化 1$ git init 3. 加入项目（注意add后面的空格） 1$ git add . 4. 查看修改状态 1$ git status 5. 下拉分支，和本地进行合并，运行项目，解决冲突 1$ git pull origin master 6. 再次提交修改文件 1$ git add . 7. 添加项目描述 1$ git commit -m &quot;fix&quot; -n 8. 推送到主线分支 1$ git push origin master 通常情况下，我们并不是直接托送到master分支，而是在本地创建自己的开发分支再推送到仓库的dev分支，这样才能保证master的准确性。 1.查看远程分支 1$ git branch -a 2.查看本地分支 1$ git branch 3.从对应的分支下拉新分支 1$ git pull origin dev 4.创建新test分支 $ git branch test 5.同步远程分支 123$ git add .$ git commit -m &#x27;init file&#x27; -n$ git push origin test 6.开发完对应功能，推送 1234567$ git stash` # 暂存本地修改$ git pull origin test# 同步远程分支，多人协作开发时必须操作$ git stash pop# 恢复本地修改$ git add . --&gt;对应第5步骤推送代码","tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Git/"}]},{"title":"react事件处理","date":"2018-11-12T13:06:00.000Z","path":"2018/11/12/react事件处理/","text":"React的事件处理和DOM元素的很相似，但是还是有些不同： 绑定事件方式 传统: onclick 属性小写 reatc: onClick on+事件名 驼峰原则 阻止事件默认 传统: &lt;a href=&quot;#&quot; onclick=&quot;javascript:return false;&quot;&gt;链接&lt;/a&gt; react: 12345678910111213141516171819class PreventDefault extends Component&#123; constructor(props)&#123; super(props) this.handleClick = this.handleClick.bind(this) &#125; handleClick = () =&gt; &#123; // handleClick()&#123;&#125;可以写成这种形式 e.preventDefault(); console.log(&#x27;preventDefault&#x27;); &#125; render()&#123; return( &lt;div&gt; &lt;a href=&quot;#&quot; onClick=&#123;this.handleClick&#125;&gt;阻止默认行为&lt;/a&gt; &lt;/div&gt; ) &#125;&#125; 回调函数的this绑定 传统: 自动绑定this react: 直接输出this为undefined，三种方式绑定： 一、onClick=&#123;this.handleClick&#125;情况下在类的构造函数手动绑定： 1234constructor(props)&#123; super(props) this.handleClick = this.handleClick.bind(this)&#125; 二、onClick=&#123;this.handleClick&#125;情况下使用属性初始化器绑定 123handleClick = () =&gt; &#123; console.log(&#x27;this is&#x27;, this);&#125; 三、箭头函数 此时函数的声明方式可以写成上面案例中注释的方式 1onClick=&#123;(e)=&gt;&#123;this.handleClick(e)&#125;&#125; 向事件处理函数传递参数 一、通过Function.prototype.bind方式传递 1&lt;button onClick=&#123;this.handleClick.bind(this,id)&#125;&gt;点击按钮&lt;/button&gt; 二、通过箭头函数传递 1&lt;button onClick=&#123;(e)=&gt;this.handleClick(id,e)&#125;&gt;点击按钮&lt;/button&gt; 上面两个例子中，参数 e 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。 值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面，例如: 12345678910111213141516171819class Propper extends React.Component&#123; constructor()&#123; super() this.state = &#123; name: &#x27;hello react&#x27; &#125; &#125; handleClick (name, e)&#123; &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;a href=&quot;www.baidu.com&quot; onClick=&#123;this.handleClick.bind(this, this.state.name)&#125;&gt;链接&lt;/a&gt; &lt;/div&gt; ) &#125;&#125;","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"小程序的组件布局","date":"2018-10-20T03:43:00.000Z","path":"2018/10/20/小程序的组件布局/","text":"前端页面开发常用的是DIV+CSS布局，但是在小程序中为了达到不同端的兼容，定义了一套的组件标签，比如和div类似的有view。 一、视图容器 1.1 view组件 view是一个块级容器组件，没有特殊功能，主要用于布局展示，类似于DIV+CSS中的div，view具备一套关于点击行为的属性： hover: 是否启动点击状态，默认值为false hover-class: 指定按下去的样式，当hover-class=&quot;none&quot;时，没有点击效果，默认值为“none” hover-start-time: 按住后多久出现点击状态，单位毫秒，默认值为50 hover-stay-time: 手指松开后点击状态保留时间，单位毫秒，默认值为400 下面介绍三种常见的布局： 三栏布局 12345&lt;view style=&quot;display: flex;&quot;&gt; &lt;view style=&quot;background-color:red;flex-grow:1;height:80rpx;&quot;&gt;1&lt;/view&gt; &lt;view style=&quot;background-color:blue;flex-grow:1;height:80rpx;&quot;&gt;2&lt;/view&gt; &lt;view style=&quot;background-color:green;flex-grow:1;height:80rpx;&quot;&gt;3&lt;/view&gt;&lt;/view&gt; 左右混合布局 1234567&lt;view style=&quot;display: flex; height: 400rpx;&quot;&gt; &lt;view style=&quot;background-color:red;width:250rpx;color:#fff;&quot;&gt;1&lt;/view&gt; &lt;view style=&quot;flex-grow:1;display:flex;flex-direction:column;&quot;&gt; &lt;view style=&quot;flex-grow:1;background-color:blue;color:#fff;&quot;&gt;2&lt;/view&gt; &lt;view style=&quot;flex-grow:1;background-color:green;color:#fff;&quot;&gt;3&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 上下混合布局 1234567&lt;view style=&quot;display: flex; flex-direction: column; height: 400rpx;&quot;&gt; &lt;view style=&quot;background-color:red;height:150px;color:#fff;&quot;&gt;1&lt;/view&gt; &lt;view style=&quot;flex-grow:1;display:flex;&quot;&gt; &lt;view style=&quot;flex-grow:1;background-color:blue;color:#fff;&quot;&gt;2&lt;/view&gt; &lt;view style=&quot;flex-grow:1;background-color:green;color:#fff;&quot;&gt;3&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1.2 scroll-view组件 该组件容器具备可滑动的能力，尽管我们可以给view组件设置overflow: scroll属性来实现，但是由于小程序没有DOM的概念，不方便于后续处理，因此我们需要用到scroll-view组件，有以下属性： scroll-x: 允许横向滚动，默认false scroll-y: 允许纵向滚动，默认false upper-threshold: 距顶部/左边多远时（单位px）触发scrolltoupper事件，默认50 lower-threshold: 距底部/右边多远时（单位px）触发scrolltolower事件，默认50 scroll-top: 设置竖向滚动条位置 scroll-left: 设置横向滚动条位置 scroll-into-view: 值应为某子元素的id，滚动到该元素时，元素对齐滚动区域顶部 bindscrolltoupper: 滚动到顶部/左边，会触发scrolltoupper事件 bindscrolltolower: 滚动到底部/右边，会触发scrolltolower事件 bindscroll: 滚动时触发事件 目前，请勿在scroll-view中使用textarea、map、canvas、video组件。 1234567891011&lt;scroll-view class=&quot;scroll-container&quot; upper-threshold=&quot;0&quot; lower-threshold=&quot;100&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; bindscroll=&quot;scroll&quot; bindscrolltolower=&quot;scrollToLower&quot; bindscrolltoupper=&quot;scrollToUpper&quot; scroll-y=&quot;true&quot; scroll-top=&quot;&#123;&#123;scrollTop&#125;&#125;&quot;&gt; &lt;view id=&quot;item-1&quot; class=&quot;scroll-item bg-red&quot;&gt;1&lt;/view&gt; &lt;view id=&quot;item-2&quot; class=&quot;scroll-item bg-blue&quot;&gt;2&lt;/view&gt; &lt;view id=&quot;item-3&quot; class=&quot;scroll-item bg-red&quot;&gt;3&lt;/view&gt; &lt;view id=&quot;item-4&quot; class=&quot;scroll-item bg-blue&quot;&gt;4&lt;/view&gt; &lt;view id=&quot;item-5&quot; class=&quot;scroll-item bg-red&quot;&gt;5&lt;/view&gt; &lt;view id=&quot;item-6&quot; class=&quot;scroll-item bg-blue&quot;&gt;6&lt;/view&gt;&lt;/scroll-view&gt;&lt;view class=&quot;act&quot;&gt; &lt;button bindtap=&quot;scrollToTop&quot;&gt;点击滚到顶部&lt;/button&gt;&lt;/view&gt; 1234567891011121314151617.scroll-container&#123; border: solid 1px; height: 800rpx;&#125;.scroll-container .scroll-item&#123; height: 300rpx; width:120%;&#125;.bg-blue&#123; background-color: #87cefa;&#125;.bg-red&#123; background-color: #ff6347;&#125;.act&#123; padding: 10px;&#125; 1234567891011121314151617181920Page(&#123; data: &#123; toView: &#x27;item-3&#x27; //第一次渲染 默认滚动到该元素区域 &#125;, scrollToUpper: function()&#123; console.log(&#x27;触发到滚动顶部事件&#x27;); &#125;, scrollToLower: function()&#123; console.log(&#x27;触发到滚到底部事件&#x27;); &#125;, // 点击按钮时，滚到顶部 scroll: function()&#123; console.log(&#x27;触发了滚动事件&#x27;); &#125;, scrollToTop: function()&#123; this.setData(&#123; scrollTop: &#x27;0&#x27; &#125;) &#125;&#125;) 1.3 滑块视图组件 tabBar可以配置程序顶部或底部菜单样式，可配置属性： scroll-x: 允许横向滚动，默认false scroll-y: 允许纵向滚动，默认false upper-threshold: 距顶部/左边多远时（单位px）触发scrolltoupper事件，默认50 lower-threshold: 距底部/右边多远时（单位px）触发scrolltolower事件，默认50 scroll-top: 设置竖向滚动条位置 scroll-left: 设置横向滚动条位置 scroll-into-view: 值应为某子元素的id，滚动到该元素时，元素对齐滚动区域顶部 bindscrolltoupper: 滚动到顶部/左边，会触发scrolltoupper事件 bindscrolltolower: 滚动到底部/右边，会触发scrolltolower事件 bindscroll: 滚动时触发事件 12345678&lt;swiper class=&quot;banner&quot; indicator-dots=&quot;true&quot; autoplay=&quot;&#123;&#123;autoplay&#125;&#125;&quot; current=&quot;0&quot; interval=&quot;2000&quot; duration=&quot;300&quot; bindchange=&quot;change&quot;&gt; &lt;block wx:for=&quot;&#123;&#123;sliderList&#125;&#125;&quot;&gt; &lt;swiper-item class=&quot;&#123;&#123;item.className&#125;&#125;&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/swiper-item&gt; &lt;/block&gt;&lt;/swiper&gt;&lt;view&gt; &lt;button bindtap=&quot;play&quot;&gt;暂停|播放&lt;/button&gt;&lt;/view&gt; 12345678910111213.banner&#123; height: 400px; background-color: #ddd;&#125;.bg-blue&#123; background-color: #87cefa;&#125;.bg-red&#123; background-color: #ff6347;&#125;.bg-green&#123; background-color: #43cd80;&#125; 12345678910111213141516171819202122Page(&#123; data: &#123; autoplay: true, sliderList: [ &#123;className: &#x27;bg-red&#x27;, name: &#x27;slider1&#x27;&#125;, &#123;className: &#x27;bg-blue&#x27;, name: &#x27;slider2&#x27;&#125;, &#123;className: &#x27;bg-green&#x27;, name: &#x27;slider3&#x27;&#125;, ] &#125;, //监听swiper滚动事件，并切换面板 switchTab: function(e)&#123; console.log(&#x27;监听切换处理&#x27;); &#125;, play: function()&#123; this.setData(&#123; autoplay: !this.data.autoplay &#125;) &#125;, change: function()&#123; console.log(&#x27;执行了滑动&#x27;); &#125;&#125;)","tags":[{"name":"小程序","slug":"小程序","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序的WebSocket","date":"2018-10-17T14:32:00.000Z","path":"2018/10/17/小程序的WebSocket/","text":"以前的网络通信方式都是通过客户端向服务端发起请求，然后由服务端返回数据以达到通信的目的，这种方式有个缺点，不能实现服务端主动向客户端返回数据来达到通信的目的，采用这种短连接方式实现客户端和服务端之间的即时通讯技术只能使用轮询，即在特定的时间间隔（如1秒），由客户端向服务端发起请求，然后由服务端返回数据。这种方式要不断的向服务端发起请求，既浪费性能又占用带宽，在这种情况下，小程序提供相关API应用WebSocket。 各种API方法和参数详见官方文档，这里不多赘述，下面展示一个简单的例子。 123456789101112131415161718192021222324var socketOPen = false;var socketMsgQueue = [];wx.connectSocket(&#123; // 创建连接 url: &#x27;wss://www.myserver.com&#x27;,&#125;);wx.onSocketOpen(function(res)&#123; socketOpen = true; // 连接打开后先处理之前栈中数据 for(var i = 0, msg; msg = socketMsgQueue[i]; ++i)&#123; sendMsg(msg); &#125; socketMshQueue = [];&#125;);function sendMsg(msg)&#123; // 如果连接在请求中还未打开，先将数据出入信息栈中 if(!socketOpen)&#123; socketMsgQueue.push(msg); return; &#125; // 如果连接打开，发送数据 wx.sendSocketMessage(&#123; data: msg &#125;);&#125;","tags":[{"name":"小程序","slug":"小程序","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序的全局配置和逻辑文件","date":"2018-10-01T02:50:00.000Z","path":"2018/10/01/小程序的全局配置和逻辑文件/","text":"小程序就不用多说了，其用完即走的理念和以微信为宿主的优势使其成为现在前端领域的热门话题。本文介绍微信小程序入门的小程序全局配置文件app.json和逻辑文件app.js。详见官文 一、配置文件（app.json） app.json是小程序的全局配置文件，在程序加载时加载，只加载一次，其配置项有： pages: 设置页面路径，必填项 window: 设置默认页面的窗口表现 tabBar: 设置tab的表现 networkTimeout: 设置网络超时时间 debug: 设置是否开启debug模式，默认关闭。 1.1 pages配置 pages负责注册小程序的页面，其值为包含页面路径的数组。 123456&#123; &quot;pages&quot;: [ &quot;page/index/index&quot;, &quot;page/list/list&quot; ]&#125; 1.2 window配置 window负责设置小程序的状态栏、导航条、标题、窗口背景色等系统级样式。属性： navigationBarBackgroundColor: 导航栏背景颜色 navigationBarTextStyle: 导航栏标题颜色，仅支持black/white navigationBarTitleText: 导航栏标题文字内容 backgroundColor: 窗口背景色 backgroundTextStyle: 下拉背景字体、Loading图的样式、仅支持drak/light enablePullDownRefresh: 是否开启下拉刷新，默认false 1.3 tabBar配置 tabBar可以配置程序顶部或底部菜单样式，可配置属性： color: tab上文字的颜色，必填 selectedColor: tab上文字选中时的颜色，必填 backgroundColor: tab的背景颜色，必填 borderStyle: tabbar上边框的颜色，必填 list: tab的列表，必填，值为一个数组，最少2个最多5个，数组中每一项是一个对象，代表一个tab的相关配置，每项的相关配置如下： pagePath: 页面路径，必须在pages中先定义，必填项 text: tab上按钮的文字，必填项 iconPath: tab上icon图片的相对路径，icon大小限制在40kb，必填 selectedPath: tab选中时图片的相对路径，icon大小限制在40kb，必填 position: tab在顶部或者底部显示，可选值为bottom、top，默认是bottom 1234567891011121314151617181920212223242526272829&#123; &quot;pages&quot;: [ &quot;page/index/index&quot;, &quot;page/list/list&quot; ], &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#000000&quot;, &quot;selectedColor&quot;: &quot;#ff7f50&quot;, &quot;backgroundColor&quot;: &quot;#ffffff&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;page/index/index&quot;, &quot;iconPath&quot;: &quot;images/home.png&quot;, &quot;selectedIconPath&quot;: &quot;images/home-selected.png&quot;, &quot;text&quot;: &quot;首页&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;page/list/list&quot;, &quot;iconPath&quot;: &quot;images/list.png&quot;, &quot;selectedIconPath&quot;: &quot;images/list-selected.png&quot;, &quot;text&quot;: &quot;列表&quot; &#125;], &quot;borderStyle&quot;: &quot;bottom&quot;, &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 60000, &quot;connectSocket&quot;: 60000 &#125;, &quot;debug&quot;: true &#125;&#125; 1.4 networkTimeout配置 小程序中各种网络请求API的超时时间只能通过networkTimeout统一设置，不能再API中单独设置，具体属性有： request: 设置wx.request的超时时间，单位毫秒。 connectSocket: 设置wx.connectSocket的超时时间，单位毫秒。 uploadFile: 设置wx.uploadFile的超时时间，单位毫秒。 downloadFile: 设置wx.downloadFile的超时时间，单位毫秒。 1.5 debug配置 此项配置控制是否开启debug模式，默认是关闭的，值为布尔类型。 二、逻辑文件（app.js） app.js是小程序的逻辑文件，小程序的逻辑文件分为页面逻辑文件和小程序逻辑文件，此文件中我们可以通过App()函数注册小程序的生命周期函数，全局方法和全局属性，已注册的小程序实例可以在其他逻辑层代码中通过getApp()获取。 2.1 注册小程序 App()函数用于注册一个小程序，参数为Object对象，在参数对象中我们可以注册自定义方法和属性供全局使用，其参数属性如下： onLaunch: 生命周期函数，监听小程序初始化。当小程序初始化完成时，就会触发onLaunch，该事件在全局只触发一次。 onShow: 生命周期函数，监听小程序显示。当小程序启动时或者从后台进入前台显示时都会触发onShow。 onHide: 生命周期函数，监听小程序隐藏。当小程序从前台进入后台时会触发。 其他: 开发者可以添加任意的函数或数据到Object参数中，这些属性会被注册到小程序对象中，其他逻辑文件可通过getApp()函数获取已注册的小程序实例。 1234567891011121314App(&#123; onLaunch: function()&#123; //小程序初始化完成时执行 &#125;, onShow: function()&#123; //小程序显示时执行 &#125;, onHide: function()&#123; //小程序隐藏时执行 &#125;, gloabalOtherFn: function()&#123; //其他全局方法 &#125;&#125;) 2.2 获取小程序实例 注册完小程序，可以在其他逻辑文件中通过全局函数getApp()获取小程序实例： 12var app = getApp();console.log(app.globalData); 在App()注册函数中，this代表当前App实例，而不使用getApp()方法。通过getApp()获取实例后，可以获取注册的属性，调用注册的方法，但不要私调用声明周期函数，这样使项目逻辑混乱。","tags":[{"name":"小程序","slug":"小程序","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"nodejs代理解决接口跨域问题","date":"2018-09-26T14:05:00.000Z","path":"2018/09/26/node.js代理解决接口跨域问题/","text":"由于安全性和防盗链等原因吗，一般在服务端都会设置跨域限制，然而跨域限制一般只在浏览器端存在，对于服务端或IOS、Android等客户端是不存在的，使用代理是常见的解决方案，比如：Nginx反向代理，nodejs代理… 这里以API代理和图片代理为例，API来自知乎链接。 1.安装依赖 首先安装依赖npm install --save-dev request 2.设置代理域 123456const http = require(&#x27;http&#x27;);const request = require(&#x27;request&#x27;);const hostname = &#x27;127.0.0.1&#x27;;const port = 8010;const imgPort = 8011; 3.创建一个API代理服务 12345678910111213141516171819202122232425// 创建一个API代理服务const apiServer = http.createServer((req, res) =&gt; &#123; const url = &#x27;http://news-at.zhihu.com/api/2&#x27; + req.url; // /news/latest const options = &#123; url: url &#125;; function callback(error, response, body)&#123; if(!error &amp;&amp; response.statusCode === 200)&#123; //设置编码类型 否则中文乱码 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain;charset=UTF-8&#x27;); //设置所有域允许跨域 res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //返回代理后的内容 res.end(body); &#125; &#125; request.get(options, callback);&#125;);// 监听8080端口apiServer.listen(port, hostname, () =&gt; &#123; console.log(`接口代理运行在http://$&#123;hostname&#125;:$&#123;port&#125;`);&#125;) 3.创建一个图片代理服务 12345678910111213141516171819202122// 创建一个图片代理服务const imgServer = http.createServer((req, res) =&gt; &#123; const url = req.url.split(&#x27;/img/&#x27;)[1]; const options = &#123; url: url, encoding: null &#125;; function callback(error, response, body)&#123; if(!error &amp;&amp; response.statusCode === 200)&#123; const contentType = response.headers[&#x27;content-type&#x27;]; res.setHeader(&#x27;Content-Type&#x27;, contentType); res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.end(body); &#125; &#125; request.get(options, callback);&#125;)// 监听8011端口apiServer.listen(imgPort, hostname, () =&gt; &#123; console.log(`图片接口代理运行在http://$&#123;hostname&#125;:$&#123;imgPort&#125;`);&#125;) 4.启动服务 node filename.js通过node命令运行该js文件。 代理的核心是在返回的头部（response header）中添加一项Access-Control-Allow-Origin为&quot;*&quot;，允许所以域访问。这里监听了两个端口：8010和8011，比如真实的接口为：http://news.zhihu.com/api/2/news/latest， 开发时改写为：http://127.0.0.1:8010/news/latest； 图片真实地址为：http://pic2.zhihu.com/pic0.jpg， 开发时改写为：http://127.0.0.1:8011/img/http://pic2.zhihu.com/pic0.jpg。","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/NodeJs/"}]},{"title":"webpack搭载vue常见错误","date":"2018-09-23T02:38:00.000Z","path":"2018/09/23/webpack搭载vue常见错误/","text":"现在，前端工程化越来越成为前端开发中不可回避的问题，伴随的还有模块化，组件化等。 那么，前端自动化工程主要解决一下一些问题： JavaScript、css代码合并和压缩 css预处理语言的编译 生成雪碧图 ES6转ES5 模块化 … 虽然webpack看起来比较复杂，但它只不过是一个js配置文件，只需要搞清楚入口（Entry）、出口（Output）、加载器（Loaders）和插件（Plugins）这四个概念，使用起来就很容易了。 以下罗列了webpack搭载vue配置时一些常见的报错及处理方式，本次使用的webpack版本为4.19.0，请务必先安装node.js。 使用npm init初始化配置。 在项目目录下局部安装webpacknpm install webpack --save-dev。 安装webpack服务，启动热更新npm install webpack-dev-server --save-dev，在package.json的scripts里面配置启动服务脚本，运行npm run dev会自动打开服务。 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.config.js&quot; &#125;, 在项目目录下新建一个main.js文件作为入口文件，然后在webpack.config.js中配置。 123456789101112var path = require(&#x27;path&#x27;);var config = &#123; entry: &#123; main: &#x27;./main&#x27; //入口文件 &#125;, output: &#123; path: path.join(__dirname, &#x27;./dist&#x27;), //输出文件路径 publicPath: &#x27;/dist/&#x27;, //指定资源文件引用目录 filename: &#x27;main.js&#x27; //输出文件名 &#125;&#125;;module.exports = config; 在webpack的世界里面，每一个文件都是一个模块，所以不同的文件需要用不同的加载器来处理，如果需要写一些css样式，就需要用到css加载器。 npm install css-loader --save-dev npm install style-loader --save-dev 123456789101112131415var config = &#123; //...... module:&#123; rules: [ &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ] &#125; ] &#125;&#125;; 在module的rules属性中可以指定一系列的loaders，每一个loader都必须包含test和use选项，当webpack编译遇到.css结尾的文件，使用该加载器编译。 直到上面这种情况，css是通过JavaScript动态创建style标签来写入的，这样就加重了main.js的代码量，但在实际业务中，可能有多个css样式文件，我们可以把这些文件提取出来，合并成一个main.css文件。 npm install extract-text-webpack-plugin --save-dev 123456789101112131415161718192021var ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);var config = &#123; //...... module:&#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: &#x27;style-loader&#x27;, fallback: &#x27;css-loader&#x27; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;main.css&quot;); ]&#125;;//..... 搭载vue需要使用vue加载器vue-loader、vue-style-loader，还需要使用babel做ES6转换，配置到webpack中可以解析vue文件，需要以下依赖： npm install --save vue npm install --save-dev vue-loader npm install --save-dev vue-style-loader npm install --save-dev vue-template-compiler npm install --save-dev vue-hot-reload-api npm install --save-dev babel npm install --save-dev babel-loader npm install --save-dev babel-core npm install --save-dev babel-plugin-transform-runtime npm install --save-dev babel-preset-es2015 npm install --save-dev babel-runtime 12345678910111213141516171819202122232425262728293031323334353637var ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);var config = &#123; //...... module:&#123; rules: [ &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: &#x27;style-loader&#x27;, fallback: &#x27;style-loader&#x27; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;main.css&quot;) ]&#125;;//..... babel还需要一个.babelrc的文件，并写入babel配置，webpack会依赖此文件使用babel编译ES6。 12345&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;], &quot;comments&quot;: false&#125; 我们可以对webpack进一步配置，来支持更多功能，实现对图片、字体的支持。 npm install --save-dev url-loader npm install --save-dev file-loader 12345678910111213141516var config = &#123; //...... module:&#123; rules: [ //...... &#123; test: /\\.(gif|jpg|png|woff|svg|eot|ttf)\\??.*$/, loader: &#x27;url-loader?limit=1024&#x27; &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;main.css&quot;) ]&#125;;//..... 上面是开发环境的基本配置，生产环境打包所以资源都会保存到demo/dist目录下，为方便开发和生产的切换，需添加生产环境的配置文件webpack.prod.config.js，需安装两个依赖： npm install --save-dev webpack-merge npm install --save-dev html-webpack-plugin 123456// package.json&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.config.js&quot;, &quot;build&quot;: &quot;webpack --progress --hide-modules --config webpack.prod.config.js&quot;&#125;, 1234567891011121314151617181920212223242526272829303132333435363738394041// webpack.prod.config.jsvar webpack = require(&#x27;webpack&#x27;);var HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);var ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);var merge = require(&#x27;webpack-merge&#x27;);var webpackBaseConfig = require(&#x27;./webpack.config.js&#x27;);//清空基本配置的插件列表webpackBaseConfig.plugins = [];module.exports = merge(webpackBaseConfig, &#123; output: &#123; publicPath: &#x27;/dist/&#x27;, filename: &#x27;[name].[hash].js&#x27; &#125;, plugins: [ new ExtractTextPlugin(&#123; // 提取css,并从命名为带有20位hash值的唯一文件 filename: &#x27;[name].[hash].css&#x27;, allChunks: true &#125;), //定义当前node环境为生产环境 new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: &#x27;&quot;production&quot;&#x27; &#125; &#125;), //压缩js new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125; &#125;), //提取模板 并保存入口html文件 new HtmlWebpackPlugin(&#123; filename: &#x27;../index_prod.html&#x27;, template: &#x27;./index.ejs&#x27;, inject: false &#125;) ]&#125;) 通过npm run build运行打包，会在项目目录下生成dist文件，里面就是打包完成的所以静态资源。至此，webpack的一些基本配置已经完成，以下是过程中的一些报错： 1.缺少webpack-cli 找不到webpack-cli模块，原因是在webpack4.0之后，webpack-cli作为一个工具包独立出来了，npm install -D webpack-cli安装即可。 2.extract-text-webpack-plugin版本太低 版本过低，与webpack4.x不兼容，npm install --save-dev extract-text-webpack-plugin@next升级到下一个测试版本，可解决。 3.babel的相关插件版本不统一 babel版本可能是6.x，但是babel-core或者babel-loader的版本达到8.x，解决办法有下面两种： 1.使用webpack 4.x | babel-loader 8.x | babel 7.x，安装npm install -D babel-loader @babel/core @babel/preset-env webpack 2.使用webpack 4.x | babel-loader 7.x | babel 6.x，安装npm install -D babel-loader@7 babel-core babel-preset-env webpack 4.vue-loader新特性 vue-loader在15.x之后的版本都需要使用VueLoaderPlugin，解决办法，先定义一个VueLoaderPlugin变量，再在扩展中使用。 const VueLoaderPlugin = require('vue-loader/lib/plugin'); 在webpack.config.js中plugins项添加new VueLoaderPlugin() 5.js压缩旧方法的移除 在webpack4.x之后移除了UglifyJsPlugin的用法，用config.optimization.minimize代替，解决办法： npm install --save-dev uglifyjs-webpack-plugin安装该插件 引入并配置该插件： 1234567891011121314const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;);module.exports = &#123; //... optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: false &#125; &#125;) ] &#125;&#125;; 至此，搭载vue的一个自动化工程已经基本配置好了，由于webpack配置内容较为笼统，详细代码请参考：https://github.com/joydezhong/webpack-vue","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/webpack/"}]},{"title":"vue组件间的通信","date":"2018-09-21T14:27:00.000Z","path":"2018/09/21/vue组件间的通信/","text":"“组件化、模块化、工程化”是现在前端中不可回避的话题，在Vue开发中体现的尤为明显，组件与组件之间的通信也有多种类型，参考下图： 一、父组件向子组件通信 1.1.props传递数据 如上图中父组件向子组件通信使用props传递数据，在组件中使用props选项来声明需要从父级接收的数据，props值有两种：一种是字符串数组，一种是对象。 1234&lt;div id=&quot;root&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;parentMessge&quot; /&gt; &lt;my-component :parent-data=&quot;parentMessage&quot;&gt;&lt;/my-component&gt;&lt;/div&gt; 12345678910Vue.component(&#x27;my-component&#x27;, &#123; props: [&#x27;parentData&#x27;], template: &#x27;&lt;div&gt;来自父组件的数据：&#123;&#123;parentData&#125;&#125;&lt;/div&gt;&#x27;&#125;)new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; parentMessage: &#x27;&#x27; &#125;&#125;) 父组件my-component绑定了一个数据parentData，数据来源于input的输入值，组件内的template里包含一个div，并显示相应的数据。 1.2.单向数据流 Vue2.x和Vue1.x比较大的一个改变是Vue2.x通过props传递的数据是单项流的，也就是说父级props的更新会向下流到子组件中，但是反过来不行，这样尽可能的解耦父子组件，避免子组件意外修改父组件的状态，从而 导致你的应用的数据流难以理解，详见官文单项数据流。 1234&lt;div id=&quot;app&quot;&gt; &lt;p&gt;父组件数据：&#123;&#123;pData&#125;&#125;&lt;/p&gt; &lt;single-component :init-count=&quot;pData&quot;&gt;&lt;/single-component&gt;&lt;/div&gt; 1234567891011121314151617181920Vue.component(&#x27;single-component&#x27;, &#123; props: [&#x27;initCount&#x27;], template: &#x27;&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;button @click=&quot;handleClick&quot;&gt;+1&lt;/button&gt;&lt;/div&gt;&#x27;, data: function()&#123; return &#123; count: this.initCount &#125; &#125;, methods: &#123; handleClick: function()&#123; this.count++ &#125; &#125;&#125;);new Vue(&#123; el: &#x27;#app1&#x27;, data: &#123; pData: 3 &#125;&#125;) 子组件中声明一个本地data数据count来保存父组件传递过来的数据，之后就与父组件的数据无关，不管count如何修改，都不会影响父组件的数据，当我们点击+1按钮对count执行+1操作，此时父组件数据并不受影响。 二、子组件向父组件通信 2.1.自定义事件 当子组件要向父组件传递数据时，可以用到v-on进行自定义事件，子组件通过$emit()来触发事件，父组件通过$on()来监听事件。 1234567&lt;div id=&quot;root&quot;&gt; &lt;p&gt;总数： &#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;my-component @increase=&quot;handleGetTotal&quot; @reduce=&quot;handleGetTotal&quot; &gt;&lt;/my-component&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233Vue.component(&#x27;my-component&#x27;, &#123; template: &#x27;&lt;div&gt;&#x27; + &#x27;&lt;button @click=&quot;handleIncrease&quot;&gt;+1&lt;/button&gt;&#x27; + &#x27;&lt;button @click=&quot;handleReduce&quot;&gt;-1&lt;/button&gt;&#x27; + &#x27;&lt;/div&gt;&#x27;, data: function()&#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; handleIncrease: function()&#123; this.counter++; this.$emit(&#x27;increase&#x27;, this.counter); &#125;, handleReduce: function()&#123; this.counter--; this.$emit(&#x27;reduce&#x27;, this.counter); &#125; &#125;&#125;);new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; total: 0 &#125;, methods: &#123; handleGetTotal: function(total)&#123; this.total = total; &#125; &#125;&#125;) 这里在组件的template的两个按钮自定义handleIncrease和handleReduce事件执行对组件数据的增减，然后通过this.$emit触发increase和reduce事件并传递组件中的数据，在父组件中通过@increase和@reduce监听事件，并执行相应的操作。 2.2.自定义组件使用v-model Vue2.x可以在自定义组件上使用v-model，实际上是@input事件的一个语法糖。 123456&lt;div id=&quot;app&quot;&gt; &lt;p&gt;总数：&#123;&#123;total&#125;&#125;&lt;/p&gt; &lt;model-component v-model=&quot;total&quot;&gt;&lt;/model-component&gt; &lt;p&gt;总数：&#123;&#123;total1&#125;&#125;&lt;/p&gt; &lt;model-component @input=&quot;handleGetTotal&quot;&gt;&lt;/model-component&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627Vue.component(&#x27;model-component&#x27;,&#123; template: &#x27;&lt;button @click=&quot;handleClick&quot;&gt;+1&lt;/button&gt;&#x27;, data: function()&#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; handleClick: function()&#123; this.counter++; this.$emit(&#x27;input&#x27;, this.counter); &#125; &#125;&#125;);new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; total: 0, total1: 0 &#125;, methods: &#123; handleGetTotal: function(total)&#123; this.total1 = total; &#125; &#125;&#125;); 这里自定义了一个组件model-component，引用了两次，第一次使用v-model指令绑定total数据，第二次使用@input事件绑定handleGetTotal方法；而在组边template的按钮里使用@click绑定handleClick，在方法里面对数据执行操作并触发input事件，传递了处理后的数据。 三、非父子组件间的通信 3.1.借助中央事件总线bus 中央处理总线就是一个全局的空的vue实例，用于承载组件间通信的操作，从单词意思也可以看出。 123456&lt;div id=&quot;app&quot;&gt; &lt;p&gt;实例下显示孙组件的内容：&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;wrap-component&gt; &lt;in-component&gt;&lt;/in-component&gt; &lt;/wrap-component&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233var bus = new Vue();var Child = &#123; template: &#x27;&lt;div&gt;&lt;h6&gt;这是内层孙组件&lt;/h6&gt;&lt;button @click=&quot;handleEvent&quot;&gt;孙按钮派发事件&lt;/button&gt;&lt;/div&gt;&#x27;, methods: &#123; handleEvent: function()&#123; bus.$emit(&#x27;on-message&#x27;, &#x27;来自孙组件的内容&#x27;); &#125; &#125;&#125;Vue.component(&#x27;wrap-component&#x27;,&#123; template: &#x27;&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;这是外层组件&lt;/div&gt;&#x27;, components: &#123; &#x27;in-component&#x27;: Child &#125;&#125;);new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;&#x27; &#125;, components: &#123; &#x27;in-component&#x27;: Child &#125;, mounted: function()&#123; var _this = this; bus.$on(&#x27;on-message&#x27;, function(msg)&#123; _this.message = msg; &#125;) &#125;&#125;) 这里首先创建了一个名为bus的Vue空实例，用js对象的形式创建了一个组件，并在wrap-component组件中注册，由于局部注册的组件在其子组件中不可用，所以在根实例中再注册一次。局部组件通过按钮事件向bus触发一个’on-message’事件，传递相应的数据，并在app vue实例下监听相应的事件。 3.2.父链和子链 在子组件中，可以通过this.$parent访问该组件的父实例和组件，同样的可以通过this.$children访问它的子组件，可以无限上下递归，直到最内层的组件或根实例。 1234&lt;div id=&quot;app&quot;&gt; &lt;p&gt;通过父链修改的数据：&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;component-a&gt;&lt;/component-a&gt;&lt;/div&gt; 123456789101112131415Vue.component(&#x27;component-a&#x27;,&#123; template: &#x27;&lt;button @click=&quot;handleEvent&quot;&gt;通过父链直接修改数据&lt;/button&gt;&#x27;, methods: &#123; handleEvent: function()&#123; this.$parent.message = &#x27;来自组件component-a的内容&#x27;; &#125; &#125;&#125;);new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;默认数据，点击按钮被修改&#x27; &#125;&#125;); 这里直接通过组件的按钮修改了父实例的数据。 3.3.子组件索引 当子组件过多时，多次使用$children显然不可取，这时候可以通过ref属性给组件一个索引名称。 1234&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;handleRef&quot;&gt;通过ref获取子组件实例&lt;/button&gt; &lt;component-b ref=&quot;comA&quot;&gt;&lt;/component-b&gt;&lt;/div&gt; 12345678910111213141516171819Vue.component(&#x27;component-b&#x27;, &#123; template: &#x27;&lt;div&gt;子组件&lt;/div&gt;&#x27;, data: function()&#123; return &#123; message: &#x27;子组件内容&#x27; &#125; &#125;&#125;);new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; handleRef: function()&#123; //通过$refs来访问指定的实例 var msg = this.$refs.comA.message; console.log(msg); &#125; &#125; &#125;) 这里this.$refs.comA获取到指定索引的组件，注意的是，$refs只在组件渲染完成后才填充，并且它是非响应式的，应该避免在模板和计算属性中使用。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"node爬虫获取翻页数据","date":"2018-09-20T01:40:00.000Z","path":"2018/09/20/node爬虫获取翻页数据/","text":"如果我们想：如果能够获取翻页数据，那数据不就丰富了。这里也可以解决这个问题。 本程序在上一篇文章爬虫程序写入mongodb中的程序依赖中增加eventproxy包，请自行创建node项目并安装，推荐使用webstorm直接创建一个node.js express App。 eventproxy是管理异步操作的一个npm包， 1.引入依赖模块 123456789101112//导入包const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);const url = require(&quot;url&quot;);const fs = require(&quot;fs&quot;);const eventproxy = require(&#x27;eventproxy&#x27;);const mongoose = require(&quot;mongoose&quot;);const superagent = require(&quot;superagent&quot;);const cheerio = require(&quot;cheerio&quot;);const ep = eventproxy(); 2.连接数据库，建数据模型 推荐使用MongoDB可视化工具Studio 3T，安装MongoDB数据库自行参考网上资料。 12345678910111213141516//连接本地mongodb数据库Doubanvar mongourl = &#x27;mongodb://localhost/DBBook&#x27;;mongoose.connect(mongourl);var Schema = mongoose.Schema;//创建模型var topBookSchema = new Schema(&#123; title: String, enTitle: String, bookId: Number, copyrightInfo: String, grade: String, remark: String, bookImg: String, description: String&#125;);var TopBook = mongoose.model(&#x27;topBook&#x27;, topBookSchema, &#x27;topbooklist&#x27;); 3.初始化结果数组和url数组 123456789//存放结果和url数组的let resultArr = [];let desUrlList = [];//页码拼接url遍历for (let i = 1; i &lt;= 10; i++)&#123; let pageIndex = 25*(i-1); desUrlList.push(`https://book.douban.com/top250?start=$&#123;pageIndex&#125;`);&#125; 4.遍历url数组，调用superagent的get方法和end方法处理 get(): 此方法参数为获取数据的链接 end(): 此方法第一的参数为error对象，第二个参数为get中页面的所有DOM结果 1234567for (let desUrl of desUrlList)&#123; superagent .get(desUrl) .end((error, response)=&gt;&#123; // ...5... &#125;)&#125; 5.分析结构，提取相应的数据，派发异步事件 12345678910111213141516171819202122232425262728293031323334353637383940414243if(error) console.log(error);//获取页面文档数据var content = response.text;//cheerio也就是node下的jquery 将整个文档包装成一个集合，定义一个$接收var $ = cheerio.load(content);//分析文档结构 先获取每个li 再遍历里面的内容（此时每个li里面就存放着我们想要获取的数据）$(&quot;.indent table&quot;).each(function(index,value)&#123; //提取url链接中的id var address = $(value).find(&quot;.item td a&quot;).attr(&quot;href&quot;); var bookId = address.replace(/[^0-9]/ig,&quot;&quot;); //将获取的数据以对象的形式添加到数组中 var oneBook = &#123; title: $(value).find(&quot;.item td .pl2 a&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;), enTitle: $(value).find(&quot;.item td .pl2 span&quot;).text(), bookId: bookId, copyrightInfo: $(value).find(&quot;.item td p.pl&quot;).text(), grade: $(value).find(&quot;.item td .star .rating_nums&quot;).text(), remark: $(value).find(&quot;.item td .star .pl&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;), bookImg: $(value).find(&quot;.item td .nbg img&quot;).attr(&quot;src&quot;).replace(/^https:/g,&quot;&quot;), description: $(value).find(&quot;.item td .quote .inq&quot;).text() &#125;; resultArr.push(oneBook); //将每个书本信息实例化到newBook模型中 var topBook = new TopBook(oneBook); //保存到mongodb topBook.save(function(err)&#123; if(err)&#123; console.log(&#x27;保存失败：&#x27;+ err); return; &#125; console.log(&quot;OK!&quot;); &#125;); ep.emit(&#x27;allBooks&#x27;,oneBook); //派发一个事件&#125;); ep是eventproxy的实例，这里通过emit()方法派发一个事件allBooks，用来监测oneBook数据，当一个oneBook数据源抓取完毕，就会告诉ep一个数据源抓取完成。 6.在所以异步操作执行完后执行某些处理 1234// 此代码放于for循环后ep.after(&#x27;allBooks&#x27;,desUrlList.length,function () &#123; //......&#125;); 完整代码请参考：https://github.com/joydezhong/SimpleCrawler/blob/master/pageEventproxy.js","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"node爬虫数据写入MongoDB","date":"2018-09-17T01:32:00.000Z","path":"2018/09/17/node爬虫数据写入mongodb/","text":"如果我们想：不是每次都打开json文件，导入到数据库，而是直接能把获取的数据写入到数据库，开发时直接使用，是不是方便多了。这里很好的解决了这个问题。 本程序在上一篇文章简易的爬虫程序中的程序依赖中增加mongoose包，请自行创建node项目并安装，推荐使用webstorm直接创建一个node.js express App。 mongoose操作MongoDB更多强大功能参考官文：https://mongoosejs.com/ mongoose操作MongoDB模式：通过创建Schema模型去匹配数据库中的数据，返回的数据结果通过mongoose提供的方法进行操作。 1.引入依赖模块 123456789//导入包const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);const url = require(&quot;url&quot;);const fs = require(&quot;fs&quot;);const mongoose = require(&quot;mongoose&quot;);const superagent = require(&quot;superagent&quot;);const cheerio = require(&quot;cheerio&quot;); 2.连接数据库，建数据模型 推荐使用MongoDB可视化工具Studio 3T，安装MongoDB数据库自行参考网上资料。 1234567891011121314//连接本地mongodb数据库Doubanvar mongourl = &#x27;mongodb://localhost/DBBook&#x27;;mongoose.connect(mongourl);var Schema = mongoose.Schema;//创建模型var newBookSchema = new Schema(&#123; title: String, bookId: Number, grade: Number, bookInfo: String, bookImg: String, description: String&#125;);var NewBook = mongoose.model(&#x27;NewBook&#x27;, newBookSchema, &#x27;newbooks&#x27;); 3.调用superagent的get方法和end方法处理 get(): 此方法参数为获取数据的链接 end(): 此方法第一的参数为error对象，第二个参数为get中页面的所有DOM结果 12345superagent .get(&quot;https://book.douban.com/latest?icn=index-latestbook-all&quot;) .end((error, response)=&gt;&#123; // ...... &#125;) 4.分析结构，提取相应的数据 123456789101112131415161718192021222324252627282930313233343536373839404142//获取页面文档数据var content = response.text;//cheerio也就是node下的jquery 将整个文档包装成一个集合，定义一个$接收var $ = cheerio.load(content);//定义一个空数组，用来接收数据var result = [];//分析文档结构 先获取每个li 再遍历里面的内容（此时每个li里面就存放着我们想要获取的数据）$(&quot;.cover-col-4 li&quot;).each(function(index,value)&#123; //提取url链接中的id var address = $(value).find(&quot;.cover&quot;).attr(&quot;href&quot;); var bookId = address.replace(/[^0-9]/ig,&quot;&quot;); var gradeStr = $(value).find(&quot;.detail-frame .rating .font-small&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;); //将获取的数据以对象的形式添加到数组中 var oneBook = &#123; title: $(value).find(&quot;.detail-frame h2 a&quot;).text(), bookId: bookId, grade: Number(gradeStr) ? Number(gradeStr) : 0, bookInfo: $(value).find(&quot;.detail-frame .color-gray&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;), bookImg: $(value).find(&quot;.cover img&quot;).attr(&quot;src&quot;).replace(/^https:/g,&quot;&quot;), description: $(value).find(&quot;.detail-frame .detail&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;) &#125;; result.push(oneBook); //将每个书本信息实例化到newBook模型中 var newBook = new NewBook(oneBook); //保存到mongodb newBook.save(function(err)&#123; if(err)&#123; console.log(&#x27;保存失败：&#x27;+ err); return; &#125; console.log(&quot;OK!&quot;); &#125;);&#125;); 完整代码请参考：https://github.com/joydezhong/SimpleCrawler/blob/master/crawler.js","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/NodeJs/"}]},{"title":"node简易的爬虫程序","date":"2018-09-13T12:44:00.000Z","path":"2018/09/13/node简易的爬虫程序/","text":"很多时候自己做前端项目由于没有后台和数据的支持，往往无法更好的渲染页面效果，这时候爬虫就可以很好地解决这个烦恼，本站点的所有爬虫文章都基于豆瓣页面。 node爬虫程序依赖两个npm包：superagent、cheerio，和nodejs的fs模块，通过分析页面DOM结构，提取相应的数据写入json文件中。 本程序依赖node.js和上面的两个npm，请自行创建node项目并安装，可以使用webstorm直接创建一个node.js express App 1.引入依赖模块 12345678//导入包const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);const url = require(&quot;url&quot;);const fs = require(&quot;fs&quot;);const superagent = require(&quot;superagent&quot;);const cheerio = require(&quot;cheerio&quot;); 2.调用superagent的get方法和end方法处理 get(): 此方法参数为获取数据的链接 end(): 此方法第一的参数为error对象，第二个参数为get中页面的所有DOM结果 12345superagent .get(&quot;https://book.douban.com/latest?icn=index-latestbook-all&quot;) .end((error, response)=&gt;&#123; // ...... &#125;) 3.分析结构，提取相应的数据 12345678910111213141516171819202122232425262728293031323334//获取页面文档数据var content = response.text;//cheerio也就是node下的jquery 将整个文档包装成一个集合，定义一个$接收var $ = cheerio.load(content);//定义一个空数组，用来接收数据var result = [];//分析文档结构 先获取每个li 再遍历里面的内容（此时每个li里面就存放着我们想要获取的数据）$(&quot;.cover-col-4 li&quot;).each(function(index,value)&#123; //提取url链接中的id var address = $(value).find(&quot;.cover&quot;).attr(&quot;href&quot;); var bookId = address.replace(/[^0-9]/ig,&quot;&quot;); var gradeStr = $(value).find(&quot;.detail-frame .rating .font-small&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;); //将获取的数据以对象的形式添加到数组中 var oneBook = &#123; title: $(value).find(&quot;.detail-frame h2 a&quot;).text(), bookId: bookId, grade: Number(gradeStr) ? Number(gradeStr) : 0, bookInfo: $(value).find(&quot;.detail-frame .color-gray&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;), bookImg: $(value).find(&quot;.cover img&quot;).attr(&quot;src&quot;).replace(/^https:/g,&quot;&quot;), description: $(value).find(&quot;.detail-frame .detail&quot;).text().replace(/\\ +/g,&quot;&quot;).replace(/[\\r\\n]/g,&quot;&quot;) &#125;; result.push(oneBook);&#125;); //将数组转成字符串result = JSON.stringify(result);//将数组输出到json文件里 刷新目录 即可看到当前文件夹多出一个newBooks.json文件fs.writeFile(&quot;newBooks.json&quot;, result, &quot;utf-8&quot;, (error)=&gt;&#123; //监听错误，如正常输出，则打印null if(error == null)&#123; console.log(&quot;恭喜您，数据爬取成功!请打开json文件&quot;); &#125;&#125;) 这里我是获取豆瓣书本数据，一本书包含：标题、书本ID、评分、书本信息、书本封面、简介。 完整代码请参考：https://github.com/joydezhong/SimpleCrawler/blob/master/crawler.js","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/NodeJs/"}]},{"title":"JavaScript操作cookie","date":"2018-09-11T14:50:00.000Z","path":"2018/09/11/JavaScript操作cookie/","text":"Cookie是一些数据，用于存储页面的一些信息，存储在你电脑文本文件中，由于HTTP请求是无状态的，不会记录用户信息，Cookie有助于服务端获取用户信息，保存某种状态。 1.通过document.cookie创建 通过document对象的cookie创建cookie，并添加过期时间（默认浏览器关闭时删除），并添加cookie路径（默认属于当前页面） document.cookie=&quot;name=jode; expires=Thu, 18 Dec 2018 12:00:00 GMT; path=/&quot;; 通过document.cookie读取整个cookie，以字符串的方式返回，类似：cookie1=value;cookie2=value 修改cookie只需要重新设置，原来值将被覆盖，这样达到修改的目的。 删除cookie只需要把过期时间设置为当前时间之前，过期的cookie将删除。 2.JavaScript示例，设置cookie函数 参数 key: 设置cookie键名 val: 设置cookie值 exday: 过期时间、天 123456function setCookie(key, val, exday)&#123; var date = new Date(); date.setTime(date.getTime() + (exday*24*60*60*1000)); var expires = &#x27;expires=&#x27; + date.toGMTString(); document.cookie = key + &#x27;=&#x27; + val + &#x27;;&#x27; + expires;&#125; 3.JavaScript示例，获取cookie值函数 参数 key: cookie键名 12345678function getCookie(key)&#123; var name = key + &#x27;=&#x27;; var arr = document.cookie.split(&#x27;;&#x27;); for(var i = 0; i &lt; arr.length; i++)&#123; var cok = arr[i].trim(); if(cok.indexOf(name) == 0) return cok.substring(name.length, cok.length); &#125; return &#x27;&#x27;; 4.JavaScript示例，删除cookie值函数 参数 key: cookie键名 12345function delCookie(key)&#123; var date = new Date(); date.setTime(date.getTime()-1000); document.cookie = key + &quot;=v; expires =&quot; + date.toGMTString();&#125; 5.对比localStrong和sessionStrong | 特性 | Cookie | localStrong | sessionStrong | | -------- | ----- | ---- | | 数据的声明周期 | 一般由服务器生成，可设置失效时间。如果在浏览器生成，默认是关闭浏览器之后失效 | 除非被清楚，否则永久保存 | 仅在当前会话有效，关闭页面或浏览器后被清除 | | 存放数据大小 | 4KB | 一般5MB | 一般5MB | | 与服务端通信 | 每次都会携带在HTTP头中，如果使用 cookie 保存过多数据会带来性能问题 | 仅在客户端中保存，不参与和服务器的通信 | 同 localStorage | | 用途 | 一般由服务器端生成，用于标识用户身份 | 用于浏览器端缓存数据 | 同 localStorage |","tags":[{"name":"cookie","slug":"cookie","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/cookie/"}]},{"title":"JavaScript高阶函数","date":"2018-09-09T14:50:00.000Z","path":"2018/09/09/JavaScript高阶函数/","text":"JavaScript高阶函数实现更高效的封装，包括数据对象的枚举处理、排序、过滤，使我们写的代码更加高效简洁，结合ES6语法，在MV*框架编程中尤为明显。 1.map map在计科专业词汇中有“映射”的意思，顾名思义，传入一个函数对调用该方法的数据进行枚举处理。 参数 currentValue: callback 数组中正在处理的当前元素 index可选: callback 数组中正在处理的当前元素的索引 array可选: callback map方法被调用的数组 12345678910111213141516171819202122232425262728//对象Oject示例var infoObj=[&#123; name:&quot;二狗&quot;, sex:&#x27;female&#x27;, age:28 &#125;, &#123; name:&quot;二楞&quot;, sex:&#x27;male&#x27;, age:20 &#125;, &#123; name:&quot;牛二&quot;, sex:&#x27;female&#x27;, age:32 &#125;]; infoObj.map(function(item)&#123; console.log(item); // 结果输出每一项&#125;)//数组示例var arr = [1,3,8,9];// var newArr = arr.map(x=&gt;x*x);var newArr = arr.map(function(x)&#123; return x*x;&#125;);console.log(newArr); //[1,9,64,81] 2.reduce reduce()方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 参数 accumulator: 累加器累加回调的返回值；它是上一次调用回调时返回的累积值或初始的第一项。 currentValue: 数组中正在处理的元素 currentIndex可选: 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1 array可选: 调用reduce的数组 123456var arr = [1,3,8,9];// var newArr = arr.reduce((x,y) =&gt; x + y);var newArr = arr.reduce(function(x, y)&#123; return x + y;&#125;)console.log(newArr); // 21 3.filter filter()方法创建一个新数组，它用于把Array的某些元素过滤掉，然后返回剩下的元素 参数 currentValue: 数组中正在处理的元素 currentIndex可选: 数组中正在处理的当前元素的索引 array可选: 调用filter的数组 123456var arr = [1,3,6,8,9];//var newArr = arr.filter( x =&gt; x % 3 == 0);var newArr = arr.filter(function(x)&#123; return x % 3 == 0;&#125;)console.log(newArr); // [3,6,9] 4.sort sort()方法创建一个新的排序结果，包括正序，倒序，直接使用该方法可能会出错 参数 compareFunction可选: 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序 123// 出错示例console.log([10, 20, 1, 2].sort());// [1, 10, 2, 20] What? 上述示例让人丈二和尚，根据MDN web docs上一段描述：排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。 可以知道，sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。 123456789101112131415161718192021222324252627// 对象示例var infoObj=[ &#123; name:&quot;二狗&quot;, sex:&#x27;female&#x27;, age:28 &#125;, &#123; name:&quot;二楞&quot;, sex:&#x27;male&#x27;, age:20 &#125;, &#123; name:&quot;牛二&quot;, sex:&#x27;female&#x27;, age:32 &#125; ];var resultObj = infoObj.sort(function(a,b)&#123; return a[&#x27;age&#x27;] &lt; b[&#x27;age&#x27;] ? 1 : -1;&#125;);console.log(resultObj); // 结果按年龄倒序// 数组示例var arr = [10, 20, 1, 2];var newArr = arr.sort((x,y)=&gt;x&lt;y?1:-1);console.log(newArr); // [20, 10, 2, 1]","tags":[]},{"title":"JavaScript函数中的闭包","date":"2018-09-08T13:50:00.000Z","path":"2018/09/08/JavaScript函数中的闭包/","text":"闭包是JavaScript中的一大重点，也是难点（敲黑板）， 闭包简单的来说：定义在函数内部的函数。 内部函数作为返回值。 闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量，所以是能够读取其他函数内部变量的函数。 特点：能够读取函数内部的变量，变量始终保存在内存中。 接下来从上面三句话理解闭包： 1.闭包是一个“函数”，是定义在函数内部的一个函数，并作为返回值输出，示例中fn即为闭包。 12345678910function wrapFn()&#123; var name = &#x27;jode&#x27;; function insertFn()&#123; console.log(name); &#125; return insertFn;&#125;var fn = wrapFn();fn(); // &#x27;jode&#x27; 2.闭包是由函数以及创建该函数的词法环境组合而成 1234567891011function makeAdd(x)&#123; return function(y)&#123; return x + y; &#125;&#125;var fn1 = makeAdd(2);var fn2 = makeAdd(42);var res1 = fn(6);var res2 = fn(26);console.log(res1); // 8console.log(res1); // 68 这里我们定义了makeAdder(x)函数，它接受一个参数x，并返回一个新的函数。返回的函数接受一个参数y，并返回x+y的值。 从本质上讲，makeAdder是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和6求和，另一个和26求和。 fn1和fn2都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在fn1的环境中，x为5。而在fn2中，x则为10。 注意：返回函数不要引用任何循环变量或者后续会发生改变的变量 1234567891011121314151617function count()&#123; var arr = []; for(var i = 0; i &lt; 3; i++)&#123; arr.push(function()&#123; return i * i; &#125;) &#125; return arr;&#125;var fn = count();var f1 = fn[0];var f2 = fn[1];var f3 = fn[2];f1(); // 9f2(); // 9f3(); // 9 上面示例中，每次循环都追加一个函数到arr数组中，并返回数组，可结果并不是我们认为的0, 1, 4。 结果都是9，原因在于返回的函数引用了循环变量i，我们输出fn的其中一个项可以看到和push方法内部的函数一样，当f1保存count()返回的函数时，函数并没有执行，而是在f1()函数调用时 执行i * i的计算，而此时for循环完成i的值为3。","tags":[{"name":"闭包","slug":"闭包","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"vue表单","date":"2018-08-29T14:57:00.000Z","path":"2018/08/29/vue表单/","text":"vue中表单主要通过v-model实现数据的双向绑定，实现原理主要通过javascript的object.defineproperty方法。v-model会忽略所有表单元素的value、checked、selected特性的初始值而总是将Vue实例的数据作为数据来源。 一、input 1.1 一般的数据绑定，数据填充表单才会更新视图 1234&lt;div id=&quot;root&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;请输入&quot;&gt; &lt;p&gt;输入的内容是： &#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: &quot;#root&quot;, data: &#123; message: &#x27;&#x27; &#125;&#125;) 1.2 @input事件，同步输入法的输入，此时输入法输入什么，视图更新什么 1234&lt;div id=&quot;root&quot;&gt; &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; placeholder=&quot;请输入&quot;&gt; &lt;p&gt;输入的内容是： &#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011new Vue(&#123; el: &quot;#root&quot;, data: &#123; message: &#x27;&#x27; &#125;, methods: &#123; handleInput: function(e)&#123; this.message = e.target.value; &#125; &#125;&#125;) 二、radio 2.1 单个radio使用，只需要通过v-bind绑定checked属性值 12345&lt;div id=&quot;root&quot;&gt; &lt;label&gt;单个单选&lt;/label&gt; &lt;input type=&quot;radio&quot; :checked=&quot;picked&quot;&gt; &lt;p&gt;目前状态是： &#123;&#123;picked&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: &quot;#root&quot;, data: &#123; picked: true &#125;&#125;) 2.2 多个radio组合使用，需要借助v-model绑定相同的数据，当数据值和radio的value值相同，才会被选中 123456789&lt;div id=&quot;root&quot;&gt; &lt;label for=&quot;html&quot;&gt;HTML&lt;/label&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked1&quot; value=&quot;html&quot; id=&quot;html&quot;&gt; &lt;label for=&quot;js&quot;&gt;javascript&lt;/label&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked1&quot; value=&quot;js&quot; id=&quot;js&quot;&gt; &lt;label for=&quot;css&quot;&gt;css&lt;/label&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked1&quot; value=&quot;css&quot; id=&quot;css&quot;&gt; &lt;p&gt;输入的内容是： &#123;&#123;picked1&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: &quot;#root&quot;, data: &#123; picked1: &quot;js&quot; &#125;&#125;) 三、checkbox checkbox和radio也是分单个和组合使用，不同的是单个使用需要v-model绑定一个布尔值，多个使用绑定的是一个数组 3.1 单个checkbox使用，需要通过v-model绑定checked值 12345&lt;div id=&quot;root&quot;&gt; &lt;label&gt;单个复选&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;p&gt;目前状态是： &#123;&#123;checked&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: &quot;#root&quot;, data: &#123; checked: true &#125;&#125;) 3.2 多个checkbox组合使用，需要使用v-model绑定相同的数据，该数据为一个数组，当数组的值和checkbox的value值相同，才会被选中 123456789&lt;div id=&quot;root&quot;&gt; &lt;label for=&quot;html&quot;&gt;HTML&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked1&quot; value=&quot;html&quot; id=&quot;html&quot;&gt; &lt;label for=&quot;js&quot;&gt;javascript&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked1&quot; value=&quot;js&quot; id=&quot;js&quot;&gt; &lt;label for=&quot;css&quot;&gt;css&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked1&quot; value=&quot;css&quot; id=&quot;css&quot;&gt; &lt;p&gt;输入的内容是： &#123;&#123;checked1&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: &quot;#root&quot;, data: &#123; checked1: [&#x27;js&#x27;,&#x27;css&#x27;] &#125;&#125;) 四、selected selected也分单个选择和多项选择。 4.1 单个选择selected使用，需要通过v-model绑定selected值 123456789&lt;div id=&quot;root&quot;&gt; &lt;label&gt;单个选择&lt;/label&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;html&quot;&gt;HTML&lt;/option&gt; &lt;option value=&quot;js&quot;&gt;JS&lt;/option&gt; &lt;option value=&quot;css&quot;&gt;CSS&lt;/option&gt; &lt;/select&gt; &lt;p&gt;目前状态是： &#123;&#123;selected&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456 new Vue(&#123; el: &quot;#root&quot;, data: &#123; selected: &#x27;css&#x27;, &#125;&#125;) 4.2 多项选择selected使用，需要通过v-model绑定selected值，值为一个数组，当数组的值和selected的值匹配时，才会被选择 12345678910&lt;div id=&quot;root&quot;&gt; &lt;label&gt;多个选择&lt;/label&gt; &lt;select v-model=&quot;selected1&quot; multiple&gt; &lt;option value=&quot;html&quot;&gt;HTML&lt;/option&gt; &lt;option value=&quot;js&quot;&gt;JS&lt;/option&gt; &lt;option value=&quot;css&quot;&gt;CSS&lt;/option&gt; &lt;option value=&quot;vue&quot;&gt;VUE&lt;/option&gt; &lt;/select&gt; &lt;p&gt;目前状态是： &#123;&#123;selected1&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456 new Vue(&#123; el: &quot;#root&quot;, data: &#123; selected1: [&#x27;js&#x27;,&#x27;vue&#x27;] &#125;&#125;) 官方文档。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"vue数据data改变没有触发计算属性","date":"2018-08-28T14:26:00.000Z","path":"2018/08/28/vue数据data变化却没有触发计算属性/","text":"在用vue做购物车小案例时，vue实例中的data是写死的，只有三项数据，给每项加上全选反选，checkbox选择为true时统计价格，这里使用计算属性computed实现价格的统计。 checkbox状态通过一个数组绑定，改变状态即可与改变数组项的布尔值，操作中发现，勾选每一项时可以触发计算属性统计价格，但是勾选全选按钮时，并不能触发计算属性。 先看看例子： 1. HTML页面（index.html） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;vue购物车&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot; v-cloak&gt; &lt;template v-if=&quot;list.length&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checkAll&quot; @click=&quot;handleCheckAll&quot;&gt;&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品单价&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item, index) in list&quot;&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checkOne[index]&quot; @click=&quot;handleCheckOne(index)&quot; key=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.price &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;handleReduce(index)&quot; :disable=&quot;item.count===1&quot;&gt;-&lt;/button&gt; &#123;&#123; item.count &#125;&#125; &lt;button @click=&quot;handleAdd(index)&quot;&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;handleRemove(index)&quot;&gt;移除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div&gt;总价：￥ &#123;&#123;totalPrice&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;div v-else&gt;购物车为空&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/shop.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2. 定义js（shop.js） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [ &#123; id: 1, name: &#x27;iphone7&#x27;, price: 6188, count: 1 &#125;, &#123; id: 2, name: &#x27;iPad Pro&#x27;, price: 5888, count: 1 &#125;, &#123; id: 3, name: &#x27;MacBook Pro&#x27;, price: 21488, count: 1 &#125; ], checkAll: false, checkOne: [false,false,false] &#125;, computed: &#123; totalPrice: function()&#123; console.log(123); var total = 0; for(var i = 0; i &lt; this.checkOne.length; i++)&#123; if(this.checkOne[i])&#123; var item = this.list[i]; total += item.price * item.count; &#125; &#125; return total.toString().replace(/\\B(?=(\\d&#123;3&#125;)+$)/g, &#x27;,&#x27;); &#125; &#125;, methods: &#123; handleReduce: function(index)&#123; if(this.list[index].count === 1) return; this.list[index].count--; &#125;, handleAdd: function(index)&#123; this.list[index].count++; &#125;, handleRemove: function(index)&#123; this.list.splice(index, 1); &#125;, //全选 handleCheckAll: function()&#123; for(var i = 0; i &lt; this.checkOne.length; i++)&#123; // this.checkOne[i] = !this.checkAll; Vue.set( this.checkOne, i, !this.checkAll); &#125; &#125;, //单选 handleCheckOne: function(index)&#123; this.checkOne[index] = true; &#125; &#125;&#125;); 3. 定义css（style.css） 1234567891011121314151617181920[v-cloak]&#123; display: none;&#125;table&#123; border: 1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0; empty-cells: show;&#125;th,td&#123; padding: 8px 16px; border: 1px solid #e9e9e9; text-align: left;&#125;th&#123; background: #f7f7f7; color: #5c6b77; font-weight: 600; white-space: nowrap;&#125; 我们查看官方文档深入响应式原理的检测变化的注意事项有这样一段话： 受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。 简单理解为：受JavaScript语言本身限制，Vue不能够检测到对对象属性的变更。再看我这个小例子，全选函数handleCheckAll中对数组进行遍历赋值，也就是对数组的属性进行操作，此时vue是检测不到的，但是单选函数操作为什么是正常，有点小疑问？ 解决办法有两种，都按照下面的办法写才是标准的。 Vue.set(vm.someObject, 'b', 2)，将响应属性添加到嵌套的对象上；this.$set(this.someObject,'b',2)，这也是全局 Vue.set 方法的别名。 对应上面例子中的写法Vue.set( this.checkOne, i, !this.checkAll);。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/vue/"}]},{"title":"AngularJs之指令与控制器之间的交互","date":"2018-08-21T12:26:00.000Z","path":"2018/08/21/angluarjs之指令与控制器之间的交互/","text":"指令（directive）是AngularJS核心模块之一，可以实现很多强大的功能，那么指令和多控制器之间的交互是如何实现的呢？请花费两分钟阅读下文！ 站内文章“指令的三个阶段”中提到，大部分时候我们只需要编写link函数，其中包括DOM操作、时间绑定、函数调用等。 一、指令复用时调用控制器的方法 1. HTML 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;MyModule&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;MyCtrl&quot;&gt; &lt;loader howToLoad=&quot;loadData()&quot;&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;div ng-controller=&quot;MyCtrl2&quot;&gt; &lt;loader howToLoad=&quot;loadData2()&quot;&gt;滑动加载&lt;/loader&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/controller.js&quot; &gt;&lt;/script&gt;&lt;/html&gt; 这里定义angualrjs应用MyModule，在不同的控制器使用自定义指令loader，指令里面定义属性howToLoad，属性值为控制器里面函数的调用。 2. javascript 123456789101112131415161718192021222324var myModule = angular.module(&quot;MyModule&quot;, []);myModule.controller(&#x27;MyCtrl&#x27;,[&#x27;$scope&#x27;, function($scope)&#123; $scope.loadData = function()&#123; console.log(&quot;加载数据中...&quot;); &#125;;&#125;]);myModule.controller(&#x27;MyCtrl2&#x27;,[&#x27;$scope&#x27;, function($scope)&#123; $scope.loadData2 = function()&#123; console.log(&quot;加载数据中222...&quot;); &#125;;&#125;]);myModule.directive(&quot;loader&quot;,function()&#123; return &#123; restrict: &quot;AE&quot;, link: function(scope, element, attrs)&#123; element.bind(&quot;mouseenter&quot;, function(event)&#123; scope.$apply(attrs.howtoload); //转换成小写 &#125;) &#125; &#125;&#125;) 分别在不同的控制器定义不同函数，在指令的link函数中绑定鼠标事件，传入自定义指令的属性值，调用对应的函数。 3. 归纳： 自定义指令和多控制器交互，主要是通过复用指令时传入不同的属性值（不同的函数），在指令的link函数中调用实现的，注意link函数中取自定义属性会被转成小写。 二、指令与控制器之间的数据绑定 1. scope的三种绑定方式： 类型 描述 @ 把当前属性作为字符串传递。你还可以绑定来自外层scope的值，在属性值中插入&#123; &#123; &#125; &#125;即可 = 与父scope中的属性进行双向绑定 &amp; 传递一个来自父scope的函数，稍后调用 2. @绑定方式 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;MyModule&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/myController.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;&quot; ng-controller=&quot;MyCtrl&quot;&gt; &lt;drink flavor=&quot;&#123;&#123;ctrlFlavor&#125;&#125;&quot;&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819var myModule = angular.module(&quot;MyModule&quot;,[]);myModule.controller(&#x27;MyCtrl&#x27;, [&#x27;$scope&#x27;, function($scope)&#123; $scope.ctrlFlavor=&quot;百威&quot;;&#125;])myModule.directive(&quot;drink&quot;, function()&#123; return &#123; restrict: &#x27;AE&#x27;, scope: &#123; flavor: &#x27;@&#x27; &#125;, template: &quot;&lt;div&gt;&#123;&#123;flavor&#125;&#125;&lt;/div&gt;&quot;// ,// link: function(scope, element, attrs)&#123;// scope.flavor = attrs.flavor;// &#125; &#125;&#125;); 自定义指令的flavor属性值用&#123; &#123; &#125; &#125;表达式，给指令的scope绑定对应的@符号，可以代替link函数中的重新赋值。 3. =绑定方式 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;MyModule&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/myController.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;&quot; ng-controller=&quot;MyCtrl&quot;&gt; 控制器： &lt;br /&gt; &lt;input type=&quot;text&quot; ng-model=&quot;ctrlFlavor&quot; /&gt; &lt;br /&gt; 指令： &lt;br /&gt; &lt;drink flavor=&quot;ctrlFlavor&quot;&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415var myModule = angular.module(&quot;MyModule&quot;,[]);myModule.controller(&#x27;MyCtrl&#x27;, [&#x27;$scope&#x27;, function($scope)&#123; $scope.ctrlFlavor=&quot;百威&quot;;&#125;])myModule.directive(&quot;drink&quot;, function()&#123; return &#123; restrict: &#x27;AE&#x27;, scope: &#123; flavor: &#x27;=&#x27; &#125;, template: &#x27;&lt;input type=&quot;text&quot; ng-model=&quot;flavor&quot; /&gt;&#x27; &#125;&#125;); 控制器的input绑定控制器的ctrlFlavor数据，指令template的input绑定指令域的flavor属性，通过=符号实现数据的双向绑定。 4. &amp;绑定方式 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;MyModule&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/myController.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;&quot; ng-controller=&quot;MyCtrl&quot;&gt; &lt;greeting greet=&quot;sayHello(name)&quot;&gt;&lt;/greeting&gt; &lt;greeting greet=&quot;sayHello(name)&quot;&gt;&lt;/greeting&gt; &lt;greeting greet=&quot;sayHello(name)&quot;&gt;&lt;/greeting&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718var myModule = angular.module(&quot;MyModule&quot;,[]);myModule.controller(&#x27;MyCtrl&#x27;, [&#x27;$scope&#x27;, function($scope)&#123; $scope.sayHello = function(name)&#123; alert(&quot;Hello &quot;+name); &#125;;&#125;])myModule.directive(&quot;greeting&quot;, function()&#123; return &#123; restrict: &#x27;AE&#x27;, scope: &#123; greet: &#x27;&amp;&#x27; &#125;, template: &#x27;&lt;input type=&quot;text&quot; ng-model=&quot;userName&quot; /&gt;&#x27; + &#x27;&lt;button class=&quot;btn btn-default&quot; ng-click=&quot;greet(&#123;name:userName&#125;)&quot;&gt;问候&lt;/button&gt;&lt;br /&gt;&#x27; &#125;&#125;); 自定义指令的greet属性绑定了控制器的sayHello方法，传入name值，自定义指令中input绑定用户输入的数据userName，通过ng-click事件调用greet属性传过来的值。","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/angularJs/"}]},{"title":"AngularJs之指令的三个阶段","date":"2018-08-18T02:33:00.000Z","path":"2018/08/18/angluarjs之指令的三个阶段/","text":"AngularJS具有五大核心特性：MVC设计、模块化、指令系统、数据双向绑定、依赖注入。所以理解angualrjs指令是如何工作有利于深入理解angularjs。 1. 指令的加载阶段 此阶段加载anguale.js，查找ng-app，确定angularjs应用范围。 2. compile编译阶段 此阶段遍历DOM，查找所有的指令，保存到angularjs所指定的存储区中，根据指令中的template、replace、transclue转换DOM结构，如果存在compile函数则调用，一般不再compile做任何处理。 3. link编译阶段 此阶段对每一条指令运行link函数，link函数一般用来操作DOM，绑定事件监听器。 4. 归纳： compile函数用来对模板自身进行转换，而link函数负责在模型和视图之间进行动态关联； 作用域在链接阶段才会被绑定到编译之后的link函数上； compile函数仅仅在编译阶段运行一次，而对于指令的每个实例，link函数都会执行一次； compile可以返回preLink和postLink函数，而link函数只会返回postLink函数； 如果需要修改DOM结果，应该在postLink中来做这件事，而如果在preLink中做这件事会导致错误，大多数我们只需要编写link函数即可；","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/angularJs/"}]},{"title":"AngularJs之angular-ui-router","date":"2018-08-17T14:43:00.000Z","path":"2018/08/17/angluarjs之ui-router/","text":"AngularJS中提供ngRoute路由模块实现路由切换，在1.2+后的版本独立出来angular-router.js，但是在遇到路由深层次嵌套的情况下，该模块就力不从心，这时就需要angular-ui-router登场。 1. 目录结构 app文件夹为项目资源主文件夹 plugin为引入的框架和库文件夹 templates为各模板的文件夹 index.html项目启动主页 app.js为项目启动js文件 2. 主页index.html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;routerApp&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ui router&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;plugin/bootstrap.min.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;plugin/angular.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;plugin/angular-ui-router.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/app.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;navbar-brand&quot; ui-sref=&quot;#&quot;&gt;AngularUI Router&lt;/div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt; &lt;a ui-sref=&quot;home&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ui-sref=&quot;about&quot;&gt;About&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;div ui-view=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这里定义了一个angularjs应用ng-app=&quot;routerApp&quot;，定义了两个路由ui-sref=&quot;home&quot;、ui-sref=&quot;about&quot;，&lt;div ui-view=&quot;&quot;&gt;&lt;/div&gt;为路由显示容器。 3. 第一种方式路由home页home.html 1234567891011&lt;div class=&quot;jumbotron text-center&quot;&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;p&gt;This Page Demonstartes &lt;span class=&quot;text-denger&quot;&gt;nested&lt;/span&gt;views. &lt;/p&gt; &lt;a ui-sref=&quot;.list&quot; class=&quot;btn btn-primary&quot;&gt;List&lt;/a&gt; &lt;a ui-sref=&quot;.paragraph&quot; class=&quot;btn btn-danger&quot;&gt;Paragraph&lt;/a&gt;&lt;/div&gt;&lt;div ui-view&gt; &lt;/div&gt; 这里定义了两个二级路由ui-sref=&quot;.list&quot;、ui-sref=&quot;.paragraph&quot;，&lt;div ui-view&gt;&lt;/div&gt;为路由显示容器。 4. 二级路由.list页home-list.html 12345&lt;ul&gt; &lt;li ng-repeat=&quot;topic in topics&quot;&gt; &#123;&#123;topic&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 5. 第二种方式路由视图about页about.html 123456789101112131415&lt;div class=&quot;jumbotron text-center&quot;&gt; &lt;h1&gt;The About Page&lt;/h1&gt; &lt;p&gt;This Page demonstrates &lt;span class=&quot;text-danger&quot;&gt;multiple&lt;/span&gt; &lt;span class=&quot;text-danger&quot;&gt;named&lt;/span&gt;views. &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;div ui-view=&quot;columnOne&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;div ui-view=&quot;columnTwo&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这里定义了两个视图块ui-view=&quot;columnOne&quot;、ui-view=&quot;columnTwo&quot;，来显示不同的模板。 6. 二级路由视图columnTwo@about页table-data.html 123456789101112131415&lt;h2&gt;Ice-Creams&lt;/h2&gt;&lt;table class=&quot;table table-hover table-striped table-bordered&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Cost&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=&quot;topic in topics&quot;&gt; &lt;td&gt;&#123;&#123;topic.name&#125;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&#123;topic.price&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 7. 设置app.js，定义angualrjs模块，路由状态管理，控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var routerApp = angular.module(&#x27;routerApp&#x27;, [&#x27;ui.router&#x27;]);routerApp.config([&#x27;$stateProvider&#x27;, &#x27;$urlRouterProvider&#x27;, function($stateProvider, $urlRouterProvider)&#123; $urlRouterProvider.otherwise(&#x27;/home&#x27;); $stateProvider.state(&#x27;home&#x27;,&#123; url: &#x27;/home&#x27;, templateUrl: &#x27;templates/home.html&#x27; &#125;).state(&#x27;home.list&#x27;,&#123; url: &#x27;/list&#x27;, templateUrl: &#x27;templates/home-list.html&#x27;, controller: function($scope)&#123; $scope.topics = [&#x27;Butterscotch&#x27;, &#x27;Black Current&#x27;, &#x27;Mango&#x27;]; &#125; &#125;).state(&#x27;home.paragraph&#x27;, &#123; url: &#x27;/paragraph&#x27;, template: &#x27;666，paragraph页面&#x27; &#125;).state(&#x27;about&#x27;,&#123; //多个ui-view的情况 url: &#x27;/about&#x27;, views: &#123; //，没有指定view &#x27;&#x27;: &#123; templateUrl: &#x27;templates/about.html&#x27; &#125;, // ui-view=&#x27;colnumOne&#x27; &#x27;columnOne@about&#x27;: &#123; template: &#x27;这里是第一列的内容&#x27; &#125;, // ui-view=&#x27;columnTwo&#x27; &#x27;columnTwo@about&#x27;: &#123; templateUrl: &#x27;templates/table-data.html&#x27;, controller: &#x27;table-Controller&#x27; &#125; &#125; &#125;)&#125;]);routerApp.controller(&#x27;table-Controller&#x27;, function($scope)&#123; $scope.message = &#x27;test&#x27;; $scope.topics = [&#123; name: &#x27;Butterscotch&#x27;, price: 50 &#125;, &#123; name: &#x27;Black Current&#x27;, price: 100 &#125;, &#123; name: &#x27;Mango&#x27;, price: 20 &#125;];&#125;); 在angularjs主模块注入ui.router依赖，在模块配置中配置$stateProvider、$urlRouterProvider用于状态管理和url管理的服务，当没有路由匹配时执行$urlRouterProvider.otherwise('/home');，在state()方法第一个参数用.表示二级路由；当涉及多个ui-view时使用childName@parentName子视图名+@+父级路由名方式定义视图。再配合angular-animate可以实现丰富的切换效果和复杂的路由效果。","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/angularJs/"}]},{"title":"AngularJs之模块化","date":"2018-08-12T12:53:00.000Z","path":"2018/08/12/angluarjs之模块化/","text":"AngularJS中可以通过angular.module函数来创建，在第二个参数中可以注入不用的模块，当一个应用程序多人协同开发时，这种需要体现的尤为明显。AngularJS推荐使用angular.module来定义不同模块。 1. 初始化主模块 12345678910111213141516var bookStoreApp = angular.module(&#x27;bookStoreApp&#x27;, [ &#x27;ngRoute&#x27;, &#x27;ngAnimate&#x27;, &#x27;bookStoreCtrls&#x27;, &#x27;bookStoreFilters&#x27;, &#x27;bookStoreServices&#x27;, &#x27;bookStoreDirectives&#x27;]);bookStoreApp.config(function($routeProvider) &#123; $routeProvider.when(&#x27;/hello&#x27;, &#123; templateUrl: &#x27;tpls/hello.html&#x27;, controller: &#x27;HelloCtrl&#x27; &#125;).when(&#x27;/list&#x27;,&#123; templateUrl:&#x27;tpls/bookList.html&#x27;, controller:&#x27;BookListCtrl&#x27; &#125;).otherwise(&#123; redirectTo: &#x27;/hello&#x27; &#125;)&#125;); 2. 定义子模块bookStoreServices（新建services.js，与app.js同目录） 123456789var bookStoreServices = angular.module(&#x27;bookStoreServices&#x27;, []);bookStoreServices.service(&#x27;bookStoreService_1&#x27;, [&#x27;$scope&#x27;, function($scope) &#123;&#125;]);bookStoreServices.service(&#x27;bookStoreService_2&#x27;, [&#x27;$scope&#x27;, function($scope) &#123;&#125;]); 3. 定义子模块bookStoreDirectives（新建directives.js，与app.js同目录） 123456789var bookStoreDirectives = angular.module(&#x27;bookStoreDirectives&#x27;, []);bookStoreDirectives.directive(&#x27;bookStoreDirective_1&#x27;, [&#x27;$scope&#x27;, function($scope) &#123;&#125;]);bookStoreDirectives.directive(&#x27;bookStoreDirective_2&#x27;, [&#x27;$scope&#x27;, function($scope) &#123;&#125;]); 其他模块的定义方式同理，这样更好地实现了不同模块的独立开发，然后在主模块中注入，实现应用程序的聚合。","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/angularJs/"}]},{"title":"Angularjs实现tab选项卡","date":"2018-08-11T13:23:00.000Z","path":"2018/08/11/angluarjs和tab选项卡的冲突/","text":"Angularjs中页面的切换通过Router路由也就是锚点，而大部分的tab选项卡插件切换效果也是利用锚点，这与angualrjs中的router有冲突，为了更好地在angularjs应用实现tab选项卡功能，我们利用angularjs全局作用域$rootScope、ng-class、ng-click和ng-if实现这个效果，这里使用的是mdui。 1. HTML页面 12345678910111213141516171819&lt;!--省略--&gt;&lt;body ng-app=&#x27;routingDemoApp&#x27;&gt; &lt;div class=&#x27;container&#x27;&gt; &lt;div class=&quot;mdui-row&quot;&gt; &lt;div class=&quot;mdui-tab&quot; mdui-tab&gt; &lt;a ng-class=&quot;&#123;&#x27;active&#x27;:data.current==1&#125;&quot; ng-click=&quot;actions.setCurrent(1, $event)&quot; class=&quot;mdui-ripple mdui-tab-active&quot;&gt;tab标签一&lt;/a&gt; &lt;a ng-class=&quot;&#123;&#x27;active&#x27;:data.current==2&#125;&quot; ng-click=&quot;actions.setCurrent(2, $event)&quot; class=&quot;mdui-ripple&quot;&gt;tab标签二&lt;/a&gt; &lt;/div&gt; &lt;div ng-if=&quot;data.current==1&quot; class=&quot;mdui-p-a-2&quot;&gt; &lt;p&gt;标签一内容&lt;/p&gt; &lt;/div&gt; &lt;div ng-if=&quot;data.current==2&quot; class=&quot;mdui-p-a-2&quot;&gt; &lt;p&gt;标签二内容&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;!--省略--&gt; 2. 定义控制器 123456789101112DoubanApp.controller(&#x27;IndexController&#x27;, [&#x27;$scope&#x27;, &#x27;$http&#x27;, &#x27;$rootScope&#x27;, function ($scope, $http, $rootScope) &#123; //选项卡的切换 $rootScope.data = &#123; current:&quot;1&quot; &#125;; $rootScope.actions = &#123; setCurrent:function(param, $event)&#123; $($event.target).addClass(&#x27;mdui-tab-active&#x27;).siblings().removeClass(&#x27;mdui-tab-active&#x27;); $rootScope.data.current = param; &#125; &#125;;&#125;]); 通过在全局作用内声明标识变量和标识变量更改函数，在函数里面修改标识变量和对应的class，给tab标签绑定ng-click和ng-class事件，用于传入对应的参数更改全局变量和改变对应的class样式，给相应的内容区块绑定ng-if，用过判断全局标识来显示或隐藏。","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/angularJs/"}]},{"title":"Jquery 克隆input元素有值却不显示","date":"2018-08-06T12:40:00.000Z","path":"2018/08/06/clone元素input有值却不显示/","text":"在做用户自定义表单时，使用到clone()方法对初始的DOM元素克隆，添加ture可以实现深度克隆，追加完DOM后发现input中的值并没有克隆过去，于是查看HTML和Jquery的DOM元素，发现HTML元素上有value属性也有相应的值，在Jquery对象里面value属性是没有值，但是有个defaultVale有value的值，貌似有点怪异，一般涉及到有值无值特别是select和radio问题，首先想到prop()和attr()的影响，详见站内文章。 解决办法 获取需要的值，重新赋值一遍。 $(cloneElement).find(&quot;.condition-input&quot;).val(originVal);","tags":[{"name":"jquery","slug":"jquery","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/jquery/"}]},{"title":"Express中的中间件Middleware","date":"2018-07-20T12:40:00.000Z","path":"2018/07/20/express中间件/","text":"做nodejs开发离不开Express的引用，通过Express可以更加简单的实现客户端的请求和服务端的响应，原因在于Express在Node.js的HTTP模块上添加了一个中间件，那么，所谓的中间件是什么呢？ 以下是一些浅显的理解： 中间件可以看做是处理HTTP请求的一种封装，也可以理解为一个函数，可以通过某个对象调用，它有三个参数：请求对象req、响应对象res、next函数。 中间件是在管道pipe中执行的，了解Linux的小伙伴应该知道管道运算机制，数据从首端流入，末端流出，数据可以在注入端向下传递，这里面套路很深，就不做过多扩展了。在Express中，通过调用 app.use向管道中注入中间件。 在管道的最后，通常放一个“捕获一切”的处理请求，由它来处理所有跟前面都不匹配的路由请求，这个中间件一般返回状态码“404”。如果该中间件函数没有传入next函数，不调用next函数，请求就在 当前所在的中间件终止了。 我们需要灵活运用中间件和路由处理器，需要知道Express几个关键之处： 路由处理器：app.get、app.post等，统称为app.verb，这也是中间件的一种，只处理特定方式的HTTP请求，路由处理器的第一个参数必须是路径，如果想匹配所有路径，只需用/*。 路由处理器和中间件的参数中，都有回调函数，参数个数不固定，通常是2个、3个或4个。常用的2个或3个参数，第一个是网络请求req，第二个是响应对象res，第三个是next()函数。 如果是4个参数，它就变成了错误处理中间件，第一个参数变成了错误对象，然后依次是上面的三个。 如果不调用next()函数，管道就会被终止，也不会再有处理器或中间件的后续处理。如果不调用next()函数，则应该发送一个响应给客户端，常用的有三种格式：res.send、res.json、res.sender等。如果不这样做，客户端就会被挂起，并最终导致超时。 如果调用了next()函数，一般不宜再发送响应给客户端，这是因为如果发送了响应，管道中的后续中间件或处理器还会执行，但它们发送的任何响应都会被忽略。 简单来说，中间件（Middleware）就是处理HTTP请求的函数，它的最大特点是，一个中间件处理完，再传给下一个中间件，应用程序在运行过程中，会调用一系列的中间件。如下是一个中间件。 1234function funMiddleware(req, res, next)&#123; //... next();&#125; 每个中间件可以从APP实例中接受三个参数，依次是：request对象（HTTP请求）、response对象（HTTP响应）、next函数（表示下一个中间件）。每个中间件都可以对HTTP请求进行判断，从而决定是否进入下一级， 将request对象传给下一个中间件，参数中的next就是这个意思。 下面举个例子： 123456789101112app.use(function(req, res, next)&#123; console.log(&#x27;processing request for &#x27;+ req.url); next();&#125;)app.use(funciton(req, res, next)&#123; console.log(&#x27;terming request&#x27;); res.send(&#x27;thinks for playing!&#x27;); //这里没有调用next()，请求终止&#125;)app.use(function(res, req, next)&#123; console.log(&#x27;I never get called!&#x27;);&#125;) 这里用到三个中间件：第一个中间件只是输出一个log信息，并把请求传给了下一个中间件；第二个中间件真正的处理请求，注意，如果忽略res.send()，客户端就会被挂起，导致客户端等待超时；第三个中间件永远也不会执行，应为所以请求在上一个中间件终止了。","tags":[]},{"title":"项目git push之后删除node_modules文件夹","date":"2018-07-18T13:40:00.000Z","path":"2018/07/18/git上传后删除仓库中的文件/","text":"在做Demo时没来得及设置.gitignore文件，把node_modules也push上去了，取他山之玉，攻自山之石。 1、先新建.gitignore文件，设置忽略文件。 windows系统下用记事本新建文件，写入忽略文件，另存为所有文件(.)格式，更改文件名为.gitignore即可。 2、在命令行进入仓库目录，删除github仓库上.gitignore上新加的选项 git rm -r --cached . 3、然后重新添加要提交的选项 git add . 4、接着commit，简要说明一下commit的内容 git commit -m “remove node_modules” 5、最后在git push 到远程仓库上就可以了 git push","tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Git/"}]},{"title":"AngularJs项目之ngMock","date":"2018-07-03T14:30:00.000Z","path":"2018/07/03/angluarjs之ngMock/","text":"数据模拟在项目前后端分离时尤为重要，再也不用找后端加测试数据，再也不用等后端写完接口在对接功能。利用数据模拟，在敲定Api设计和数据格式后即可开展项目开发。一般的项目直接引入mock.js库即可模拟接口数据，简单粗暴，但是在angularJs项目中直接引入是行不通的，因为它有自带的测试工具angular-mock，遗憾的是angular-mock`不支持mock语法，注意：工具的版本要和angularjs版本一致，不然会报错。更多详细配置见官方文档。 1. HTML页面（index.html）和工具引入 1234567891011&lt;!--省略--&gt;&lt;body ng-app=&#x27;routingDemoApp&#x27;&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.5.8/angular.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.5.8/angular-route.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/angular-mocks/1.5.8/angular-mocks.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/Scritps/router.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/Scripts/controller.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/Scritps/devMock.js&quot;&gt;&lt;/script&gt;&lt;!--省略--&gt; 2. 定义路由（router.js） 12345678910111213var routingDemoApp = angular.module(&#x27;routingDemoApp&#x27;, [&#x27;ngRoute&#x27;, &#x27;ngMockE2E&#x27;]);routingDemoApp.config([&#x27;$routeProvider&#x27;, function ($routeProvider) &#123; $routeProvider $routeProvider.when(&#x27;/&#x27;, &#123; templateUrl: &#x27;/Home/Index&#x27;, controller: &#x27;IndexController&#x27;, &#125;) $routeProvider.when(&#x27;/About&#x27;, &#123; templateUrl: &#x27;/Home/About&#x27;, controller: &#x27;AboutController&#x27;, &#125;) //......&#125;]); 定义一个module，引入ngRoute、ngMockE2E作为主应用的依赖模块，配置路由的视图和控制器。 3. 定义mock（devMock.js） 12345678910111213141516171819202122232425262728293031323334353637routingDemoApp.run([&#x27;$httpBackend&#x27;, function ($httpBackend) &#123; var users = &#123; &quot;code&quot;: 1, &quot;data&quot;: [&#123; &quot;UserID&quot;: 1, &quot;UserName&quot;: &quot;小红&quot;, &quot;MaxDevice&quot;: 10, &quot;Remark&quot;: &quot;...&quot;, &quot;DeviceNum&quot;: 5, &quot;ScriptName&quot;: &quot;脚本1&quot; &#125;, &#123; &quot;UserID&quot;: 2, &quot;UserName&quot;: &quot;小名&quot;, &quot;MaxDevice&quot;: 20, &quot;Remark&quot;: &quot;...&quot;, &quot;DeviceNum&quot;: 8, &quot;ScriptName&quot;: &quot;脚本2&quot; &#125;, &#123; &quot;UserID&quot;: 3, &quot;UserName&quot;: &quot;小康&quot;, &quot;MaxDevice&quot;: 45, &quot;Remark&quot;: &quot;...&quot;, &quot;DeviceNum&quot;: 20, &quot;ScriptName&quot;: &quot;脚本3&quot; &#125;], &quot;pageCount&quot;: 1, &quot;Count&quot;: 3 &#125;; //mock拦截排除的资源和目录 $httpBackend.whenGET(/\\/View\\/*/).passThrough(); $httpBackend.whenGET(/ *.js/).passThrough(); $httpBackend.whenGET(/ *.css/).passThrough(); $httpBackend.whenGET(/ *.jpg/).passThrough(); //用户列表api $httpBackend.whenPOST(&quot;/api/GetUser&quot;, &#123; token: &quot;&quot;, pindex: 1, pagesize: 999 &#125;).respond(200, users);&#125;]) 4. 定义Index控制器（controller.js） 1234567routingDemoApp.controller(&#x27;IndexController&#x27;, [&#x27;$scope&#x27;, &#x27;$http&#x27;, &#x27;$location&#x27;, function ($scope, $http, $location) &#123; $http.post(&quot;/api/GetUser&quot;,&#123; token: &quot;&quot;, pindex: 1, pagesize: 999 &#125;).then(function(json)&#123; console.log(json.data); &#125;,function(err)&#123; console.log(err); &#125;);&#125;]) 只要模块引入正确，路由配置正确，mock书写正确，数据分分钟console.log，接下来你可以独立开发angularJs项目了。","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/AngularJS/"}]},{"title":"前端开发数据模拟那些事","date":"2018-07-03T13:51:00.000Z","path":"2018/07/03/前端开发中模拟数据/","text":"Long long ago，前端在项目开发中都是作为辅助的角色，在.NET、Java尤为明显，.NET有其自己的一套MVC开发架构，Java有JSP支持前端开发，但是这样开发代码冗余量大，不利于软件开发“高内聚、低耦合”的原则，项目升级维护起来困难，因此出现类型前端MVC开发框架，前后端分离成为常态，既相互独立，又有一定的联系，这种联系仅体现在数据交互方面。前端开发时模拟后台返回的数据，开发时相互独立，生产时以数据为纽带紧密联系在一起。下文聊聊前端开发数据模拟的常见类型： 1. 懵逼版 123456789101112131415161718192021222324function randerList()&#123; //...&#125;var isDev = true;var data = &#123; &quot;code&quot;: 1, &quot;count&quot;: 1, &quot;data&quot;: &#123; &quot;userid&quot;: 1, &quot;username&quot;: &quot;lina&quot;, &quot;age&quot;: 25, &quot;sex&quot;: 0 &#125;&#125;;if(isDev)&#123; randerList(data);&#125;else&#123; $.get(&quot;/userlist&quot;,function(json)&#123; randerList(json.data); &#125;)&#125; 这段代码我看的懵逼了一下，其实就是通过一个boolean标识，来判断到底是执行传入了静态数据的函数还是执行传入动态数据的函数，如果整个项目一直这样下去，相信大佬的你到后面也会懵逼。 2. 入门版 在项目下新建一个json文件，此处叫data.json。 1234567891011//data.json&#123; &quot;code&quot;: 1, &quot;count&quot;: 1, &quot;data&quot;: &#123; &quot;userid&quot;: 1, &quot;username&quot;: &quot;lina&quot;, &quot;age&quot;: 25, &quot;sex&quot;: 0 &#125;&#125; ajax请求获取json文件。 12345678$.ajax(&#123; url: &#x27;data.json&#x27;, type: &#x27;GET&#x27;, dataType: &#x27;json&#x27;, success: function(json) &#123; console.log(json); &#125;&#125;); 这种比上面那种看起来更加清晰，对接时修改url即可，但是和上面的有个共同点，数据不够灵活，如果需要判断状态码status|code时，弊端显而易见。 3. 升级版 使用Mock.js，一个模拟数据和编写自动化测试的库，生成随机数据，拦截Ajax请求。 引入工具库和模拟js文件。 1234&lt;!--引入工具库和模拟js文件--&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/Mock.js/1.0.0/mock.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;devData.js&quot; &gt;&lt;/script&gt; 配置mock数据，mock语法规范自行参考官方文档。 12//配置mockMock.mock(&#x27;/api/getName&#x27;, &#123; name: &#x27;Jack&#x27;, &#x27;age|10-20&#x27;: 10 &#125;); ajax请求数据 12345678910$.ajax(&#123; type: &#x27;GET&#x27;, url: &#x27;/api/getName&#x27;, dataType: &#x27;json&#x27;, success: function(data) &#123; console.log(data); &#125;&#125;);//打印数据：&#123;name: &quot;Jack&quot;, age: 13&#125; 当我们对接后台时只需要把引入mock.js和devData.js删除即可，贼带劲！","tags":[]},{"title":"myeclipse2016控制台和浏览器调试项目乱码","date":"2018-06-26T14:20:00.000Z","path":"2018/06/26/myeclipse乱码/","text":"由于旧版myeclipse主题不可以全套更改，于是安装了2016版本，再启动java项目时发现控制台打印乱码，浏览预览乱码，码可以乱，但是心不可以乱，于是搜罗各种答案。发现是Tomcat编码设置问题和IDE自带的一些小工具的影响。 首先控制台乱码是因为Tomcat服务器编码问题。 点击Run–&gt;Run Configurations进入下图界面： 然后进入Arguments项，在VM arguments里面加入：-Dfile.encoding=&quot;UTF-8&quot;(注意-前面的空格)，点击apply即可 浏览器显示乱码问题。 在myeclipse 2016 CI 3版本中，在servers、console工具栏有个小眼睛的功能live preview，只需要把他关闭即可。 在myeclipse 2016 CI 4版本中，Live Preview改名为CodeView，开启后访问项目会显示一个面板，目前还没使用这些功能，详见官文https://www.genuitec.com/tech/live-preview/。","tags":[]},{"title":"web常用的chrome扩展","date":"2018-06-22T14:40:00.000Z","path":"2018/06/22/web常用的chrome扩展/","text":"chrome扩展可以帮助我们更加方便的开发调试web项目，下面介绍几个常用插件。 1. Window Resizer 整浏览器窗口的大小以模拟不同的屏幕分辨率，包括PC端和移动端或者自定义分辨率。 2. Library Sniffer for Google Chrome 探测当前网页所使用的类库、框架和服务器环境，为开发者提供了方便。相比之下，貌似下面这个检测更全面。 3. WhatRuns 发现一个网站使用什么框架、分析工具、Wordpress插件、字体-你可以更好的了解它。 4. Tabbed Postman - REST Client 客户端代理调试API的工具，有个软件叫Postman，这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！ 5. jQuery Audit jQuery Audit是让你可以在DevTools查看页面节点的jQuery属性和数据，方便你调试使用jQuery库的web应用。你可以在上面看到你选中的页面元素的jQuery的events、data等属性。 6. AngularJS Inspector 扩展开发人员工具，添加用于调试和分析AngularJS应用程序的工具。基于AngularJS Batarang。 7. EditThisCookie EditThisCookie是一个cookie管理器。您可以添加，删除，编辑，搜索，锁定和屏蔽cookies！ 8. 谷歌访问助手 最简单易用的谷歌访问助手,为chrome扩展用户量身打造。可以解决chrome扩展无法自动更新的问题，同时可以访问谷歌google搜索，gmail邮箱。","tags":[]},{"title":"angularjs页面数据无法渲染","date":"2018-06-20T13:40:00.000Z","path":"2018/06/20/angularjs无法渲染页面数据/","text":"做angularJs相关项目时，发现绑定在页面上的数据渲染有问题，部分代码如下： 12345678910111213141516171819202122232425262728routingDemoApp.controller(&#x27;CloudService&#x27;, [&#x27;$scope&#x27;, &#x27;$http&#x27;, &#x27;$location&#x27;, function ($scope, $http, $location) &#123; //加载项目列表 $http(&#123; method: &#x27;post&#x27;, url: &#x27;/api/getlist&#x27;, data: &#123; token: token, data1: val1 &#125; &#125;).then(function (json) &#123; var json = json.data; $scope.pnamedata = json.data; ...... &#125;, function (json) &#123; //失败时执行 ... &#125;); $.post(&quot;/api/getlist&quot;, &#123; token: token, data1: val1 &#125;, function (json) &#123; $scope.pnamedata = json.data; ...... $scope.$apply(); &#125;) $scope.addCloudUser = function () &#123; $(&quot;#addUserModal&quot;).modal(&#x27;show&#x27;); &#125;; &#125;]) 当页面触发addCloudUser函数时，页面数据$scope.pnamedata才会渲染，并不是页面加载时渲染数据。我们先排除页面路由的控制器配置是否正确，页面控制器是否注入$scope等依赖部件。 通过搜罗发现，是AngularJs的$http和jquery的ajax混用导致，在AngularJS中使用了ajax请求数据时，AngularJS是监听不到的，解决办法有两种：一是通过$scope.$apply();强制渲染一下； 二是使用AngularJs自带的http模块$http，用法和jquery的ajax差不多，具体代码如上。","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/AngularJS/"}]},{"title":"$.post()、$.get()捕获异常和异步更改","date":"2018-06-13T13:16:00.000Z","path":"2018/06/13/$.post()$.get异常捕获和异步更改/","text":"我们在用Jquery进行项目开发时，对接后台用到最多的方式就是$.post()、$.get()，但参数只有3个：请求URL、传递参数、成功后事件，当我们需要对请求进行异步更改或者异常捕获时，但又不想重新封装$.ajax()方法时，可以这样写：$.post(…).error(function()&#123;…&#125;);，当地址返回404、500等异常时，会执行error里面的代码。 例如下面的写法： 123456789101112131415var jqxhr = $.post(&quot;/api/getLists&quot;, &#123; code: code &#125;, function() &#123; alert(&quot;success&quot;); //成功回调&#125;).success(function() &#123; alert(&quot;second success&quot;); //成功回调第二个方法&#125;).error(function() &#123; alert(&quot;error&quot;); //异常回调（ex:500、404）&#125;).complete(function() &#123; alert(&quot;complete&quot;); //完成调用事件（完成后最终执行）&#125;); // 在这里执行其他任务.// 为上面的请求设置另一个完成函数.jqxhr.complete(function()&#123; alert(&quot;second complete&quot;);&#125;); 当我们需要设置$.post()、$.get()方法同步请求时，而又不想使用$.ajax()重写，可以如下设置： 12345$.ajaxSettings.async = false; $.post(&quot;/finance/getLastTimeCard&quot;, data, function(result) &#123; // 请求处理 &#125;); $.ajaxSettings.async = true; 在请求之前把jquery的ajax方法设置为同步，执行完成后复原。","tags":[]},{"title":"服务端口被占用的处理办法","date":"2018-06-08T13:40:00.000Z","path":"2018/06/08/服务端口被占用/","text":"我们在启动服务应用或者node.js应用时，经常会出现listen EADDRINUSE :::8000这样的错误，这是因为8000端口被占用的问题，下面我们来看看如何用终端解决，前提都在CMD终端完成。 1.查看所有端口使用情况 在终端界面执行C:\\Users\\User&gt; netstat -ano 查看所有的端口使用情况。 2.查看指定端口的占用情况 在终端界面执行C:\\Users\\User&gt; netstat -ano|findstr &quot;8000&quot; 查看指定端口的占用情况。 显示顺序依次是：协议、本地地址、外部地址、状态、PID。 3.查看指定PID对应的进程 在终端界面执行C:\\Users\\User&gt; tasklist|findstr &quot;8000&quot; 查看指定指定PID对应的应用。 显示顺序依次是：映像名称、PID 会话名、会话、内存使用。 3.终止对应的进程 在终端界面执行C:\\Users\\User&gt; taskkill /f /t /im node.exe 查看终止结果。","tags":[]},{"title":"Js文件下载操作","date":"2018-05-30T13:20:00.000Z","path":"2018/05/30/js文件下载操作/","text":"在做后台web后台开发时，遇到一些表格数据需要导出相应的文件，这就需要js做文件下载操作，通常后台会返回一个文件的链接。 1. 通常模式 通常情况下我们获取到后台返回的文件url打开即可下载文件，可是兼容问题让人脑阔痛。 12345678//该方法在火狐上没有效果的，在IE浏览器上是可以的window.open(&quot;fileUrl&quot;);//该方法火狐有些版本是不支持的window.location.href=&quot;fileUrl&quot;;//为了解决火狐有些版本不支持,可以改成这种方式window.location=&quot;fileUrl&quot;; 2. 封装模式 通过内嵌iframe访问下载 123456789101112//该方法IE和火狐都可以，//fileUrl表示要下载的文件路径function downloadFile(fileUrl) &#123; try&#123; var elemIF = document.createElement(&quot;iframe&quot;); elemIF.src = fileUrl; elemIF.style.display = &quot;none&quot;; document.body.appendChild(elemIF); &#125;catch(e)&#123; alert(&quot;下载异常！&quot;); &#125; &#125; 通过创建form表单GET提交下载 1234567891011//表单方式直接下载文件//fileUrl表示要下载的文件路径,如:htpp://127.0.0.1/test.rarfunction downloadFile(fileUrl)&#123; var form=$(&quot;&lt;form&gt;&quot;);//定义form表单,通过表单发送请求 form.attr(&quot;style&quot;,&quot;display:none&quot;);//设置为不显示 form.attr(&quot;target&quot;,&quot;&quot;); form.attr(&quot;method&quot;,&quot;get&quot;);//设置请求类型 form.attr(&quot;action&quot;,fileUrl);//设置请求路径 $(&quot;body&quot;).append(form);//添加表单到页面(body)中 form.submit();//表单提交&#125; 通过创建form表单POST提交下载 123456789101112131415161718192021222324252627//fileUrl表示请求路径,进入后台处理,后台返回一个文件流function downloadFile(fileUrl)&#123; //定义一个form表单,通过form表单来发送请求 var form=$(&quot;&lt;form&gt;&quot;); //设置表单状态为不显示 form.attr(&quot;style&quot;,&quot;display:none&quot;); //method属性设置请求类型为post form.attr(&quot;method&quot;,&quot;post&quot;); //action属性设置请求路径, //请求类型是post时,路径后面跟参数的方式不可用 //可以通过表单中的input来传递参数 form.attr(&quot;action&quot;,fileUrl); $(&quot;body&quot;).append(form);//将表单放置在web中 //在表单中添加input标签来传递参数 //如有多个参数可添加多个input标签 var input1=$(&quot;&lt;input&gt;&quot;); input1.attr(&quot;type&quot;,&quot;hidden&quot;);//设置为隐藏域 input1.attr(&quot;name&quot;,&quot;id&quot;);//设置参数名称 input1.attr(&quot;value&quot;,&quot;123&quot;);//设置参数值 form.append(input1);//添加到表单中 form.submit();//表单提交&#125;","tags":[]},{"title":"Express实现登录页面","date":"2018-05-28T14:40:00.000Z","path":"2018/05/28/Express实现登录页面/","text":"最近在看MEAN（MongoDB+Express+AngularJS+Node.js）类的书籍，通过Node.js+Express实现一个简单的登录页面。 1. 在node.js项目下安装依赖 12345678910111213//package.json&#123; &quot;name&quot;: &quot;express_login&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;body-parser&quot;: &quot;~1.8.1&quot;, &quot;express&quot;: &quot;~4.9.0&quot; &#125;&#125; Express中获取网络请求参数的方法 在浏览器中经常会看到两类访问方式，一种是带问号，另一种是不带问号的。如：http://localhost:3000?user=jode&amp;age=18或者http://localhost:3000/user/:name。 req.params属于不带问号类型，如：http://localhost:3000/user/jode，通过req.params.name可以获取参数name值。 req.query属于带问号类型，不需要中间件，直接查询对应的参数，如：http://localhost:3000?user=jode&amp;age=18，通过req.query.user可以获取参数user值。 req.body需要引入body-parser中间件，此方法通常用于POST中的参数，如：http://localhost:3000?user=jode&amp;age=18，通过req.query.user可以获取参数user值。 在终端输入npm install完成安装。 2. 创建服务文件 123456789101112131415//server.jsvar express = require(&quot;express&quot;);var bodyParser = require(&quot;body-parser&quot;);var app = express();//使用body-parser用来解析json数据格式和form表单提交的数据，也就是请求头中包含这样的信息： Content-Type: application/x-www-form-urlencodedapp.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.set(&#x27;views&#x27;, __dirname + &#x27;/view&#x27;); //视图文件目录app.set(&#x27;view engine&#x27;, &#x27;html&#x27;); //设置模板引擎app.listen(3000,function()&#123; console.log(&quot;Strated on port 3000!&quot;);&#125;); 3. 构建路由 123456789101112//server.js//访问localhost:3000时渲染登录页面app.get(&quot;/&quot;,function(req,res)&#123; res.sendFile(__dirname + &quot;/views/index.html&quot;);&#125;)//post请求为/login时做登录操作app.post(&quot;/login&quot;,function(req,res)&#123; var username = req.body.user; var password = req.body.password; console.log(&quot;User name=&quot; + username + &quot;,password is&quot; + password); res.end(&#x27;yes&#x27;);&#125;) 4. 构建视图页面 123456789101112131415161718192021222324252627282930313233343536373839404142//views/index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/4.1.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;h4&gt;登录演示&lt;/h4&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; placeholder=&quot;用户名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;.btn-default&quot;).click(function()&#123; var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); $.post(&quot;http://localhost:3000/login&quot;,&#123;user: username,password: password&#125;,function(json)&#123; if(json)&#123; alert(&quot;Login Success!&quot;); &#125; &#125;); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 至此，一个简单的登录演示demo完成。","tags":[{"name":"express","slug":"express","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/express/"}]},{"title":"canvas API前端图片压缩","date":"2018-05-26T12:43:00.000Z","path":"2018/05/26/前端图片压缩/","text":"随着手机的拍照效果的不断提升，必然使得单张图片的存储变大，几M到十几M不等，因此大图片上传不仅占用服务器资源、耗流量，也影响了用户体验，因而在前端方面有必要用js进行图片压缩。 一、 HTML5 canvas drawImage() 方法 canvas的drawImage()方法是前端图片压缩的核心方法，其有三种用法： 123//获取canvas对象和图片对象var canvas = document.createElement(&#x27;canvas&#x27;);var context = canvas.getContext(&#x27;2d&#x27;); ** 1.在画布上定位图像 ** context.drawImage(img,x,y); 参数：img规定要使用的图像、画布或视频；x在画布放置图像的x坐标位置；y在画布放置图像的y坐标位置。 ** 2.在画布上定位图像，并规定图像的宽度和高度 ** context.drawImage(img,x,y,width,height); 参数：width可选。要使用的图像的宽度。（伸展或缩小图像）；height可选。要使用的图像的高度。（伸展或缩小图像）。 ** 3.剪切图像，并在画布上定位被剪切的部分 ** context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数：sx可选。开始剪切的x坐标位置；sy可选。开始剪切的y坐标位置；swidth可选。被剪切图像的宽度；sheight可选。被剪切图像的高度。 二、 HTML5 file API 显示图片 HTML5的file API可以在图片上传之前直接在浏览器中显示，通常使用FileReader()方法。 1234567891011121314151617//图片上传元素var eleFile = document.querySelector(&quot;#imgfile&quot;);// 选择的文件对象var file = null;// 压缩图片需要的一些元素和对象var reader = new FileReader(), img = new Image();// 文件base64化，以便获知图片原始尺寸reader.onload = function (e) &#123; img.src = e.target.result; //图片base64地址&#125;;eleFile.addEventListener(&#x27;change&#x27;, function (event) &#123; file = event.target.files[0]; // 选择的文件是图片 if (file.type.indexOf(&quot;image&quot;) == 0) &#123; reader.readAsDataURL(file); //base64读取 &#125;&#125;); 三、 如何把canvas画布转成img图像 ** 1. HTMLCanvasElement.toDataURL() ** 该方法可以把图片转换成base64格式信息，纯字符的图片表示法。 canvas.toDataURL(type, encoderOptions); 参数：type可选。图片格式，默认为 image/png；encoderOptions可选。在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。 12345678var canvas = document.createElement(&#x27;canvas&#x27;);canvas.setAttribute(&quot;id&quot;,&quot;canvas&quot;);canvas.setAttribute(&quot;width&quot;,&quot;5&quot;);canvas.setAttribute(&quot;height&quot;,&quot;5&quot;);var dataURL = canvas.toDataURL();console.log(dataURL);// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot; ** 2. HTMLCanvasElement.toBlob() ** 该方法可以把canvas转换成Blob文件，通常用在文件上传中，因为是二进制的，对后端更加友好。 canvas.toBlob(callback, type, encoderOptions); 参数：type可选。图片格式，默认为 image/png；encoderOptions可选。在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。 和toDataURL()方法相比，toBlob()方法是异步的，因此多了个callback参数，这个callback回调方法默认的第一个参数就是转换好的blob文件信息，本文demo的文件上传就是将canvas图片转换成二进制的blob文件，然后再ajax上传的，代码如下： 12345678// canvas转为blob并上传canvas.toBlob(function (blob) &#123; // 图片ajax上传 var xhr = new XMLHttpRequest(); // 开始上传 xhr.open(&quot;POST&quot;, &#x27;upload.php&#x27;, true); xhr.send(blob); &#125;); 于是，经过“图片→canvas压缩→图片”三步曲，我们完成了图片前端压缩并上传的功能。 以下是完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//压缩上传var eleFile = document.querySelector(&quot;#imgfile&quot;);// 压缩图片需要的一些元素和对象var reader = new FileReader(), img = new Image();// 选择的文件对象var file = null;// 缩放图片需要的canvasvar canvas = document.createElement(&#x27;canvas&#x27;);var context = canvas.getContext(&#x27;2d&#x27;);// base64地址图片加载完毕后img.onload = function () &#123; // 图片原始尺寸 var originWidth = this.width; var originHeight = this.height; // 最大尺寸限制 var maxWidth = 400, maxHeight = 400; // 目标尺寸 var targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过400x400的限制 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123; if (originWidth / originHeight &gt; maxWidth / maxHeight) &#123; // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); &#125; else &#123; targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); &#125; &#125; // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; console.log(targetWidth + &quot;|&quot; + targetHeight); // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 图片压缩 context.drawImage(img, 0, 0, targetWidth, targetHeight); //上传的formData格式 var formData = new FormData(); //追加数据 formData.append(&quot;sessionid&quot;, $(&quot;#user_head_form #sessionid&quot;).val()); formData.append(&quot;host&quot;, $(&quot;#user_head_form input[name=host]&quot;).val()); formData.append(&quot;fileName&quot;, $(&quot;#user_head_form input[name=fileName]&quot;).val()); // canvas转为blob并上传 canvas.toBlob(function (blob) &#123; $(&#x27;#user_head_upload_box&#x27;).hide(); $(&#x27;#user_head_show_box&#x27;).show(); //formData放入blob formData.append(&quot;head&quot;, blob); console.log(blob); // 图片ajax上传 $.ajax(&#123; url: $(&quot;#user_head_form&quot;).attr(&quot;action&quot;), type: &#x27;POST&#x27;, cache: false, data: formData, processData: false, contentType: false, dataType: &quot;json&quot;, beforeSend: function () &#123; console.log(&quot;before&quot;); &#125;, success: function (data) &#123; if (data.code == 1) &#123; console.log(data.data); $(&quot;#user_head_origin&quot;).attr(&quot;src&quot;, data.data); &#125; else &#123; console.log(&quot;Other&quot;); &#125; &#125; &#125;); &#125;);&#125;;// 文件base64化，以便获知图片原始尺寸reader.onload = function (e) &#123; img.src = e.target.result;&#125;;eleFile.addEventListener(&#x27;change&#x27;, function (event) &#123; file = event.target.files[0]; // 选择的文件是图片 if (file.type.indexOf(&quot;image&quot;) == 0) &#123; reader.readAsDataURL(file); &#125;&#125;);//压缩上传结束 *注：参考文章MDN HTMLCanvasElement.toBlob()、MDN HTMLCanvasElement.toDataURL()、HTML5 file API加canvas实现图片前端JS压缩并上传。","tags":[{"name":"图片压缩","slug":"图片压缩","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"}]},{"title":"页面模糊（毛玻璃）效果","date":"2018-05-20T14:38:00.000Z","path":"2018/05/20/页面模糊效果/","text":"页面中有些内容需要隐藏或者是有访问权限，那么在展示的时候可以给它一个遮罩层盖住，但是纯色的遮罩层效果并不太好，刚开始想着用模糊背景图片平铺，但是由于浏览器渲染和层级的关系，文字 内容在上层可以很清晰的显示出来，其实这个效果可以通过CSS的filter:blur()实现。 给页面的主div加上样式： 12345678.mainContaner &#123; filter: url(blur.svg#blur); /* FireFox, Chrome, Opera */ -webkit-filter: blur(8px); /* Chrome, Opera */ -moz-filter: blur(8px); -ms-filter: blur(8px); filter: blur(8px); filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=8, MakeShadow=false); /* IE6~IE9 */&#125; 更多用法详见MDN官方文档。","tags":[]},{"title":"IOS下iframe宽高超过可视区不能自适应","date":"2018-05-20T14:00:00.000Z","path":"2018/05/20/IOS下iframe不能自适应/","text":"在用layui admin做响应式的后台管理系统时，发现在IOS上iframe宽高超过可视区域，不能够自适应，即使你做了适配或者使用了栅格布局。查阅发现，这可能是IOS系统的一个Bug，我们无法改变IOS系统，但我们能改变我们的demo，所以iframe这种东西今后还是慎用的好。 1. 通过给iframe的父级div元素添加样式并给iframe添加属性和样式可以解决这个问题，但是影响了Android端和PC端的超宽滚动，在高度超过可视区域时并不是最好的选择。 123&lt;div class=&quot;layui-tab-item layui-show&quot; style=&quot;overflow: auto;-webkit-overflow-scrolling:touch;width:100%;height:100%;&quot;&gt; &lt;iframe src=&quot;/StoreAdmin/ManageCenter&quot; name=&quot;child&quot; id=&quot;child&quot; frameborder=&quot;0&quot; height=&quot;100%&quot; scrolling=&#x27;no&#x27; style=&quot;width: 1px; min-width: 100%; *width: 100%;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 2. 通过js获取文档内容的高度并赋给iframe元素。 123456789101112//注意：下面的代码是放在和iframe同一个页面中调用$(&quot;#iframeId&quot;).load(function () &#123; var mainheight = $(this).contents().find(&quot;body&quot;).height() + 30; $(this).height(mainheight);&#125;);//注意：下面的代码是放在iframe引用的子页面中调用$(window.parent.document).find(&quot;#iframeId&quot;).load(function () &#123; var main = $(window.parent.document).find(&quot;#iframeId&quot;); var thisheight = $(document).height() + 30; main.height(thisheight);&#125;); 3. 通过js判断手机端系统并动态设置iframe高度。 12345678910111213141516171819202122 //解决ios系统iframe bugvar u = navigator.userAgent;var isAndroid = u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Adr&#x27;) &gt; -1; //android终端var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端console.log(isAndroid + &quot;|&quot; + isiOS);if (isAndroid) &#123; $(&quot;.clildFrame .layui-show&quot;).removeAttr(&quot;style&quot;); $(&quot;#child&quot;).removeAttr(&quot;frameborder&quot;); $(&quot;#child&quot;).removeAttr(&quot;height&quot;); $(&quot;#child&quot;).attr(&quot;scrolling&quot;,&quot;auto&quot;); $(&quot;#child&quot;).removeAttr(&quot;style&quot;);&#125;else &#123; //解决ios iframe高度问题 动态设置高度 之前else if(isIOS)&#123;&#125; $(&quot;#child&quot;).load(function () &#123; setTimeout(function () &#123; var mainheight = $(&quot;#child&quot;).contents().find(&quot;body&quot;).height() + 52; console.log(mainheight); $(&quot;#child&quot;).height(mainheight); &#125;, 1000); &#125;);&#125;","tags":[]},{"title":"Js密码强度计算","date":"2018-05-16T13:38:00.000Z","path":"2018/05/16/js密码强度计算/","text":"注册或修改密码实时显示密码强度，有利于提高用户体验，降低账户安全风险，主要利用js正则匹配，修改强度元素的样式。 1234567891011121314151617181920212223242526272829303132//强度计算 if else里面的css自行调整$(&#x27;input[name=new_password]&#x27;).keyup(function () &#123; var strongRegex = new RegExp(&quot;^(?=.&#123;8,&#125;)(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*\\\\W).*$&quot;, &quot;g&quot;); var mediumRegex = new RegExp(&quot;^(?=.&#123;7,&#125;)(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))).*$&quot;, &quot;g&quot;); var enoughRegex = new RegExp(&quot;(?=.&#123;6,&#125;).*&quot;, &quot;g&quot;); $(&quot;.safe-level&quot;).show(); if (false == enoughRegex.test($(this).val())) &#123; $(&quot;.safe-level span&quot;).removeClass(&quot;level&quot;).eq(1).text(&quot;弱&quot;); $(&quot;.safe-level span&quot;).eq(0).addClass(&quot;level&quot;); //默认灰色 //密码小于六位的时候，密码强度图片都为灰色 &#125; else if (strongRegex.test($(this).val())) &#123; $(&quot;.safe-level span&quot;).eq(1).text(&quot;强&quot;); $(&quot;.safe-level span&quot;).addClass(&quot;level&quot;); //密码为八位及以上并且字母数字特殊字符三项都包括,强度最强 &#125; else if (mediumRegex.test($(this).val())) &#123; $(&quot;.safe-level span&quot;).eq(1).addClass(&quot;level&quot;).text(&quot;中&quot;); $(&quot;.safe-level span&quot;).eq(0).addClass(&quot;level&quot;); $(&quot;.safe-level span&quot;).eq(2).removeClass(&quot;level&quot;); //密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等 &#125; else &#123; $(&quot;.safe-level span&quot;).removeClass(&quot;level&quot;).eq(1).text(&quot;弱&quot;); $(&quot;.safe-level span&quot;).eq(0).addClass(&quot;level&quot;); //如果密码为6为及以下，就算字母、数字、特殊字符三项都包括，强度也是弱的 &#125; return true;&#125;);","tags":[]},{"title":"Echarts图表实现自适应","date":"2018-05-13T12:38:00.000Z","path":"2018/05/13/Echarts图表实现自适应/","text":"在大数据时代，数据的可视化对前端提出了更高的要求，大佬们的团队提供了各色各样的插件，Echarts、HightCharts、D3.js，今天在做响应式后台管理系统时需要对Echarts图表进行自适应。 原理很简单，在浏览器窗口变化时调用Echarts提供的resize方法，详见官方文档，该方法的描述是：改变图表尺寸，在容器大小发生改变时需要手动调用。这就需要你的外部容器也是自适应的。 详见示例代码： ** HTML ** 1234&lt;!--栅格布局--&gt;&lt;div class=&quot;col-sm12&quot;&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt; ** CSS ** 123456789101112/*给出一个最大宽度 适配移动端*/#main&#123; max-width: 1920px; height: 400px;&#125;@media screen and (max-width:780px) &#123; #main&#123; width: 100%; height: 300px; &#125;&#125; ** Javascript ** 12345678910111213//echartsvar myChart = echarts.init(document.getElementById(&#x27;main&#x27;));option = &#123; //... &#125;; myChart.setOption(option);//通过DOM id获取到echarts实例var myChart = echarts.getInstanceByDom(document.getElementById(&quot;main&quot;));window.onresize = function () &#123; myChart.resize();&#125;;","tags":[]},{"title":"select、radio、checkbox的操作和attr()和prop()的区别","date":"2018-05-13T12:38:00.000Z","path":"2018/05/13/checkbox的操作和attr和prop的区别/","text":"这三类表单在前端表单操作里面相对复杂一点，特总结此篇，便于今后的开发，也希望对你有所帮助。 一、select表单 ** JS操作 ** 123456789101112131415//动态获取值var Selt = document.getElementById(&quot;selectBox&quot;);if(Selt.addEventListener)&#123; Selt.addEventListener(&quot;change&quot;,callbackFn);&#125;else&#123; Selt.attachEvent(&quot;change&quot;,callbackFn);&#125;function callbackFn(event)&#123; var e = event || window.event; var _target = e.target; var val = _target.value; console.log(val);&#125; 上面获取值是通过事件对象获取，当然还可以直接通过select的索引值获取。 123456//直接获取值var Selt = document.getElementById(&quot;selectBox&quot;);var Index = Selt.selectedIndex;var val = Selt[Index].value;console.log(val);&#125; ** JQ操作 ** //动态获取值 12345678910111213$(&quot;#selectBox&quot;).on(&quot;change&quot;,function()&#123; $(&quot;#selectBox&quot;).each(function(i,e)&#123; if($(this).prop(&quot;selected&quot;))&#123; console.log($(this).val()); &#125; &#125;);&#125;);//直接获取值var val = $(&quot;#selectBox option:selected&quot;).val();console.log(val);&#125; 二、radio表单（一组radio其name属性是相同的） ** JS操作 ** 12345678910111213141516171819202122232425//动态获取值var radios = document.getElementsByName(&quot;myradio&quot;);for(var i = 0;i &lt; radios.length; i++)&#123; if(radios[i].addEventListener)&#123; radios[i].addEventListener(&quot;change&quot;,callbackFn); &#125;else&#123; radios[i].attachEvent(&quot;change&quot;,callbackFn); &#125; &#125;function callbackFn(event)&#123; var e = event || window.event; var _target = e.target; if(_target.checked)&#123; var val = _target.value; console.log(val); &#125;&#125;//直接获取for(var i = 0; i &lt; radios.length; i++)&#123; if(radios[i].ckecked)&#123; console.log(radios[i].value); &#125;&#125; ** JQ操作 ** //动态获取值 1234567891011$(&quot;input[type=radio]&quot;).change(function()&#123; if($(this).prop(&quot;checked&quot;))&#123; console.log($(this).val()); &#125;&#125;);//直接获取值var val = $(&quot;input[type=radio]:checked&quot;).val();console.log(val);&#125; 三、checkbox表单 ** JS操作 ** 12345678910111213141516171819202122232425//动态获取值var radios = document.getElementsByName(&quot;myradio&quot;);for(var i = 0;i &lt; radios.length; i++)&#123; if(radios[i].addEventListener)&#123; radios[i].addEventListener(&quot;change&quot;,callbackFn); &#125;else&#123; radios[i].attachEvent(&quot;change&quot;,callbackFn); &#125; &#125;function callbackFn(event)&#123; var e = event || window.event; var _target = e.target; if(_target.checked)&#123; var val = _target.value; console.log(val); &#125;&#125;//直接获取for(var i = 0; i &lt; radios.length; i++)&#123; if(radios[i].ckecked)&#123; console.log(radios[i].value); &#125;&#125; ** JQ操作 ** //动态获取值 1234567891011$(&quot;input[type=checkbox]&quot;).change(function()&#123; if($(this).prop(&quot;checked&quot;))&#123; console.log($(this).val()); &#125;&#125;);//直接获取值var val = $(&quot;input[name=mycheckbox]:checked&quot;).val();console.log(val);&#125; 四、全选反选 ** JS操作 ** 1234567891011121314151617181920212223242526272829303132var checkAll = document.getElementById(&quot;checkAll&quot;);if(checkAll.addEventListener)&#123; checkAll.addEventListener(&quot;click&quot;,callbackFn);&#125;else&#123; checkAll.attachEvent(&quot;click&quot;,callbackFn);&#125;function callbackFn(event)&#123; var e = event || window.event; var _target = e.target; var checkboxs = document.getElementsByName(&quot;mycheckbox&quot;); if(_target.checked)&#123; for(var i = 0;i &lt; checkboxs.length; i++)&#123; checkboxs[i].checked = true; &#125; &#125;else&#123; for(var i = 0;i &lt; checkboxs.length; i++)&#123; checkboxs[i].checked = false; &#125; &#125;&#125;//还可以对checkbox直接赋值，减少一次for循环function callbackFn(event)&#123; var e = event || window.event; var _target = e.target; var checkboxs = document.getElementsByName(&quot;mycheckbox&quot;); checkboxs.checked = _target.checked;&#125; ** JQ操作 ** 12345678$(document).on(&#x27;click&#x27;, &#x27;#checkAll&#x27;, function () &#123; var op = $(this).is(&#x27;:checked&#x27;); if (op == true) &#123; $(&#x27;[type=checkbox]&#x27;).prop(&#x27;checked&#x27;, true); &#125; else &#123; $(&#x27;[type=checkbox]&#x27;).prop(&#x27;checked&#x27;, false); &#125;&#125;); 五、JQ方法attr()和prop()的区别 ** 1.官方文档描述 ** attr(): Description: Get the value of an attribute for the first element in the set of matched elements. 获取并且设置匹配元素的attribute属性值 prop(): Description: Get the value of a property for the first element in the set of matched elements. 获取并且设置匹配元素的property属性值 一词之差，attribute和property。 ** 2.attribute和property ** 官方文档prop()下是这样写的： Attributes vs. Properties The difference between attributes and properties can be important in specific situations. Before jQuery 1.6, the .attr() method sometimes took property values into account when retrieving some attributes, which could cause inconsistent behavior. As of jQuery 1.6, the .prop() method provides a way to explicitly retrieve property values, while .attr() retrieves attributes. For example, selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, and defaultSelected should be retrieved and set with the .prop() method. Prior to jQuery 1.6, these properties were retrievable with the .attr() method, but this was not within the scope of attr. These do not have corresponding attributes and are only properties. 考虑到在Jquery1.6之前attr()方法检索属性值返回结果有些不一致，在1.6+后，提供prop()方法明确的检索属性值当用attr()检索时，这在jquery源码中可以看到。 在编写HTML代码时，你可以在HTML元素中定义attribute属性。然而，当浏览器渲染解析页面时，该HTML元素相应的DOM节点就会被创建。该节点是一个对象，因此它就拥有properties。 因此，我们知道attributes是HTML元素（标签）的属性，而properties是DOM对象的属性。 举个例子： &lt;input id=&quot;myinput&quot; type=&quot;text&quot; value=&quot;Name&quot;&gt; 其对应DOM节点会拥有如下properties： id、type 和 value： idproperty是idattribute的映射：获取该property即等于读取其对应的attribute值，而设置该property即为attribute赋值。id是一个纯粹的映射property，它不会修改或限制其值。 typeproperty是typeattribute的映射：获取该property即等于读取其对应的attribute值，而设置该property即为attribute赋值。但type并不是一个纯粹的映射property，因为它的值被限制在已知值（即input的合法类型，如：text、password）。如果你有 ，然后 theInput.getAttribute(“type”) 会返回 “foo”，而 theInput.type 会返回 “text”。 相比之下，valueproperty并不会映射valueattribute。取而代之的是input的当前值。当用户手动更改输入框的值，valueproperty会反映该改变。所以，如果用户在input输入John，然后： theInput.value 返回 “John” 然而： theInput.getAttribute('value') 返回 “Name”。 valueproperty反映了input的当前文本内容，而valueattribute则是在 HTML源码 value 属性所指定的初始文本内容。 总结一下：attribute是HTML元素的属性，静态页面定义好的，propertype是js对象的属性值，可以是静态页面定义好的，也可以的动态操作的；attribute和property是一对多的关系，简言之，attribute的值一定是property的值，反过来就不一定；通过官方文档建议，具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()。 最后附上Jquery3.3.1源码，重点地方有注释，也可以看出在attr()方法里面调用prop()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141jQuery.fn.extend( &#123; prop: function( name, value ) &#123; return access( this, jQuery.prop, name, value, arguments.length &gt; 1 ); &#125;, removeProp: function( name ) &#123; return this.each( function() &#123; delete this[ jQuery.propFix[ name ] || name ]; &#125; ); &#125;&#125; );jQuery.extend( &#123; prop: function( elem, name, value ) &#123; var ret, hooks, nType = elem.nodeType; // Don&#x27;t get/set properties on text, comment and attribute nodes if ( nType === 3 || nType === 8 || nType === 2 ) &#123; return; &#125; if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) &#123; // Fix name and attach hooks name = jQuery.propFix[ name ] || name; hooks = jQuery.propHooks[ name ]; &#125; if ( value !== undefined ) &#123; if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; ( ret = hooks.set( elem, value, name ) ) !== undefined ) &#123; return ret; &#125; return ( elem[ name ] = value ); //清空property的name值 &#125; if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) &#123; return ret; &#125; return elem[ name ]; //返回property的name值 &#125;, propHooks: &#123; tabIndex: &#123; get: function( elem ) &#123; // Support: IE &lt;=9 - 11 only // elem.tabIndex doesn&#x27;t always return the // correct value when it hasn&#x27;t been explicitly set // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/ // Use proper attribute retrieval(#12072) var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; ); if ( tabindex ) &#123; return parseInt( tabindex, 10 ); &#125; if ( rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ) &#123; return 0; &#125; return -1; &#125; &#125; &#125;, propFix: &#123; &quot;for&quot;: &quot;htmlFor&quot;, &quot;class&quot;: &quot;className&quot; &#125;&#125; );jQuery.fn.extend( &#123; attr: function( name, value ) &#123; return access( this, jQuery.attr, name, value, arguments.length &gt; 1 ); &#125;, removeAttr: function( name ) &#123; return this.each( function() &#123; jQuery.removeAttr( this, name ); &#125; ); &#125;&#125; );jQuery.extend( &#123; attr: function( elem, name, value ) &#123; var ret, hooks, nType = elem.nodeType; // Don&#x27;t get/set attributes on text, comment and attribute nodes if ( nType === 3 || nType === 8 || nType === 2 ) &#123; return; &#125; // Fallback to prop when attributes are not supported if ( typeof elem.getAttribute === &quot;undefined&quot; ) &#123; return jQuery.prop( elem, name, value ); &#125; // Attribute hooks are determined by the lowercase version // Grab necessary hook if one is defined if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) &#123; hooks = jQuery.attrHooks[ name.toLowerCase() ] || ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined ); &#125; if ( value !== undefined ) &#123; if ( value === null ) &#123; jQuery.removeAttr( elem, name ); //移除name属性 return; &#125; if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; ( ret = hooks.set( elem, value, name ) ) !== undefined ) &#123; return ret; &#125; elem.setAttribute( name, value + &quot;&quot; ); //设置attribute return value; &#125; if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) &#123; return ret; &#125; ret = jQuery.find.attr( elem, name ); // Non-existent attributes return null, we normalize to undefined return ret == null ? undefined : ret; &#125;, attrHooks: &#123; type: &#123; set: function( elem, value ) &#123; if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; nodeName( elem, &quot;input&quot; ) ) &#123; var val = elem.value; elem.setAttribute( &quot;type&quot;, value ); //设置attribute if ( val ) &#123; elem.value = val; &#125; return value; &#125; &#125; &#125; &#125;, removeAttr: function( elem, value ) &#123; var name, i = 0, // Attribute names can contain non-HTML whitespace characters // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2 attrNames = value &amp;&amp; value.match( rnothtmlwhite ); if ( attrNames &amp;&amp; elem.nodeType === 1 ) &#123; while ( ( name = attrNames[ i++ ] ) ) &#123; elem.removeAttribute( name ); &#125; &#125; &#125;&#125; ); 注：参考文章","tags":[]},{"title":"图片上传插件之WebUploader","date":"2018-04-26T14:14:00.000Z","path":"2018/04/26/图片上传之webuploader/","text":"图片上传，头像替换是在web开发中常见的功能之一，在如今前端技术频繁更新的时代，拥有快速开发实现项目功能的能力是非常重要的。下面介绍WebUploader的配置使用。 在此之前你需要一个图片上传的按钮和图片预览的载体，引入官网包的css和js文件。 示例HTML，很简单 1234&lt;p&gt; &lt;img id=&quot;storeImg&quot; src=&quot;/Images/StoreAdmin/face.jpg&quot;/&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;choose_file&quot;&gt;上传标志&lt;/a&gt;&lt;/p&gt; 接下来进javascript预警区。 一、初始化图片上传实例： 123456789101112131415161718192021222324 //图片上传var uploader = WebUploader.create(&#123; auto: true, // 选完文件后，是否自动上传 swf: &#x27;/Plugin/webuploader/Uploader.swf&#x27;, // swf文件路径 server: &#x27;/api/Refund/ImportImages&#x27;, // 文件接收api pick: &#x27;.choose_file&#x27;, // 选择文件的按钮。可选 // 只允许选择图片文件。 accept: &#123; title: &#x27;Images&#x27;, extensions: &#x27;gif,jpg,jpeg,bmp,png&#x27;, mimeTypes: &#x27;image/jpg,image/jpeg,image/png,image/bmp,image/gif&#x27; &#125;, //配置生成缩略图的选项 thumb: &#123; type: &#x27;image/jpg,jpeg,png,gif,bmp&#x27; &#125;, //请求服务器api携带的参数 formData: &#123; token: token, sessionid: &quot;123&quot; &#125;, fileNumLimit: 1, //限制上传个数 fileSingleSizeLimit: 2048000 //限制单个上传图片的大小 2M&#125;); 二、当有图片添加进入，显示缩略图： 1234567891011121314151617// 当有文件添加进来的时候uploader.on(&#x27;fileQueued&#x27;, function (file) &#123; //img容器 var $img = $(&quot;#storeImg&quot;); // 创建缩略图 // 如果为非图片文件，可以不用调用此方法。 // thumbnailWidth x thumbnailHeight 为 宽 x 高 uploader.makeThumb(file, function (error, src) &#123; if (error) &#123; //错误处理 $img.replaceWith(&#x27;&lt;span&gt;不能预览&lt;/span&gt;&#x27;); return; &#125; $img.attr(&#x27;src&#x27;, src); &#125;, 60, 60);&#125;); 三、图片上传成功： 12345// 文件上传成uploader.on(&#x27;uploadSuccess&#x27;, function (fil,response) &#123; console.log(file); console.log(response._raw); //这里可以得到后台返回的数据&#125;); 四、图片上传失败： 123456789// 文件上传失败uploader.on(&#x27;uploadError&#x27;, function (file) &#123; console.log(file); uploader.removeFile(uploader.getFile(file.id)); //移除添加的文件 uploader.onFileDequeued = function( file ) &#123; //查看文件列表 console.log(uploader.getFiles()); &#125;;&#125;); 五、图片上传动作完成： 1234// 完成上传动作完了uploader.on(&#x27;uploadComplete&#x27;, function (file) &#123; console.log(file);&#125;); 注：WebUploader会在a标签里面自动添加一个文件上传的按钮，只需要把按钮opacity属性设置为0，即可回到我们自己的布局中。","tags":[]},{"title":"一般项目开发——找回密码逻辑","date":"2018-04-19T14:31:00.000Z","path":"2018/04/19/找回密码逻辑/","text":"既然登录注册模块是涉及到用户的项目开发中不可缺少的部分，那么忘记密码可以说是和用户登录相辅的功能了，此文归纳在实际项目开发中忘记密码模块的一些思路和通用代码块，当然也有其不足之处，望各位多多指教。 忘记密码和注册模块有其相似之处，比如发送验证码，其不同之处在于忘记密码进行找回密码时，有多种途径可选，看具体的项目而定。 1. 忘记密码模块： 相比较而言，忘记密码还是比较简单，一般就是手机、邮箱、密保问题三项找回密码，手机、邮箱是需要短信验证码校验的。 理一理逻辑：点击忘记密码，进入账号输入界面，通过账号获取用户可以通过哪几种方式找回密码；手机号和短信验证码校验进入重置密码界面；邮箱号和信息验证码校验进入重置密码界面；密保问题和答案校验进入重置密码界面；重置密码；监听回车按钮重置密码。 界面的切换，可以通过&lt;div&gt;&lt;/div&gt;的显示隐藏实现，这里不再赘述。 通过账号信息，调用后台api，获取用户绑定信息，判断用户找回密码的方式是否可以。 手机校验，事先校验手机号，发送短信验证码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//发送短信验证码var flag = true;$(&quot;#inputGetVerify&quot;).on(&quot;click&quot;, function () &#123; $(&quot;#inputTel&quot;).blur(); //失去焦点后校验 if (inputTelStatus == 1) &#123; if (flag) &#123; flag = false; $(this).css(&#123; &quot;background&quot;: &quot;#999999&quot; &#125;); var timer,wait = 60; function time() &#123; if (wait == 0) &#123; $(&quot;#inputGetVerify&quot;).css(&#123; &quot;background&quot;: &quot;#fff&quot; &#125;); $(&quot;#inputGetVerify&quot;).text(&quot;获取验证码&quot;); wait = 60; flag = true; &#125; else &#123; $(&quot;#inputGetVerify&quot;).text(&quot;重新发送(&quot; + wait + &quot;)&quot;); wait--; timer = setTimeout(function () &#123; time(); &#125;, 1000); &#125; &#125; time(); $.post(&quot;/api/Account/RegSendSms&quot;, &#123; phone: $.trim($(&quot;#inputTel&quot;).val()) &#125;, function (json) &#123; if (json.code != 1) &#123; $(&quot;#inputGetVerify&quot;).css(&quot;background&quot;, &quot;#fff&quot;).text(&quot;获取验证码&quot;); clearTimeout(timer); flag = true; $(&quot;.tisi&quot;).html(json.data); &#125; &#125;); &#125; else &#123; return; &#125; &#125; else &#123; return; &#125;&#125;);//事先校验手机号var inputTelStatus = 0; //全局使用 是否校验通过$(&quot;#inputTel&quot;).blur(function()&#123; if((/^[1-9]\\d*$/.test($(&quot;#inputTel&quot;).val())))&#123; inputTelStatus = 1; &#125; else &#123; inputTelStatus = 0; $(&quot;.tisi&quot;).html(&quot;请输入正确的手机号码！&quot;); &#125;&#125;); 校验手机。 12345678910111213141516171819202122$(&quot;#checkBtn&quot;).on(&quot;click&quot;, function () &#123; $(&quot;#inputTel1&quot;).blur(); if ($(&quot;#inputTel1&quot;).val() == &quot;&quot; || inputTelStatus == 0) &#123; $(&quot;.tisi&quot;).html(&quot;请输入正确的手机号码！&quot;); &#125; else if ($(&quot;#inputCode&quot;).val() == &quot;&quot;) &#123; $(&quot;.tisi&quot;).html(&quot;请输入验证码！&quot;); &#125; else &#123; $(&quot;#checkBtn&quot;).text(&quot;校验中..&quot;).css(&#123; &quot;color&quot;: &quot;#cccccc&quot; &#125;).attr(&quot;disabled&quot;, &quot;disabled&quot;); $.post(&quot;/api/Account/RetCheckSms&quot;, &#123; phone: $.trim($(&quot;#inputTel1&quot;).val()), code: $.trim($(&quot;#inputCode1&quot;).val()), s: 0 &#125;, function (json) &#123; if (json.code == 1) &#123; $(&quot;.search-title&quot;).text(&quot;重置密码&quot;); $(&quot;.jiaoyan-box&quot;).show(); $(&quot;.jiaoyan-box .shouji-yanzheng&quot;).hide(); $(&quot;.jiaoyan-box .reset-psswd&quot;).show(); Token = json.data; &#125; else &#123; $(&quot;.tisi&quot;).html(json.data); $(&quot;#checkBtn&quot;).text(&quot;确 认&quot;).css(&#123; &quot;color&quot;: &quot;#444&quot; &#125;).removeAttr(&quot;disabled&quot;); &#125; &#125;); &#125;&#125;) 邮箱方式找回和手机找回类似，密保问题找回只需要在用户输入账号信息之后调用api获取用户设置的密保信息载入DOM，参照【4】提交校验即可。 重置密码 1234567891011121314151617181920$(&quot;#Reset&quot;).click(function () &#123; $(&quot;#password&quot;).blur(); //事先校验 参照【3】 $(&quot;#second-password&quot;).blur(); //事先校验 参照【3】 $(&quot;#Reset&quot;).text(&quot;重置中..&quot;).css(&#123; &quot;color&quot;: &quot;#cccccc&quot; &#125;).attr(&quot;disabled&quot;, &quot;disabled&quot;); if (passwordstatus == 1 &amp;&amp; secondpasswordstatus == 1) &#123; $.post(&quot;/api/Account/ReSetPass&quot;, &#123; token: Token, s: 1, userpass: $(&quot;#password&quot;).val() &#125;, function (json) &#123; if (json.code == 1) &#123; tip(json.data, function () &#123; location.href = &quot;/Home/Login&quot;; &#125;) &#125; else &#123; $(&quot;.tisi&quot;).html(json.data); &#125; &#125;); &#125; else &#123; return; &#125;&#125;); ** 附： ** 登录、注册、找回密码涉及到较多的用户提示，下面附上常用的dialog弹框框架，点击下载css、下载js，封装了一个提示型和确定回调型方法，当然，你还可以写的更加完美。 123456789101112131415161718192021222324252627function tip(discription, fn) &#123; if (fn) &#123; javascript: $(&#x27;body&#x27;).dialog(&#123; title: &quot;提示&quot;, titleFontSize: &quot;16px&quot;, type: &#x27;primary&#x27;, showBoxShadow: true, buttons: [&#123; name: &#x27;确定&#x27;, className: &#x27;danger reload&#x27; &#125;], discription: discription, animateIn: &#x27;fadeInRight-hastrans&#x27;, animateOut: &#x27;fadeOutRight-hastrans&#x27;, duration: 0 &#125;, function (ret) &#123; if (ret.index === 0) &#123; fn(); &#125; &#125;); &#125; else &#123; javascript: $(&#x27;body&#x27;).dialog(&#123; title: &quot;提示&quot;, titleFontSize: &quot;16px&quot;, type: &#x27;primary&#x27;, showBoxShadow: true, buttons: [&#123; name: &#x27;确定&#x27;, className: &#x27;danger&#x27; &#125;], discription: discription, animateIn: &#x27;fadeInRight-hastrans&#x27;, animateOut: &#x27;fadeOutRight-hastrans&#x27;, duration: 0, &#125;); &#125;&#125;","tags":[]},{"title":"javascript实现翻页效果","date":"2018-04-16T05:20:00.000Z","path":"2018/04/16/用js实现一个翻页效果/","text":"摘要：用js实现翻页效果，首页、末页、上一页、下一页、跳转到具体页，数据采用豆瓣图书api，主要侧重功能，当然也有其不足之处，望各位多多指教。 在翻页效果中，翻页和页码生成都是动态的，所以封装一个翻页函数GoPage(p)，用来调用api、数据传输、拼接每页数据、调用页码函数、添加HTML；还需要封装一个页码函数getPageNavigate(currentPage,totalPages)，用于页码的动态生成、返回页码字符串。 其中页码生成涉及到比较多的判断，也是这个效果中比较难的地方，其中涉及到几个关键变量，当前页、总页数、页码显示个数（本案例已写死为5）、前三页、倒数第二页，下面来理一理思路： 首先初始化页码字符串为&quot;&quot;，接下来的所有逻辑即在总页数&gt;0下完成。 1.首先是首页、末页，当前页==1，首页点击不做任何操作，否则翻页到第一页GoPage(1)；如果当前页 ==总页数，不做任何操作，否则翻页到最后一页GoPage(totalPages)。 2.然后是上一页、下一页，当前页&gt;1，点击回到当前页减一页GoPage(currentpage-1)，否则点击不做任何操作；如果当前页&lt;总页数，点击回到当前页加一页GoPage(currentpage+1)，否则点击不做任何操作。 3.跳页，点击获取input输入的值调用GoPage(val)到指定页。 4.中间页码，因为页码显示5个，所以这里的子逻辑前提为总页数&gt;5；当前页数为1-3时，遍历显示前五个页码生成页码字符串，在后面追加字符串...；当前页在4到倒数第二页时，前面字符串追加...，遍历当前页-2到当前页+2页码生成页码字符串，并在后面面字符串追加...；当前页大于倒数第二页时，在前面追加字符串...，遍历后四页生成页码字符串。退出子逻辑，当总页数&lt;5时，遍历还是所有页码。 好了，一大把文字下来直接贴代码： 1. HTML： 123456789101112131415&lt;body&gt; &lt;div id=&quot;mask&quot;&gt; &lt;p id=&quot;loading&quot;&gt;加载中。。。。&lt;/p&gt; &lt;/div&gt; &lt;div&gt;javascript实现翻页效果&lt;/div&gt; &lt;div&gt;页数p为全局变量&lt;/div&gt; &lt;div&gt;在正式开发环境中在执行涉及翻页数据的api操作后需要执行该翻页函数&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;点击启动翻页&lt;/button&gt; &lt;div id=&quot;tb-content&quot;&gt; &lt;/div&gt; &lt;div id=&quot;page-bottom&quot;&gt; &lt;/div&gt;&lt;/body&gt; 2. CSS： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;style type=&quot;text/css&quot;&gt; #mask&#123; position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 99; background-color: rgba(0,0,0,.4); display: none; &#125; #loading&#123; width: 140px; position: relative; top: 45%; left: 48%; color: red; font-size: 20px; &#125; .content-div&#123; width: 700px; text-align: center; margin: 0 auto; height: 40px; line-height: 1.2; &#125; #page-bottom&#123; width: 780px; margin: 0 auto; &#125; /*页码样式*/ .noclick-nbe &#123; border: 1px solid #BBBBBB; padding: 5px 10px; margin-right: 5px; font-size: 14px; cursor: pointer; &#125; .currentpage &#123; color: #ffffff; padding: 5px 10px; font-size: 14px; margin-right: 5px; cursor: pointer; background: #3e91fe; &#125; .curra-nbe &#123; border: 1px solid #BBBBBB; padding: 5px 10px; margin-right: 5px; font-size: 14px; cursor: pointer; &#125; a &#123; color: #434343; text-decoration: none; &#125; .count &#123; border: 1px solid #BBBBBB; padding: 5px 10px; margin-right: 5px; font-size: 14px; color: rgb(150, 150, 150); &#125; .pageNum &#123; color: rgb(150, 150, 150); font-size: 14px; &#125; #pageSure-nbe &#123; border: 1px solid #BBBBBB; width: 25px; height: 25px; line-height: 30px; font-size: 14px; color: #000000; padding: 5px 10px; margin-left: 10px; &#125; #txt_page &#123; width: 38px; height: 18px; line-height: 20px; background: #f5f5f5; border: 1px solid #BBBBBB; &#125; .nopage &#123; border: 1px solid #BBBBBB; padding: 5px 10px; font-size: 14px; margin-right: 5px; cursor: pointer; &#125; &lt;/style&gt; 3. javascript 长代码预警。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var p = 1; $(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; GoPage(1); &#125;);function GoPage(i)&#123; // do someting on start.. p = parseInt(i); //p为全局变量 全部范围初始化为1 $(&quot;#mask&quot;).show(); //加载中动图 var url = &#x27;https://api.douban.com/v2/book/search?q=python&amp;fields=id,title&#x27;; $.ajax(url, &#123; data: &#123; &#x27;q&#x27;: &#x27;python&#x27;, &#x27;count&#x27;: &#x27;10&#x27;, &#x27;start&#x27;: p==1?0:p*10, &#x27;fields&#x27;: &#x27;id,title&#x27; &#125;, dataType: &#x27;jsonp&#x27;, crossDomain: true, success: function(json) &#123; $(&quot;#mask&quot;).hide(); var table = &quot;&quot;; var pageTotal; //总页数 if(json.books)&#123; pageTotal = parseInt(json.total/10); $.each(json.books, function(i ,item) &#123; //拼截每页字符串 table += &#x27;&lt;div class=&quot;content-div&quot;&gt;&lt;span&gt;&#x27;+ item.title + &#x27;&lt;/span&gt;&lt;/div&gt;&#x27;; &#125;); &#125;else&#123; table = &quot;&quot;; &#125; $(&quot;#tb-content&quot;).html(table); //页码函数 var page = getPageNavigate(p, pageTotal); $(&quot;#page-bottom&quot;).html(page); &#125; &#125;);&#125;//页码函数function getPageNavigate(currentPage, totalPages)&#123; var output = &quot;&quot;; var max = 5; //显示个数 if(totalPages &gt; 0)&#123; //至少有数据 //首页和上一页 if(currentPage == 1)&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;noclick-nbe&#x27;&gt;首页&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe&#x27; onclick=&#x27;GoPage(1)&#x27;&gt;首页&lt;/a&gt;&quot;; &#125; if(currentPage &gt; 1)&#123; output += &quot;&lt;a href=&#x27;javacript:void(0)&#x27; class=&#x27;curra-nbe&#x27; onclick=&#x27;GoPage(&quot; + (currentPage - 1) + &quot;)&#x27;&gt;上一页&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;noclick-nbe&#x27;&gt;上一页&lt;/a&gt;&quot;; &#125; //中间页码 if(totalPages &gt; 5)&#123; //超过5页 if(currentPage &lt; 4)&#123; // 1..3 加当前页和其他页码 for(var i = 1; i &lt;= 5; i++)&#123; //显示页码1..5后面加... if(currentPage == i)&#123; //当前页 加选中样式 output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe currentpage&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125;else&#123; //其他页 output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;nopage&#x27; onclick=&#x27;GoPage(&quot; + i + &quot;)&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125; &#125; output += &quot;&lt;a href=&#x27;javascr ipt: void(0)&#x27; class=&#x27;num&#x27;&gt;...&lt;/a&gt;&quot;; &#125;else if(currentPage &gt; 3 &amp;&amp; currentPage &lt;= totalPages - 2)&#123; //当前页&gt;3||&lt;倒数第二页 页码前面后面加... if(currentPage &gt; 3)&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;num&#x27;&gt;...&lt;/a&gt;&quot;; &#125; for(var i = currentPage - 2; i &lt;= currentPage + 2; i++)&#123; if(currentPage == i)&#123; //当前页，加选中样式 output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe currentpage&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;nopage&#x27; onclick=&#x27;GoPage(&quot; + i + &quot;)&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125; &#125; if(currentPage &lt; totalPages - 2)&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;&#x27;&gt;...&lt;/a&gt;&quot;; &#125; &#125;else if(currentPage &gt; totalPages - 2)&#123; //当前页&gt;倒数第二页 页码前面加... if(currentPage &gt; 3)&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;&#x27;&gt;...&lt;/a&gt;&quot;; &#125; for(var i = totalPages - 4; i &lt;= totalPages; i++)&#123; if(currentPage == i)&#123; // 当前页 加选中样式 output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe currentpage&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;nopage&#x27; onclick=&#x27;GoPage(&quot; + i + &quot;)&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125; &#125; &#125; &#125;else&#123; // 不超过5页 for(var i = 1; i &lt;= totalPages; i++)&#123; if(currentPage == i)&#123; //当前页，加选中样式 output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe currentpage&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;nopage&#x27; onclick=&#x27;GoPage(&quot; + i + &quot;)&#x27;&gt;&quot; + i.toString() + &quot;&lt;/a&gt;&quot;; &#125; &#125; &#125; //下一页和末页 if(currentPage &lt; totalPages)&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe&#x27; onclick=&#x27;GoPage(&quot; + (currentPage + 1).toString() + &quot;)&#x27;&gt;下一页&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;noclick-nbe&#x27;&gt;下一页&lt;/a&gt; &quot;; &#125; if(currentPage == totalPages)&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;noclick-nbe&#x27;&gt;末页&lt;/a&gt;&quot;; &#125;else&#123; output += &quot;&lt;a href=&#x27;javascript:void(0)&#x27; class=&#x27;curra-nbe&#x27; onclick=&#x27;GoPage(&quot; + totalPages + &quot;)&#x27;&gt;末页&lt;/a&gt;&quot;; &#125; //拼接跳页 output += &quot;&lt;span class=&#x27;count&#x27;&gt;共 &quot; + totalPages + &quot; 页&lt;/span&gt;&lt;span class=&#x27;pageNum&#x27;&gt; 到第 &lt;input type=&#x27;text&#x27; name=&#x27;pageInp&#x27; id=&#x27;txt_page&#x27; maxlength=&#x27;3&#x27; class=&#x27;pgi-nbe&#x27;&gt; 页&lt;/span&gt;&lt;a href=&#x27;javascript:void(0)&#x27; id=&#x27;pageSure-nbe&#x27; onclick=\\&quot;var a=$(&#x27;#txt_page&#x27;).val();GoPage(a);\\&quot;&gt;确定&lt;/a&gt;&quot;; return output; &#125;&#125; &lt;/script&gt; 附：此代码还可以加以优化。","tags":[{"name":"翻页","slug":"翻页","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%BF%BB%E9%A1%B5/"}]},{"title":"一般项目开发——登录注册逻辑","date":"2018-04-15T02:31:00.000Z","path":"2018/04/15/登录注册逻辑/","text":"摘要：登录注册模块是涉及到用户的项目开发中不可缺少的部分，此文归纳在实际项目开发中登录注册模块的一些思路和通用代码块，当然也有其不足之处，望各位多多指教。 登录和注册模块是非常相似的，可能唯一不同的地方是在注册的时候需要校验手机或者邮箱的验证码，看具体的项目而定。 一、登录模块： 相比较而言，登录还是比较简单，一般就是账号、密码、验证码三项信息，点击按钮提交登录，当然，在这里就不讨论高大上第三方验证方式，比如：滑动验证、文字验证等。 理一理逻辑：默认载入显示验证码图片，点击提交按钮首先表单校验，校验成功提交登录防止用户多次提交先禁用按钮，登录成功跳转页面，登录失败刷新验证码图片登录按钮正常可操作，点击验证图片切换验证图；监听回车按钮登录。 1.因为验证图功能多次使用，所以封装通用方法。 123456789//全局codehash用户后面登录校验 var codehash;getImage();function getImage() &#123; $.post(&quot;/api/Account/ValidateCode&quot;, function (json) &#123; $(&quot;.yanzhengtu&quot;).attr(&quot;src&quot;, json.fileurl); codehash = json.codehash; &#125;)&#125; 2.点击登录和后续操作 123456789101112131415161718192021222324252627282930313233343536$(&quot;#Login&quot;).on(&quot;click&quot;,function () &#123; if ($(&quot;#username&quot;).val() == &quot;&quot;) &#123; $(&quot;.tisi&quot;).html(&quot;请输入用户名！&quot;); &#125; else if ($(&quot;#password&quot;).val() == &quot;&quot;) &#123; $(&quot;.tisi&quot;).html(&quot;请输入密码！&quot;); &#125;else if ($(&quot;#code&quot;).val() == &quot;&quot;) &#123; $(&quot;.tisi&quot;).html(&quot;请输入验证码！&quot;); &#125; else &#123; var data = &#123; username: $(&quot;#username&quot;).val(), userpass: $(&quot;#password&quot;).val(), code: $(&quot;#code&quot;).val(), codehash: codehash &#125;; $(&quot;#Login&quot;).text(&quot;登录中..&quot;).css(&#123; &quot;color&quot;: &quot;#cccccc&quot; &#125;).attr(&quot;disabled&quot;, &quot;disabled&quot;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/api/Account/Login&quot;, data: data, contentType: &#x27;application/x-www-form-urlencoded&#x27;, success: function (json) &#123; if (json.code == 1) &#123; //登录成功 跳转后台界面 location.href = &quot;...&quot;; &#125; else &#123; getImage(); $(&quot;.tisi&quot;).html(json.data); $(&quot;#Login&quot;).text(&quot;登 录&quot;).css(&#123; &quot;color&quot;: &quot;#444&quot; &#125;).removeAttr(&quot;disabled&quot;); &#125; &#125; &#125;); &#125;&#125;) 3.点击图片切换验证图 1234// 切换验证图片 封装好方法直接调用$(&quot;.yanzhengtu&quot;).on(&quot;click&quot;, function () &#123; getImage();&#125;); 4.监听Enter按钮登录 123456document.onkeydown = function(event)&#123; var e = event || window.event || arguments.callee.caller.arguments[0]; if (e &amp;&amp; e.keyCode == 13) &#123; // enter 键 $(&quot;#Login&quot;).click(); &#125;&#125; 二、注册模块 ： 注册模块没有图形验证码，但是需要发送短信验证码或者邮箱验证码，点击提交按钮校验完之后再提交注册信息，我们可以对必要的input做事先校验（失去焦点后校验）。 1.发送验证信息 12345678910111213141516171819202122232425262728293031323334353637383940414243var flag = true;$(&quot;#inputGetVerify&quot;).on(&quot;click&quot;, function () &#123; $(&quot;#inputTel&quot;).blur(); //失去焦点后校验 if (inputTelStatus == 1) &#123; if (flag) &#123; flag = false; $(this).css(&#123; &quot;background&quot;: &quot;#999999&quot; &#125;); var timer,wait = 60; function time() &#123; if (wait == 0) &#123; $(&quot;#inputGetVerify&quot;).css(&#123; &quot;background&quot;: &quot;#fff&quot; &#125;); $(&quot;#inputGetVerify&quot;).text(&quot;获取验证码&quot;); wait = 60; flag = true; &#125; else &#123; $(&quot;#inputGetVerify&quot;).text(&quot;重新发送(&quot; + wait + &quot;)&quot;); wait--; timer = setTimeout(function () &#123; time(); &#125;, 1000); &#125; &#125; time(); $.post(&quot;/api/Account/RegSendSms&quot;, &#123; phone: $.trim($(&quot;#inputTel&quot;).val()) &#125;, function (json) &#123; if (json.code != 1) &#123; $(&quot;#inputGetVerify&quot;).css(&quot;background&quot;, &quot;#fff&quot;).text(&quot;获取验证码&quot;); clearTimeout(timer); flag = true; $(&quot;.tisi&quot;).html(json.data); &#125; &#125;); &#125; else &#123; return; &#125; &#125; else &#123; return; &#125;&#125;); 2.事先失去焦点后校验 ： 123456789var inputTelStatus = 0; //全局使用 是否校验通过$(&quot;#inputTel&quot;).blur(function()&#123; if((/^[1-9]\\d*$/.test($(&quot;#inputTel&quot;).val())))&#123; inputTelStatus = 1; &#125; else &#123; inputTelStatus = 0; $(&quot;.tisi&quot;).html(&quot;请输入正确的手机号码！&quot;); &#125;&#125;); 3.提交注册和Enter监听和登录模块如出一辙，这里就不赘述了。","tags":[{"name":"登录","slug":"登录","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%99%BB%E5%BD%95/"},{"name":"注册","slug":"注册","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E6%B3%A8%E5%86%8C/"}]},{"title":"通过js判断五大浏览器及其版本","date":"2018-04-10T13:16:00.000Z","path":"2018/04/10/js判断浏览器类型版本/","text":"摘要：浏览器兼容是Web开发人员挥之不去的阴霾。 此文主要参考至：heartbeaty 1. 单独判断是否IE浏览器： 1234567891011//判断是否是IE浏览器 function isIE() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 if(isIE) &#123; return &quot;1&quot;; &#125; else &#123; return &quot;-1&quot;; &#125;&#125; 2. 判断是否是IE浏览器及其版本，包括Edge浏览器 ： 1234567891011121314151617181920212223242526272829//判断是否是IE浏览器及其版本，包括Edge浏览器 function IEVersion() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 var isEdge = userAgent.indexOf(&quot;Windows NT 6.1; Trident/7.0;&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 if(isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\\\d+\\\\.\\\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) &#123; return &quot;IE7&quot;; &#125; else if(fIEVersion == 8) &#123; return &quot;IE8&quot;; &#125; else if(fIEVersion == 9) &#123; return &quot;IE9&quot;; &#125; else if(fIEVersion == 10) &#123; return &quot;IE10&quot;; &#125; else if(fIEVersion == 11) &#123; return &quot;IE11&quot;; &#125; else &#123; return &quot;0&quot; &#125; //IE版本过低 &#125; else if(isEdge) &#123; return &quot;Edge&quot;; &#125; else &#123; return &quot;-1&quot;; //非IE &#125;&#125; 3. 判断浏览器类型及其IE版本 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//判断浏览器类型及其IE版本function BrowserType() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 var isEdge = userAgent.indexOf(&quot;Windows NT 6.1; Trident/7.0;&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器 var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器 var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断Chrome浏览器 if(isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\\\d+\\\\.\\\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) &#123; return &quot;IE7&quot;; &#125; else if(fIEVersion == 8) &#123; return &quot;IE8&quot;; &#125; else if(fIEVersion == 9) &#123; return &quot;IE9&quot;; &#125; else if(fIEVersion == 10) &#123; return &quot;IE10&quot;; &#125; else if(fIEVersion == 11) &#123; return &quot;IE11&quot;; &#125; else &#123; return &quot;0&quot; &#125; //IE版本过低 &#125; //isIE end if(isFF) &#123; return &quot;FF&quot;; &#125; if(isOpera) &#123; return &quot;Opera&quot;; &#125; if(isSafari) &#123; return &quot;Safari&quot;; &#125; if(isChrome) &#123; return &quot;Chrome&quot;; &#125; if(isEdge) &#123; return &quot;Edge&quot;; &#125;&#125; 附. IE9以前判断IE浏览器经典方法 ： 123var ie = !-[1,]; alert(ie); 分析：在非标准浏览器（IE9-）里面，不会自动忽略数组最后一个逗号，而是在后面补齐undefined，所以在IE9以下不包括IE9中[1,]会被当做[1,undefined]，此时在数组前面加-号返回NaN，取非!操作返回true。","tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"通过js判断微信、QQ等内置浏览器并在外部浏览器打开","date":"2018-04-09T13:50:00.000Z","path":"2018/04/09/js判断内置浏览器/","text":"摘要：每段5Luj56CB都有领悟。 已经是第二个关于移动端支付的项目，对支付需求也更加精细化了，不仅需要扫码支付，还有唤醒App支付，另外还有在微信、QQ、支付宝内置浏览器给出相应的提示。 好在国内各大巨头公司在开发浏览器的时候都在浏览器标识上加了相应的字符，下面直接贴代码： 1234567891011function is_neizhi() &#123; var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123; return &quot;weixin&quot;; &#125; else if (ua.match(/QQ/i) == &quot;qq&quot;) &#123; return &quot;QQ&quot;; &#125; else if (ua.match(/Alipay/i) == &quot;alipay&quot;) &#123; return &quot;alipay&quot;; &#125; return false;&#125; 由此可以判断是否是App内置浏览器或者更加精细到某App内置浏览器。但是略坑的是：微信支付不管是在QQ、微信还是支付宝内置浏览器里面都不能被唤醒；支付宝支付可以在支付宝内置浏览器唤醒，其余则不能。 在外部浏览器打开是用jquery遮罩层方式写的，下面直接贴代码： 123456789101112131415161718192021222324252627var isNeizhi = is_neizhi(); //调用上面js判断var winHeight = typeof window.innerHeight != &#x27;undefined&#x27; ? window.innerHeight : document.documentElement.clientHeight; //网页可视区高度var weixinTip = $(&#x27;&lt;div id=&quot;weixinTip&quot;&gt;&lt;p&gt;&lt;img src=&quot;live_weixin.png&quot; alt=&quot;微信打开&quot;/&gt;&lt;/p&gt;&lt;/div&gt;&#x27;);if(isNeizhi)&#123; $(&quot;body&quot;).append(weixinTip);&#125;$(&quot;#weixinTip&quot;).css(&#123; &quot;position&quot;: &quot;fixed&quot;, &quot;left&quot;: &quot;0&quot;, &quot;top&quot;: &quot;0&quot;, &quot;height&quot;: winHeight, &quot;width&quot;: &quot;100%&quot;, &quot;z-index&quot;: &quot;1000&quot;, &quot;background-color&quot;: &quot;rgba(0,0,0,0.8)&quot;, &quot;filter&quot;: &quot;alpha(opacity=80)&quot;,&#125;);$(&quot;#weixinTip p&quot;).css(&#123; &quot;text-align&quot;: &quot;center&quot;, &quot;margin-top&quot;: &quot;10%&quot;, &quot;padding-left&quot;: &quot;5%&quot;, &quot;padding-right&quot;: &quot;5%&quot;&#125;);$(&quot;#weixinTip p img&quot;).css(&#123; &quot;max-width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;auto&quot;&#125;); 当然，提示的图片素材你得要有一张，最终效果如下：","tags":[{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"}]},{"title":"部分手机浏览器不支持ES6","date":"2018-04-06T02:50:00.000Z","path":"2018/04/06/手机浏览器兼容ES6/","text":"摘要：本文仅是记录在开发某个项目时遇到问题的一些调试思路及其解决方法，不足以道也。 最近在开发一个响应式的网站并且链到商户后台，主要采用Bootstrap3、Jquery、foundation-datepicker、SweetAlert2来开发。 主要功能有功能介绍、产品购买、订单查询、商户后台管理等，PC端测试良好，当开启局域网在移动上面测试时，点击立即购买毫无反应，这下就有点尴尬了。 想着在js文件开头加句alert(111);，再次点击非常给力，还是依然尴尬。 是不是bootstrap的button元素和某些东西冲突，点击事件没触发，那就换上&lt;a&gt;&lt;/a&gt;、&lt;input type='button' name='' /&gt;标签，依然尴尬。 是不是没有事件委托，元素DOM加载出来后事件没有监听，点击事件也不会触发，那就换上$(&quot;parent&quot;).on(&quot;click&quot;,&quot;child&quot;,function()&#123;...&#125;)写法，还是尴尬。 是不是手机浏览器不支持click事件，那就单独对浏览器Touch事件判断并触发： 1234567var hasTouch=function()&#123; var touchObj=&#123;&#125;; touchObj.isSupportTouch = &quot;ontouchend&quot; in document ? true : false; touchObj.isEvent=touchObj.isSupportTouch?&#x27;touchstart&#x27;:&#x27;click&#x27;; return touchObj.isSupportTouch; // ture or false&#125; 判断浏览器是否支持Touch事件，如需了解Touch事件详情请移步站内相关文章，当返回ture时，再做下一步操作，依旧无效。 我开始怀疑人生了，因为在上一个项目中也是类似的写法，华为自带浏览器兼容良好，而这次既然挂了，从天上到地下的感觉。于是在HTML页面底部加上script脚本，调用alert弹出窗，竟然可以弹出窗口， 差不多可以定位是js文件除了问题，其实在上面alert无法弹出时也是可以定位的，再进一步思考，可能有js报错导致js文件终止执行，既然是报错为什么PC端可以执行，而且之后用手机360浏览器、手机百度 测试正常，这时候可以考虑兼容问题了，兼容问题导致js文件终止执行。 通过比对上一个项目和这个项目的js写法，发现这个项目在采用SweetAlert2插件时用了如下的ES6写法，导致【华为】和【苹果】自带浏览器无法执行js文件。 1234567891011swal(&#123; html: &quot;&lt;p&gt;这是p段落标签&lt;/p&gt;&quot;, showCancelButton: true, focusConfirm: false, confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then((result)=&gt;&#123; if(result.value)&#123; window.location.href = &quot;uri...&quot;; &#125; &#125;) 箭头函数改成ES5写法： 1234567891011swal(&#123; html: &quot;&lt;p&gt;这是p段落标签&lt;/p&gt;&quot;, showCancelButton: true, focusConfirm: false, confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(function (result) &#123; if(result.value)&#123; window.location.href = &quot;uri...&quot;; &#125; &#125;) 问题解决，也不用怀疑人生了。 因为上面写法采用的是ES6的Promise对象提供的方法。补充一下关于某些手机浏览器不支持ES6 Promise的解决方法。 复写Promise函数，把ES6的Promise写法转换成ES5的写法，这里提供一个Google在线转换链接http://google.github.io/traceur-compiler/demo/repl.html#。 使用bluebird.js兼容Promise函数。 可以使用babel转换代码。","tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/ES6/"}]},{"title":"NodeJs连接MySQL数据库","date":"2018-04-02T15:12:00.000Z","path":"2018/04/02/NodeJs连接MySQL数据库/","text":"参加了两次FCC线下活动，主题偏向于后端数据分析，后端大神们分享的如python、julia，对于我这个前端小菜更是一窍不通，好在有大神分享了一些工作上面的宝贵经验，最后总结一点：代码语言只是工具，最重要的是思维方式。例如：当拿到这批数据的时候，我想的是怎么在我现有的技术栈前提下把需要的数据提取出来，当然首选NodeJs+MySQL提取数据，之后再在前端显示出来。好，下面就来看看怎么实行的把。 一.安装所需模块 想要Nodejs数据显示在前端，有两种方式：一是纯原生拼接HTML字符串，渲染到某个页面；二是使用模板引擎渲染。 安装NodeJs，点击官网下载安装即可。 安装MySQL数据库，点击官网下载安装即可。当然，为了更直观的可视化操作MySQL数据库，也可以选择安装SQLyog可视化工具。 安装Express框架，npm install express --save，框架默认搭载ejs模板，当然也可以选择jade。 安装ejs模板，npm install ejs --save。 安装Node的mysql数据库模块，npm install mysql --save，–save是否本目录保存还是全局安装的区别。 依赖模块如package.json: 1234567&#123; &quot;dependencies&quot;: &#123; &quot;ejs&quot;: &quot;^2.5.8&quot;, &quot;express&quot;: &quot;^4.16.2&quot;, &quot;mysql&quot;: &quot;2.6.2&quot; &#125;&#125; 二.连接MySQL数据库 新建settings.js文件，写入连接配置。 12345678var settings = &#123;&#125;;settings.db = &#123; host: &#x27;localhost&#x27;, user: &#x27;root&#x27;, password: &#x27;123456&#x27;, database: &#x27;datasname&#x27;&#125;module.exports = settings; 二.NodeJs后台文件 新建contact.js文件，写入后台配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//导入相应模块var express = require(&#x27;express&#x27;);var mysql = require(&#x27;mysql&#x27;);var app = express();var settings = require(&#x27;./settings&#x27;);// 设置模板路径，默认为./views app.set(&#x27;views&#x27;, __dirname + &#x27;/views&#x27;); //视图文件目录app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); var connection = mysql.createConnection(settings.db);//创建一个connectionconnection.connect(function(err)&#123; if(err) throw err; console.log(&#x27;-----------connection connect succeed!------------&#x27;);&#125;); //执行SQLvar sql = &#x27;SELECT col1,col2 from tablename&#x27;;arr = [];connection.query(sql, function(err,result)&#123; if(err) throw err; //处理数据 for(var index in result)&#123; arr.push(result[index]); &#125;&#125;);//设置根目录文件app.get(&#x27;/&#x27;, function(req, res)&#123; res.render(&#x27;index&#x27;,&#123;title:&#x27;Express模板&#x27;, data: arr&#125;); &#125;);//api接口 抛出数据app.get(&#x27;/pageApi&#x27;, function(req, res)&#123; res.send(&#123;page:1&#125;); //发送响应数据&#125;);//输出值 ajax所在的请求页app.get(&#x27;/ajaxtest&#x27;, function(req, res)&#123; res.render(&#x27;ajaxtest&#x27;,&#123;&#125;); &#125;);//关闭connectionconnection.end(function(err)&#123; if(err) throw err; console.log(&#x27;-----------connection end succeed!----------------&#x27;);&#125;);//监听服务app.listen(3000); 三.视图文件 由于上面文件配置，在项目目录下新建views。 新建index.ejs。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;title&gt; &lt;%=title%&gt; &lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;style&gt; span&#123; display: block; width: 90px; float: left; &#125; li&#123; width: 330px; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;% for(var i in arr)&#123; %&gt; &lt;li&gt; &lt;span&gt;playerID：&lt;%= data[i].col1 %&gt;&lt;/span&gt; &lt;span&gt;yearID：&lt;%= data[i].col2 %&gt;&lt;/span&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 新建pageApi.ejs，作为api的载体。 其实不需要写任何东西，实在过意不去就写个HTML5骨架吧。 新建ajaxtest.ejs，作为api数据显示页。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;p&gt;这是ajax渲染nodejs数据页面&lt;/p&gt;&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;Page:&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314$(function()&#123; $.ajax(&#123; type: &quot;GET&quot;, url: &#x27;http://localhost:3000/pageApi&#x27;, dataType: &#x27;json&#x27;, success: function(data)&#123; $(&quot;#content p&quot;).text(data.page); console.log(data); &#125;, error: function(err)&#123; console.log(err); &#125; &#125;)&#125;) 四.运行 cmd进入终端，cd到项目所在目录，node contact.js运行启动服务。 在浏览器中输入localhost:3000，即可查看首页效果。 在浏览器中输入localhost:3000/ajaxtest，即可查看请求api数据显示效果，在控制台也把数据console.log()出来了。 最后小结一下，涉及知识：nodejs、npm、mysql、ajax、ejs、express等。","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/NodeJs/"},{"name":"mySQL","slug":"mySQL","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/mySQL/"}]},{"title":"如何把项目托管到git Coding","date":"2018-03-27T13:50:00.000Z","path":"2018/03/27/项目推送到coding/","text":"安装git，到Coding上面注册账号，并且新建一个项目，这是前提： 在所在项目目录文件下右键选中Git bash Here进入Git终端 1. 初始添加git管理 123$ git init# Initialized empty Git repository in F:/File/Demo/Item/.git/# 初始化一个git空仓库 2. 克隆远程目标地址 123$ git clone https://git.coding.net/yourName/demo.git# Cloning into &#x27;demoTest&#x27;...# 克隆进行中。。。 3. 加入项目 12$ git add .# 加入项目 （注意add后面的空格） 4. 添加项目描述 12$ git commit -m &quot;init file&quot;# 添加项目描述 init file 5. 添加远程地址 12$ git remote add origin https://git.coding.net/yourName/demo.git# 添加远程推送地址 6. 推送到主线 12# git push origin master -f# 强制推送到主线","tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/Git/"}]},{"title":"AngularJS通过$location获取及操作当前页面的URL","date":"2018-03-22T14:50:00.000Z","path":"2018/03/22/AngularJS操作URL/","text":"本文中的所有操作基于http://localhost:29000/#/HomePage?type=2&amp;name=jhon地址。 一. 获取url的相关方法（不修改URL）: 1.获取当前完整的url路径 12var absurl = $location.absUrl(); //http://localhost:29000/#/HomePage?type=2&amp;name=jhon 2.获取当前url路径(当前url#后面的内容,包括参数和哈希值): 12var url = $location.url(); // 结果：/HomePage?type=2&amp;name=jhon 3.获取当前url的子路径(也就是当前url#后面的内容,不包括参数) 12var pathUrl = $location.path() //结果：/HomePage 4.获取当前url的协议(比如http,https) 12var protocol = $location.protocol(); //结果：http 5.获取主机名 12var localhost = $location.host(); //结果：localhost 6.获取当前url的端口 12var port = $location.port(); //结果：29000 7.获取当前url的哈希值 12var hash = $location.hash() //结果：&quot;&quot; 8.获取当前url的参数的序列化json对象 12var search = $location.search(); //结果：&#123;type: &quot;2&quot;, name: &quot;jhon&quot;&#125; 二. 修改url的相关方法(改变URL相关内容): 1.修改url的子路径部分(也就是当前url#后面的内容,不包括参数): 12$location.url(&#x27;/validation&#x27;); //结果：http://localhost:29000/#/validation 2.修改url的哈希值部分 12$location.hash(&#x27;myhash3&#x27;); //结果：http://localhost:29000/#/validation#myhash3 3.修改url的参数部分(第一个参数表示url参数的属性名,第二个参数是该属性名的属性值,如果是已有属性名,则修改,如果不是已有属性,则新增) 12345$location.search(&#x27;type&#x27;,&#x27;111&#x27;) // 结果(修改参数值)：http://localhost:29000/#/HomePage?type=111&amp;name=jhon $location.search(&#x27;name&#x27;,&#x27;111&#x27;) // 结果（新增ids参数): http://localhost:29000/#/HomePage?type=111&amp;name=111 4.一次性修改多个参数 12$location.search(&#123;type:&#x27;55&#x27;,&#x27;name&#x27;:&#x27;66&#x27;&#125;) //结果：http://localhost:29000/#/HomePage?type=55&amp;name=66 5.第一个值表示url参数的属性名,如果是已有属性名,则删除该属性,如果不是已有属性,那就等于没改过 12$location.search(&#x27;name&#x27;,null)//结果： http://localhost:29000/#/HomePage?type=2 三、修改URL但不存入历史记录 在上面的修改url的方法的时候,每修改一次,url都会被存入历史记录,可以使用后退按钮回到修改前的url,如果不想要这种效果,而仅仅是替换当前的记录,可以使用$location.path('/validation').replace();。","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/AngularJS/"}]},{"title":"CSRF跨站攻击","date":"2018-03-21T13:34:00.000Z","path":"2018/03/21/CSRF跨站攻击/","text":"作为一名开发者都少不了遇到web安全这个话题，不管是在平时开发还是面试过程中，网络安全人员更加。所以饶有兴趣的了解了一下CSRF，下面我们来看看它到底是什么gui。 CSRF是什么？ CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 CSRF可以做什么？ 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF漏洞示例 CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI…… 而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 CSRF的原理 下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 如何防御CSRF CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 Cookie Hashing 所有表单都包含同一个伪随机值。 这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 验证码 这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 One-Time Tokens 不同的表单包含一个不同的伪随机值。 在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。 转载：原文地址http://blog.nsfocus.net/fix-summary-csrf/","tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/CSRF/"},{"name":"web安全","slug":"web安全","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"window.open在Safari中不能打开的问题","date":"2018-03-13T14:35:00.000Z","path":"2018/03/13/window.open在Safari中不能打开的问题/","text":"今天在调移动支付问题的时候遇到过，用window.open打开一个微信支付链接，唤醒移动支付，在IOS下死活唤醒不了，是js代码冲突问题…是click事件IOS下不兼容问题…最后定位到window.open语句，之后改为window.loaction.href，奇迹般的可以唤醒支付，因此，也就很直观的证明了在Safari下用window.open是有问题的，所以在网上搜寻下各方大佬的解决方案。 我们先来看下window.open()，其作用是创建一个新的浏览器窗口用来打开相关的资源，这是一个原生的JavaScript API接口。有关有关window.open()的基本使用可以参考 mozilla 提供的 API 文档：window.open 。 大部分现代的浏览器（Chrome/Firefox/IE 10+/Safari）都默认开启了阻止弹出窗口的策略，原因是window.open被广告商滥用，严重影响用户的使用。这个阻止弹出窗口的操作，并不是直接封杀window.open()，而是会根据用户的行为来判断这次window.open()是否属于流氓操作。 如果是由用户触发的动作所引起的 window.open 就不会被浏览器所阻止，比如写在 onclick 这些事件 handler 里的，但如果是代码自己触发的就会被阻止。 那么，我们可以知道，在Safari中无法open新窗口，原因是Safari的安全机制将其阻挡。 那么，如果我们的需求是通过Ajax请求数据后，在成功的回调函数中open一个相关的窗口，显然正常手段是没法在Safari中搞定的。 那么，如何解决该问题呢？很简单，直走不行绕着走，绕过这个安全机制，也就是说在你调用Ajax之前，先打开这个窗口，然后在回调函数里面修改打开窗口的location，这样就可以解决。 示例代码： 123456789101112var openWin = function()&#123; var winRef = window.open(&quot;url&quot;,&quot;_blank&quot;); $.ajax(&#123; type: &#x27;&#x27;, url: &#x27;&#x27;, data: &#x27;&#x27;, ...... success:function(json)&#123; winRef.location = &quot;新的url&quot;; &#125; &#125;);&#125;; 不过，由于种种原因，window.open()经常会被阻止掉，我们可以根据window.open()的返回值来判断其执行情况，代码如下： 123456var winOpen = window.open(&quot;url&quot;,...);if(winOpen == null || typeof(winOpen) == &#x27;undefined&#x27;)&#123; consoel.log(&quot;窗口无法打开，请检查浏览器！&quot;);&#125;else&#123; consoel.log(&quot;窗口打开成功！&quot;);&#125; 这样的话，就可以在界面上比较清晰的告知用户是怎么回事了。","tags":[{"name":"safari","slug":"safari","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/safari/"}]},{"title":"a标签使用href=\"javascript:;\" 在火狐IE浏览器跟chrome 不兼容","date":"2018-03-13T14:10:01.000Z","path":"2018/03/13/a标签的href属性值在火狐IE浏览器跟chrome不兼容/","text":"在调霸哥的时候发现，使用如下的链接方式，在Chrome下阻止了a的默认事件–正常，但是在Firefox下却会打开一个新的空页面，根据资料和测试发现，IE下也有此问题。 1&lt;a href=&quot;javascript:;&quot; target=&quot;_blank&quot;&gt;点击&lt;/a&gt; 后经查找，可如下解决： 通过onclick阻止事件的默认行为：&lt;a href=&quot;javascript:;&quot; onclick=&quot;return false;&quot; target=&quot;_blank&quot;&gt;点击&lt;/a&gt; 直接删除：&lt;a target=&quot;_blank&quot;&gt;点击&lt;/a&gt; 原因在于三款浏览器，对三个属性的处理顺序不同。 Chrome顺序：onclick -&gt; href -&gt; target IE和Firefox顺序：onclick -&gt; target -&gt; href","tags":[{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"}]},{"title":"一个初级前端的上年总结","date":"2018-02-25T14:10:01.000Z","path":"2018/02/25/一个初级前端的上年总结/","text":"春节在家，寻思着写篇上年总结hexo到博客里面，无奈在家里断网和拖延症的双重作用下到现在还没有开始，明天就是上班的第一天，还是逼自己写一写，也算是对上一年有个交代。 年初的头一个月都在找工作，冒着一场大雨中去面试，还算找到一份比较不错的工作。之后由于赶项目上线比较忙，另一方面也确实拖延症犯。所以回过头来看下，记录也没有做几篇。所以今年要多分享，多记录，遇到问题都总结并记录下来，及时hexo到博客里面。 技术上 一月份便开始了新的工作，前端做为后端架构的辅助，在原有的AngularJs应用中进行二次开发，主要从事虚拟产品交易，也决定了我之后的工作在中后台web上。 对个人技术的成长有一些，首先是在AngularJs上，对它的指令、http服务、路由等有一定的了解，体会到09年出来的它为什么会如此受欢迎，然后是对前端的工程化模块化有进一步的理解，期间多为不同功能模块的的实现，比如微信支付宝支付模块等。在今年，要不断完善自己的技术栈，对Vue、小程序、ReactNative要更加熟悉，而不是停留在了解的份上。 业务上 由于目前处于初级水平，扎实提升自己技术是前提，初步对自己业务做个规划：在熟悉的平台拓展自己的业务，更好地规划并实现自己的CV站点，运营自己的公众号，研究WP后台系统的二次开发。 反思 回看过去一年，不足之处很多，并且有点侥幸心理。使自己略微懒惰，并没有真正的静下心来深入一些东西，就拿自己学react来说，只做了一个SPA，相当于了解了react基础，缺乏深入，也没有系统的记录一些东西。所以在戊戌之年，秉承变法精神，拔掉缺点，克服困难，人有的时候真的要逼自己前进。感谢过去一年遇见的人和事，尤其是不甘平凡的自己，正如那句话所说：没有比脚更长的路，没有比人更高的山。加油向蔚蓝！ ![爱的影子](http://zhongweipeng.cn/haveLove.jpg)","tags":[{"name":"人生","slug":"人生","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"IOS下Safari中click点击事件无效","date":"2018-02-15T15:00:01.000Z","path":"2018/02/15/IOS下Safari中click事件点击无效/","text":"做web移动端页面时，发现在ios真机上点击事件无效，然后各种找度娘，发现Safari下只有默认可点击的元素才click点击事件，像span div等元素是不具有点击事件的。在此归纳一下解决办法，也可参考本站js点击事件无效的这篇文章。 解决办法有 4 种可供选择： 将 click 事件直接绑定到目标​元素（​​即 .target）上 将目标​元素换成 或者 button 等可点击的​元素 将 click 事件委托到​​​​​非 document 或 body 的​​父级元素上 给​目标元素加一条样式规则 cursor: pointer; 推荐最后一种，因为在Safari中默认不可点击的元素也不会冒泡到父元素。用过cursor: pointer;使元素变为可点击的。","tags":[{"name":"click","slug":"click","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/click/"},{"name":"safari","slug":"safari","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/safari/"}]},{"title":"分析DOM绑定click事件无效及解决办法","date":"2018-02-14T14:09:01.000Z","path":"2018/02/14/分析DOM绑定click事件无效及解决办法/","text":"在项目中我们经常会遇到给DOM元素绑定click事件无效的问题，在此记录一下我所遇到的原因及解决办法。同时也加深对js事件处理机制（事件冒泡、事件捕获）的理解。 1.事件在某处被解绑 对DOM事件解绑一般不会导致click失效，但是在以下的情况，click事件会失效： 123456$(function()&#123; $(&quot;#btn&quot;).unbind();&#125;)$(&quot;#btn&quot;).click(function()&#123; //...&#125;); 由于$(function()&#123;&#125;)是DOM元素加载完毕后执行的函数，因此函数外部的绑定click事件函数先与$(function()&#123;&#125;)执行，在DOM元素加载完毕后对.button元素的监听事件进行解绑，所以点击事件失效，如果需要解绑事件，可以这样写： 123456$(function()&#123; $(&quot;#btn&quot;).unbind(); $(&quot;#btn&quot;).click(function()&#123; alert(&quot;点击了我！&quot;); &#125;);&#125;) 2.DOM元素是js动态加载、绑定事件的js文件是通过ajax异步加载的 这种情况DOM元素加载出来都需要一定的等待时间，在等待时间前对DOM元素添加事件是无效的。解决办法有两种： 1. 延迟DOM事件的添加时间 1234567$(function()&#123; setTimeout(function()&#123; $(&quot;#btn&quot;).click(function()&#123; //... &#125;); &#125;,500)&#125;) 2. 事件委托（事件代理）给父元素 12345$(function()&#123; $(&quot;.parent&quot;).on(&quot;click&quot;,&quot;#btn&quot;,function()&#123; //... &#125;);&#125;) 3.ajax异步加载的DOM元素 当需要用ajax载入某部分的html文件时，点击事件也会失效：一、可以在ajax执行成功的回调函数done()中添加事件；二、可以参照2中事件委托的方法。 4.点击a元素链接无跳转 这种情况可能有代码阻止了元素的默认行为导致无法跳转。 123456$(function()&#123; $(&quot;a&quot;).on(&quot;click&quot;,function(e)&#123; e.preventDefault(); //... &#125;);&#125;) 对事件进行解绑即可： 1234567$(function()&#123; $(&quot;a&quot;).on(&quot;click&quot;,function(e)&#123; e.preventDefault(); //... &#125;); $(&quot;a&quot;).unbind();&#125;) 最后小结一下，涉及知识：事件绑定、事件监听、事件捕获、事件冒泡、事件代理（委托）、js执行顺序。","tags":[{"name":"click","slug":"click","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/click/"}]},{"title":"18年的年前的工作总结","date":"2018-01-15T15:00:01.000Z","path":"2018/01/15/18年的年前的工作总结/","text":"从平静到曲折再归于平静，这是我对这三个月来的形容吧！平静的上下班，曲折的进入国家的专政区域，再归于平静的上下班，然而对于我来的说，后面的上下班和前面的上下班却截然不同，那是来自于一个月时间的体会和思考。 没错，这是一篇2018年前的工作的总结，是对于某份工作某个时期的总结，是对于前面时间段经历和教训的总结，虽然阳历18年已来半月之久，但是广大人民依旧在盼望着除夕大年的到来，不管你身在何方，不管你富有贫穷，到了那一刻，归心似箭，有家的地方才叫温暖。正如三毛那句所说的：家——就像有个人点着灯在等你。 这份工作是极逐慧心，其实挺感谢年前能够得到这个机会，我将尽我最大的努力来用拥抱这次机会，来证明他的选择没有错，至少不比某些戴着面具的伪公司、伪HR，表里不一，善始不善终。对于这样的公司，不去也罢。 毋庸置疑，上班就背上了前任留下的大锅，软猫应用平台，采用AngularJs+jquery+.NET开发的一个应用，第一天熟悉了一下开发环境，晚上看AngualrJs语法，第二天就开搞，特别有种赶鸭子上架的感觉，之后了解了AngularJs的路由配置、控制器、Http、PC端和移动端页面的制作、应用页面的配置、微信支付宝支付，这里特别说一下在前端方面微信支付和在支付宝支付的区别，支付宝支付比较简单，通过调用接口使浏览器打开一个空白页面，这个页面就是支付宝提供的支付页面，但是微信支付不同，它没有页面跳转，通过接口可以获取付款码，在前端方面我们需要模拟扫码弹框显示付款二维码，后台通过定时器不断获取付款状态判断是否完成付款。更多功能和黑锅等待进一步发掘中。 下一步，随着功能的不断扩大，复杂程度也不断加剧，可想而知，但这都不能成为你退缩的理由。上文已经说过，此时的上班非彼时的上班。人生的每次出现都有其存在的意义，是你的，欣然等待，非你的，静观其变，我们要做的就是，不断地积累和提升自己。只有充足的准备才有资格拥抱更大的机会，此时的我们，才能笑看蔚蓝。 ![爱的影子](http://zhongweipeng.cn/timg.jpg)","tags":[{"name":"人生","slug":"人生","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"人生所有经过的路，都是必经之路","date":"2017-12-31T16:00:01.000Z","path":"2018/01/01/人生所有经过的路，都是必经之路/","text":"我在207遇到一位长者，算是我的室长吧，是研究生毕业，也是企业高管。可以说他是我在207对我影响比较深的人。从心理和生活上都对关怀有加吧。 初见这位室长大人，心里有些惶恐不安，很似水浒传中的冷面者，不过细处下来也是通情达理之人，常对我说：“小钟啊，既来之则安之”，“你说你这小孩，这么大了还不会照顾自己”。在他充满丰富阅历的眼光看来，我还只是一个孩子，也许是一个刚毕业涉世未深的孩子吧。 所谓人生所有经过的路，都是必经之路，既然都是必经之路，我们就不要感觉遗憾。而在现实当中，往往又透出了遗憾。而遗憾，我向来认为是人生的主旋律，但遗憾的后面又藏着什么？是不甘。所以，“必经之路”一词作为糟糕经历的总结是最好不过了。 这一个月中，我看到了形态各异的身影，他们每个人都只能在被设定好的圆圈内跳舞，他们每个人也都向往自由，而有些人的自由却是遥不可及，也许有时候我们真的不需要在意那些什么金钱名利，也许有时候并不知道我们拥有的自由是多么的可贵。那时的我每天晚上在固定的圆圈里踱步两小时，一是为了驱寒，二也是在思索，自由是多么美好的东西，然而在这之前，我从未感觉过自由是那么珍贵的一种东西。 也对，人生有时候就是很奇妙，并不要因为你现在是什么样子就潜意识认为你以后是什么样子，也并不意味着你现在是什么角色就形象的认为你以后是什么角色。出来工作后这一年，我尤其体会到世间太多的不如意，我们又能怎样，放手？可是我们的生活还是的继续，真羡慕以前的竹林七贤，怡然自得于山水之间，以天为被，以地为榻。试问现代有几人能有这等豪气。 我只是想说，上帝为你关闭一扇门也同时为你打开一扇窗。人生充满了可能，想做什么，就挽起袖子加油干，再加上点坚持与毅力，没有什么是不可能的。 异样经历怕什么，更好的旅程即将开启。 ![爱的影子](http://zhongweipeng.cn/timg.jpg)","tags":[{"name":"人生","slug":"人生","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"jquery实现毫秒和标准时间的相互转换","date":"2017-12-31T03:58:00.000Z","path":"2017/12/31/jquery实现毫秒和标准时间的相互转换/","text":"有次测试中后台api返回的日期是Unix时间戳格式，这时需要用到格式转换，直接扒拉代码贴上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455(function($) &#123; $.extend(&#123; myTime: &#123; /** * 当前时间戳 * @return &lt;int&gt; unix时间戳(秒) */ CurTime: function()&#123; return Date.parse(new Date())/1000; &#125;, /** * 日期 转换为 Unix时间戳 * @param &lt;string&gt; 2014-01-01 20:20:20 日期格式 * @return &lt;int&gt; unix时间戳(秒) */ DateToUnix: function(string) &#123; var f = string.split(&#x27; &#x27;, 2); var d = (f[0] ? f[0] : &#x27;&#x27;).split(&#x27;-&#x27;, 3); var t = (f[1] ? f[1] : &#x27;&#x27;).split(&#x27;:&#x27;, 3); return (new Date( parseInt(d[0], 10) || null, (parseInt(d[1], 10) || 1) - 1, parseInt(d[2], 10) || null, parseInt(t[0], 10) || null, parseInt(t[1], 10) || null, parseInt(t[2], 10) || null )).getTime() / 1000; &#125;, /** * 时间戳转换日期 * @param &lt;int&gt; unixTime 待时间戳(秒) * @param &lt;bool&gt; isFull 返回完整时间(Y-m-d 或者 Y-m-d H:i:s) * @param &lt;int&gt; timeZone 时区 */ UnixToDate: function(unixTime, isFull, timeZone) &#123; if (typeof (timeZone) == &#x27;number&#x27;) &#123; unixTime = parseInt(unixTime) + parseInt(timeZone) * 60 * 60; &#125; var time = new Date(unixTime * 1000); var ymdhis = &quot;&quot;; ymdhis += time.getUTCFullYear() + &quot;-&quot;; ymdhis += (time.getUTCMonth()+1) + &quot;-&quot;; ymdhis += time.getUTCDate(); if (isFull === true) &#123; ymdhis += &quot; &quot; + time.getUTCHours() + &quot;:&quot;; ymdhis += time.getUTCMinutes() + &quot;:&quot;; ymdhis += time.getUTCSeconds(); &#125; return ymdhis; &#125; &#125; &#125;);&#125;)(jQuery); 日期转换时间戳： 1$.myTime.DateToUnix(&#x27;2014-5-15 20:20:20&#x27;)); 时间戳转换日期： 1$.myTime.UnixToDate(1325347200)","tags":[{"name":"jquery","slug":"jquery","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/jquery/"},{"name":"js","slug":"js","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/js/"}]},{"title":"react搭建一个案例演示型网站","date":"2017-08-02T06:30:00.000Z","path":"2017/08/02/react搭建一个案例演示型网站/","text":"最近用react + antdesign搭建了一个Demo演示型站点，包括PC端和移动端的适配。可以给我的练习或者项目一个很好展现效果，github地址https://github.com/joydezhong/demo-display-project，效果图如下： PC端效果： 移动端效果： 用法介绍 1. 安装依赖 1-&gt; npm install 2. 启动服务 1-&gt; webpack-dev-server 浏览器访问 http://localhost:8080 即可查看 3. 站点配置 主要目录介绍： images: 网站Logo、轮播图、项目缩略图存放目录。 components: 各组件存放目录。 导航配置： pc_header.js模块的Menu配置a链接可实现跳转。 演示案例配置： pc_content.js模块引用的PCitems组件中itemTitle、itemSrc、imgSrc属性可实现demo标题、demo链接、demo缩略图的配置。 mobile_content.js模块引用的Mobileitems组件中itemTitle、itemSrc、imgSrc属性可实现demo标题、demo链接、demo缩略图的配置。 注：项目将在不断优化中，请戳下面提出宝贵的意见 ^_^。。。","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"css样式优先级及其权重的计算","date":"2017-07-27T14:20:00.000Z","path":"2017/07/27/css样式优先级及其权重的计算/","text":"一、引入样式的类型 1. 行内样式： 在元素的标签内用style=&quot; &quot;的方式引入样式，不过现在都是内容、样式、行为的分离，这种方式容易造成代码的混乱，不利于代码的维护。 2. 内嵌样式： 在html页面中用&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;style标签来内嵌css样式，其缺点和行内样式差不多。 3. 外部样式： 这里的外部样式分两种，一种是@import导入式，另一种是&lt;link rel=&quot;stylesheet&quot; href=&quot;xx.css&quot; type=&quot;text/css&quot; /&gt;标签链接式。 @import： 将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，使用的语法如下： 12345&lt;style type=&quot;text/css&quot;&gt; @import&quot;style.css&quot;; /*此处要注意.css文件的路径*/&lt;/style&gt; link： 也是将一个.css文件引入到HTML文件中，但它与导入式不同的是链接式使用HTML规则引入外部CSS文件，使用语法如下： 1&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; 比较两者的区别 1.从属关系区别 @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 2.加载顺序区别 加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。 3.兼容性区别 @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。 4.DOM可控性区别 可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。 二、css选择器的类型 1. 基本选择器： 包括三种基本选择器：通配符*选择器、标签选择器、class类名选择器、ID选择器。 2. 层级选择器： 包括后代选择器div p&#123; &#125;、子元素选择器ul&gt;li&#123; &#125;、相邻兄弟选择器div+p&#123; &#125;（所有与div同级并且相邻的第一个p元素）、通用兄弟选择器div~p&#123; &#125;（与div同级并且相邻的所有p元素）。 3. 群组选择器： 使用不同的选择器，用逗号,分隔，如：.red,p,li&#123; &#125;。 4. 属性选择器： 使用[]作为属性的筛选标志，如：[target=_blank]选择含有target属性并且值为_blank的所有元素。 5. 伪类选择器（伪对象选择器）： 伪类（:）一般反映无法在CSS中轻松或者可靠检测到的某个元素的状态或者属性； 伪元素（::）表示DOM外部的某种文档结构。 在css3中规范推荐伪对象选择器使用（::），这样就更好的区别伪类和伪对象。 伪对象选择器： E:first-letter/E::first-letter CSS1/3 设置对象内的第一个字符的样式 E:first-line/E::first-line CSS1/3 设置对象内的第一行的样式 E:before/E::before CSS2/3 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E:after/E::after CSS2/3 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E::placeholder CSS3 设置对象文字占位符的样式 E::selection CSS3 设置对象被选择时的颜色 三、优先级及权重 1. 优先级的分类： 第一优先级：无条件优先的属性只需要在属性后面使用！important。它会覆盖页面内任何位置定义的元素样式。ie6不支持该属性。 第二优先级：在html中给元素标签加style，即内联样式。该方法会造成css难以管理，所以不推荐使用。 第三优先级：由一个或多个id选择器来定义。例如，#id{margin:0;}会覆盖.classname{margin:3pxl} 第四优先级：由一个或多个类选择器、属性选择器、伪类选择器定义。如.classname{margin:3px}会覆盖div{margin:6px;} 第五优先级：由一个或多个类型选择器定义。如div{marigin:6px;}覆盖*{margin:10px；} 第六优先级：通配选择器，如*{marigin:6px;} 2. 优先级的权重计算规则： 我们把每个等级的选择器赋予相应的值，在选择器中符合哪个等级就把相应的值相加就是该选择器的权重值。 第一等级：代表内联样式，如style=&quot;&quot;，权值为 1000 第二等级：代表id选择器，如#content，权值为100 第三等级：代表类，伪类和属性选择器，如.content，权值为10 第四等级：代表标签选择器和伪元素选择器，如div p，权值为1 注意：通用选择器（*），子选择器（&gt;），和相邻同胞选择器（+）并不在这个等级中，所以他们的权值为0 div.test1 .span var 优先级 1+10 +10 +1 span#xxx .songs li 优先级1+100 + 10 + 1 #xxx li 优先级 100 +1","tags":[{"name":"css","slug":"css","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/css/"}]},{"title":"在react中实现跨域的fetch请求","date":"2017-07-26T12:29:00.000Z","path":"2017/07/26/在react中实现跨域的fetch请求/","text":"最近用react实现一个响应式的新闻展示的应用，主要技术react + antdesign + fetch + react-router，新闻数据来自网上公共api，在用fetch请求api时报错， 原因是服务端没有设置响应header为Access-Control-Allow-Origin：*，因为是公共api无法从服务端解决问题，只能在前端跨域解决。使用fetch-jsonp可以实现跨域请求，github链接; 1. fetch的用法 安装 1npm install fetch 用例 GET方法： 12345678fetch(&#x27;/url/api?data1=xx&amp;data2=xx&amp;data3=xx,&#123; method: &#x27;GET&#x27; &#125;).then(response=&gt;response.json()).then(json=&gt;&#123;something handle...&#125;).catch(function(error) &#123; console.log(&#x27;request failed&#x27;, error)&#125;); POST方法： 123456789101112131415161718var myFetchOptions = &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Access-Control-Allow-Origin&#x27;:&#x27;&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(&#123; data1: &#x27;xx&#x27;, data2: &#x27;xx&#x27;, data3: &#x27;xx&#x27; &#125;)&#125;;fetch(&quot;url/api&quot;, myFetchOptions) .then((response)=&gt;response.json()) .then(json=&gt;&#123;something handle...&#125;) .catch(function(error) &#123; console.log(&#x27;request failed&#x27;, error)&#125;); fetch用法采用ES6的promise写法，在上面的案例使用箭头函数，简化了函数的写法，包括参数和返回值，安装完fetch不用导入，可以直接使用，第一个参数为api，第二个参数为配置项，可设置请求头、请求模式、请求方法、请求参数等等，更多关于fetch高级用法请参考fetch的github文档。注意，报错图片中会提示把请求模式改为mode:'no-cors'，用于不透明的服务，即我们只需要请求，不关注是否响应数据，即响应状态为0时，它不继续进行重定向数据请求，对于需要返回数据的请求操作是毫无意义，所以我们接下来更加关注跨域请求，获取数据。 2. fetch-jsonp的用法 安装 12npm install fetch-jsonp 用例 注意：JSONP只支持GET方法，与fetch-jsonp相同： 用之前需要导入，不然会报错fetchJsonp未定义。 12345678import fetchJsonp from&#x27;fetch-jsonp&#x27;;fetchJsonp(&#x27;/uri/api?data1=xx&amp;data2=xx&amp;data3=xx) .then(response=&gt;response.json()) .then(json=&gt;&#123;something handle...&#125;) .catch(function(error) &#123; console.log(&#x27;request failed&#x27;, error)&#125;); 这里详细介绍这个response，这是请求api后响应(response)的相关数据，是一个Object，包括属性和主要的方法： 属性： status (number) - HTTP响应状态码在100–599之间 statusText (String) - 服务器的状态文本 ok (boolean) - 如何HTTP状态码是2xx headers (Headers) - 响应头 url (String) - 请求url 方法： text() - 生成数据为文本字符串时 json() - 生成数据为json类型时 blob() - 生成数据为Blob arrayBuffer() - 生成数据为ArrayBuffer formData() - 生成可以被转发到另一个请求的FormData 其他方法： clone() Response.error() Response.redirect() fetch和fetchJsonp常见的用法就是这么简单，更多高级用法请参考github文档。","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"初识react一，项目初始化","date":"2017-06-29T13:29:00.000Z","path":"2017/06/29/初识react一，项目初始化/","text":"react是目前前端比较火的三大框架之一，其以高性能的虚拟DOM、强大的facebook团队和庞大的社区获得广大开发者的青睐，以下包括这系列的文章也是我学习react的笔记，正如那句话所说：好记性不如烂博客，以下记录的是我初始化的第一个react项目。默认在安装了node的环境下。 一、npm配置开发环境 npm项目初始化 启动命令行工具，进入当前项目文件夹下，执行npm init初始化，一直回车使用默认设置，也可以自行更改，执行完毕会在项目文件夹下生成配置文件，定义了这个项目所需要的各种模块，以及项目的配置信息(比如名称、版本、许可证等元数据)。 安装依赖包 安装react和react-dom包，执行npm install --save react react-dom babelify babel-preset-react可以在关键字后面添加@xx.xx安装具体的版本，然后安装es6支持npm install babel-preset-es2015 --save。 二、webpack热加载配置 安装webpack 全局安装和项目下安装webpack和webpack服务工具。 123456npm install webpack -gnpm install webpack-dev-server -g//在项目目录下安装npm install webpack --savenpm install webpack-dev-server --save 初始化webpack配置文件 在项目文件夹下新建src目录和webpack.config.js文件，配置详情如下： 1234567891011121314151617181920212223242526var webpack = require(&#x27;webpack&#x27;);var path = require(&#x27;path&#x27;); module.exports = &#123; context: path.join(__dirname), //页面入口文件配置 entry: &#123; index : &#x27;./src/js/index.js&#x27; &#125;, //入口文件输出配置 output: &#123; path: __dirname, filename: &#x27;./src/bundle.js&#x27; &#125;, module: &#123; //加载器配置 loaders: [&#123; test: /\\.js?$/, exclude: /(node_modules)/, loader: &#x27;babel-loader&#x27;, query: &#123; presets: [&#x27;react&#x27;,&#x27;es2015&#x27;] &#125; &#125;] &#125;&#125;; 三、简单的项目代码 在项目下新建index.html文件，输入以下代码： 12&lt;div id=&quot;example&quot;&gt;Hello,react!&lt;/div&gt;&lt;script src=&quot;./src/bundle.js&quot;&gt;&lt;/script&gt; 在src目录里面新建js目录并在里面新建index.js文件，输入以下代码： 1234567var React = require(&quot;react&quot;);var ReactDOM = require(&quot;react-dom&quot;);ReactDOM.render( &lt;h1&gt;react大法好 66666666!&lt;/h1&gt;, document.getElementById(&quot;example&quot;) ); 四、打包启动项目 webpack打包，直接webpack命令；自动监控文件的改变webpack --watch；实时编译文件并自动刷新浏览器webpack-dev-server；编译后会自动在src目录下生成bundle.js。 五、调试 在chrome浏览器扩展程序里面有react的插件React Developer Tools，用于react的调试，地址https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapbkoienihi。 由于版本的不同，另附package.json依赖文件： 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;05-01&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.25.0&quot;, &quot;babel-loader&quot;: &quot;^6.4.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;babelify&quot;: &quot;^7.3.0&quot;, &quot;react&quot;: &quot;^15.3.2&quot;, &quot;react-dom&quot;: &quot;^15.3.2&quot;, &quot;webpack&quot;: &quot;^2.6.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.5.0&quot; &#125;&#125;","tags":[{"name":"react","slug":"react","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/react/"}]},{"title":"归纳javascript数组去重的多种方法","date":"2017-06-28T12:09:00.000Z","path":"2017/06/28/归纳javascript数组去重的多种方法/","text":"归纳的多种js数组去重复的方法，包括五种基本方法和ES6的三种简洁的方法。 1. 新数组法 思路： 判断数组每项值，值不在新数组就push进新数组 123456789var ary = [1,2,3,3,2,3,4,5];var newary = [];for(var i = 0; i &lt; ary.length; i++)&#123; if(newary.indexOf(ary[i]) == -1)&#123; newary.push(ary[i]); &#125;&#125;alert(newary); //[1,2,3,4,5] 2. 数组下表判断法 思路：类似第一种，判断值在数组中的索引，索引和i不相等就push进新数组 123456789var ary = [1,2,3,3,2,3,4,5];var newarr = [];for(var i = 0; i &lt; ary.length; i++)&#123; if(ary.indexOf(ary[i]) == i)&#123; newarr.push(ary[i]); &#125;&#125;alert(newarr);//[1,2,3,4,5] 3. 对象键值对法 思路：可以记录次数的对象去重，判断当前数组值作为对象的key是否存在值， 存在即把对象的值+1，否则值置为1，对象的key为数组的值，value为次数；此方法利用了object键的唯一性。 12345678910111213141516var ary = [1,2,3,3,2,3,4,5];var obj = &#123;&#125;;for(var i = 0; i &lt; ary.length; i++)&#123; var curvalue = ary[i]; if(obj[curvalue])&#123; obj[curvalue]++; &#125;else&#123; obj[curvalue] = 1; &#125;&#125;var ary=[];for(var attr in obj)&#123; ary.push(attr);&#125;alert(ary);//[1,2,3,4,5] 变式： 1234567891011var obj = &#123;&#125;, newarr = [], val, type; for (var i = 0; i &lt; array.length; i++) &#123; val = array[i]; type = typeof val; if (!obj[val]) &#123; obj[val] = type; newarr.push(val); &#125;&#125; alert(newarr);//[1,2,3,4,5] 4. 排序后相邻元素对比 思路：利用sort()方法先对数组进行排序后，相邻元素对比不同push到新数组。 1234567891011121314151617var array = [3,6,3,9,7,5,9,12];array.sort(function(x,y)&#123; if(x &lt; y)&#123; return -1; &#125;else if(x&gt;y)&#123; return 1 &#125; return 0;&#125;); var prevarr = [array[0]];for(var i = 1; i &lt; array.length; i++)&#123; if( array[i] !== prevarr[prevarr.length-1])&#123; prevarr.push(array[i]); &#125; &#125; alert(prevarr);//[3,5,6,7,9,12] 5. 优化遍历法 思路：利用双重循环，遇到重复元素跳出外层循环，进入下一次外层循环 这样就避免了重复元素的追加。有种冒泡排序的感觉0.0。 1234567891011var array = [12,252,32,32,22,12,45,50];var r = []; for(var i = 0, l = array.length; i &lt; l; i++) &#123; for(var j = i + 1; j &lt; l; j++) if (array[i] === array[j])&#123; j = ++i; &#125; r.push(array[i]); &#125; alert(r);//[252,32,22,12,45,50] 6. 利用ES6新特性的三种方法 思路：利用ES6中的Set数据结构，…扩展运算符，Array.from()数组转化的方法。 1. Set构造函数加…扩展运算符 123456const set = new Set([1,5,3,4,5,1,1,0]);var unique = [...set];alert(unique);//[1,5,3,4,0] 2. 函数传值加数组序列化方法 123456789function unique(array)&#123; return Array.from(new Set(array));&#125; unique([1,5,3,4,5,1,1,0]);alert(unique);//[1,5,3,4,0] 3. 类似第一种的转化 123456let arr = [1,5,3,4,5,1,1,0];var unique = [...new Set(arr)];alert(unique);//[1,5,3,4,0] 暂且归纳这么多，不足之处还请不吝赐教！","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/js/"}]},{"title":"Jquery ajax通用方法封装","date":"2017-06-08T14:10:00.000Z","path":"2017/06/08/Jquery ajax通用方法封装/","text":"JQuery封装一个属于自己的ajax函数，课提高代码的复用率。 1. 通用型ajax方法 123456789101112131415161718192021222324252627282930313233/** * ajax封装 * url 发送请求的地址 * data 发送到服务器的数据，数组存储，如：&#123;&quot;date&quot;: new Date().getTime(), &quot;state&quot;: 1&#125; * async 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 * 注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 * type 请求方式(&quot;POST&quot; 或 &quot;GET&quot;)， 默认为 &quot;GET&quot; * dataType 预期服务器返回的数据类型，常用的如：xml、html、json、text * successfn 成功回调函数 * errorfn 失败回调函数 */jQuery.ajx = function(url, data, async, type, dataType, successfn, errorfn) &#123; async = (async == null || async == &quot;&quot; || typeof(async) == &quot;undefined&quot;) ? &quot;true&quot; : async; type = (type == null || type == &quot;&quot; || typeof(type) == &quot;undefined&quot;) ? &quot;get&quot; : type; dataType = (dataType == null || dataType == &quot;&quot; || typeof(dataType) == &quot;undefined&quot;) ? &quot;json&quot; : dataType; data = (data == null || data == &quot;&quot; || typeof(data) == &quot;undefined&quot;) ? &#123; &quot;date&quot;: new Date().getTime() &#125; : data; $.ajax(&#123; type: type, async: async, data: data, url: url, dataType: dataType, contentType: &quot;application/json&quot;, success: function(data,status) &#123; successfn(data,status); &#125;, error: function(xhr,err) &#123; errorfn(xhr,err); &#125; &#125;);&#125;; 2. GET方式ajax方法 123456789101112131415161718192021/** * ajax Get封装 * url 发送请求的地址 * dataType 返回数据类型 * successfn 成功回调函数（d数据、txt状态码） * errorfn 失败回调（xhr http对象、e错误码） * */jQuery.ajxGet = function(url, dataType, successfn, errorfn) &#123; $.ajax(&#123; type: &quot;get&quot;, url: url, dataType: dataType, success: function(data,status) &#123; successfn(data,status); &#125;, error: function(xhr,err) &#123; errorfn(xhr,err); &#125; &#125;);&#125;; 3. POST方式ajax方法 1234567891011121314151617181920212223/** * * url 数据发送地址 * data 发送数据 * dataType 返回数据类型 * successfn 成功回调 * errorfn 失败回调 */jQuery.ajxPost = function(url,data,dataType,successfn,errorfn)&#123; $.ajax(&#123; type: &quot;post&quot;, url: url, data: data, dataType: dataType, contentType: &quot;application/json&quot;, success: function(d,txt) &#123; successfn(d,txt); &#125;, error: function(xhr,e) &#123; errorfn(xhr,e); &#125; &#125;);&#125;;","tags":[{"name":"jquery","slug":"jquery","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/jquery/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/ajax/"}]},{"title":"Jquery动态加载js文件","date":"2017-05-17T02:50:00.000Z","path":"2017/05/17/Jquery动态加载js文件/","text":"Jquery动态加载js文件方法 Jquery动态加载js文件的三种方法，一般在偏小项目中抽象出来的模块化开发中适用： 一、$.getScript() $.getScript() 是jquery封装的一个高级方法，和$.get()、$.post()类似，相当于如下ajax函数： 12345$.ajax(&#123; url: url, dataType: &#x27;script&#x27;, success: successFn&#125;); 用法： $.getScript(url, [callback]); 示例： 1234567if(item === &quot;js&quot;)&#123; $.getScript(&#x27;test.js&#x27;,function(data,textstatus)&#123; console.log(&quot;JS loading is OK!&quot;); &#125;);&#125;else&#123; console.log(&quot;JS loading is fail!&quot;);&#125; 二、利用script标签 直接上示例： 1234function importJS(path)&#123; var head = $(&#x27;head&#x27;); $(&quot;&lt;script&gt;&lt;/script&gt;&quot;).attr(&#123;src: file, type: &quot;text/javascript&quot;, id: &quot;loadjs&quot;&#125;).appendTo(head);&#125; 三、利用document.write() 貌似也是间接的利用script标签，个人还是比较喜欢第一种，直接上例子： 我们有第一个js文件test01.js 123function testOne()&#123; console.log(&quot;test01&quot;);&#125; 我们写第二个js文件test02.js 1234document.write(&quot;&lt;script src=&#x27;test01.js&#x27; type=&#x27;text/javascript&#x27;&gt;&lt;/script&gt;&quot;);function testTwo()&#123; console.log(&quot;test02&quot;);&#125; 我们只需要html页面中这样使用 12345&lt;script type=&quot;text/javascript&quot; src=&quot;test02.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; testOne(); testTwo();&lt;/script&gt; 对$.getScript()补充 因为$.getScript()是封装ajax的异步处理，所以对该函数的几个坑点做补充。 1. 错误处理： jquery 1.5开始，可以用.file()来处理错误： 12345$.getScript(&quot;test.js&quot;).done(function(data, textstatus)&#123; console.log(textstatus);&#125;;).fail(function(jqxhr, settings, exception)&#123; console.log(&quot;Data exception！&quot;);&#125;); 3. 缓存处理： 浏览器默认情况下会对请求频繁的文件进行缓存，但是$.getScript()函数在会在js文件的URL后面添加一个时间戳参数后缀，从而避免浏览器获取缓存的js文件。如果需要启用缓存，可以通过对全部ajax请求设置缓存默认置，也可以自己定义ajax方法。 123$.ajaxSetup(&#123; cache: true&#125;); 2. 文件函数变量调用： 123456$.getScript(&#x27;test.js&#x27;,function(data,textstatus)&#123; console.log(&quot;JS loading is OK!&quot;); testFn(); //成功调用&#125;);testFn(); //testFn is not defined! 因为$.getScript()是异步加载的，在你访问其中的某个变量或函数时，可能该js文件尚未完全加载完毕。建议你最好在success回调函数中处理，或者你能够确认此时该js文件已经加载完毕。","tags":[{"name":"jquery","slug":"jquery","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/jquery/"},{"name":"js","slug":"js","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/js/"}]},{"title":"sass进阶","date":"2017-05-11T11:50:00.000Z","path":"2017/05/11/sass进阶/","text":"sass指令 1. @if指令 Sass的@if指令和js的if条件语句差不多，可配合@else if 和 @else来使用，我们可以通过该指令来控制一个元素的显示隐藏。如下： 1234567891011121314151617//scss@mixin blockOrHidden($boolean:true) &#123; @if $boolean &#123; @debug &quot;$boolean is #&#123;$boolean&#125;&quot;; display: block; &#125; @else &#123; @debug &quot;$boolean is #&#123;$boolean&#125;&quot;; display: none; &#125;&#125;.block &#123; @include blockOrHidden;&#125;.hidden &#123; @include blockOrHidden&#125; *@degub 用于sass调试时，编译出错时即显示@debug设定的信息。 编译后的css 1234567.block &#123; display: block;&#125;.hidden &#123; display: none;&#125; 2. @for循环 sass的@for循环有两种用法： 12@for $i from &lt;start&gt; through &lt;end&gt;@for $i from &lt;start&gt; to &lt;end&gt; $i 为循环的变量，start 表示起始值，end 表示结束值，这两个的区别在于关键字 through 表示包括 end 这个数值，而 to 则不包括 end 这个值。如下： 123456//scss@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 20px * $i; &#125;&#125; 编译出来的css 123456789.item-1 &#123; width: 20px;&#125;.item-2 &#123; width: 40px;&#125;.item-3 &#123; width: 60px;&#125; 3. @while循环 123456789//scss$types: 4;$type-width: 20px;@while $type &gt; 0 &#123; .while-#&#123;$types&#125; &#123; width: $type-width + $types; &#125; $types: $type - 1;&#125; 编译出来的css 123456789101112.while-4 &#123; width: 24px;&#125;.while-3 &#123; width: 23px;&#125;.while-2 &#123; width: 22px;&#125;.while-1 &#123; width: 21px;&#125; 4. @each遍历 用法： @each $var in &lt;list&gt; ，list为一个值列表。 用例： 123456789101112//scss$list: adam john wynn mason kuroir;@mixin author-images &#123; @each $author in $list &#123; .photo-#&#123;$author&#125; &#123; background: url(&quot;/images/views/#&#123;$author&#125;.png&quot;) no-repeat; &#125; &#125;&#125;.author-bio &#123; @include author-images;&#125; 编译出来的css 123456789101112131415.author-bio .photo-adam &#123; background: url(&quot;/images/views/adam.png&quot;) no-repeat; &#125;.author-bio .photo-john &#123; background: url(&quot;/images/views/john.png&quot;) no-repeat; &#125;.author-bio .photo-wynn &#123; background: url(&quot;/images/views/wynn.png&quot;) no-repeat; &#125;.author-bio .photo-mason &#123; background: url(&quot;/images/views/mason.png&quot;) no-repeat; &#125;.author-bio .photo-kuroir &#123; background: url(&quot;/images/views/kuroir.png&quot;) no-repeat; &#125; sass函数 sass中的函数有字符串函数、数字函数、列表函数、颜色函数、Introspection函数、三元函数、Maps函数等 1. 字符串函数 unquote($string)：删除字符串中的引号； quote($string)：给字符串添加引号。 12345678910111213141516171819//SCSS.test1 &#123; content: unquote(&#x27;Hello Sass!&#x27;) ;&#125;.test2 &#123; content: unquote(&quot;&#x27;Hello Sass!&quot;);&#125;.test3 &#123; content: unquote(&quot;I&#x27;m Web Designer&quot;);&#125;.test4 &#123; content: unquote(&quot;&#x27;Hello Sass!&#x27;&quot;);&#125;.test5 &#123; content: unquote(&#x27;&quot;Hello Sass!&quot;&#x27;);&#125;.test6 &#123; content: unquote(Hello Sass);&#125; 编译后的 css 代码： 123456789101112131415161718//CSS.test1 &#123; content: Hello Sass!; &#125;.test2 &#123; content: &#x27;Hello Sass!; &#125;.test3 &#123; content: I&#x27;m Web Designer; &#125;.test4 &#123; content: &#x27;Hello Sass!&#x27;; &#125;.test5 &#123; content: &quot;Hello Sass!&quot;; &#125;.test6 &#123; content: Hello Sass; &#125; 从测试的效果中可以看出，unquote() 函数只能删除字符串最前和最后的引号（双引号或单引号），而无法删除字符串中间的引号。如果字符没有带引号，返回的将是字符串本身。 另外还有 To-upper-case() 函数将字符串小写字母转换成大写字母。To-lower-case() 函数与 To-upper-case() 刚好相反，将字符串转换成小写字母. 2. 数字函数 percentage($value)：将一个不带单位的数转换成百分比值； round($value)：将数值四舍五入，转换成一个最接近的整数； ceil($value)：将大于自己的小数转换成下一位整数； floor($value)：将一个数去除他的小数部分； abs($value)：返回一个数的绝对值； min($numbers…)：找出几个数值之间的最小值； max($numbers…)：找出几个数值之间的最大值； random()： 获取随机数 3. 列表函数 length($list)：返回一个列表的长度值； nth($list, $n)：返回一个列表中指定的某个标签值 join($list1, $list2,[$separator])：将两个列给连接在一起，变成一个列表； append($list1, $val, [$separator])：将某个值放在列表的最后； zip($lists…)：将几个列表结合成一个多维的列表； index($list, $value)：返回一个值在列表中的位置值。 4. Introspection函数 Introspection 函数包括了几个判断型函数： type-of($value)：返回一个值的类型 unit($number)：返回一个值的单位 unitless($number)：判断一个值是否带有单位 comparable($number-1, $number-2)：判断两个值是否可以做加、减和合并 5. Miscellaneous函数 在这里把 Miscellaneous 函数称为三元条件函数，主要因为他和JavaScript 中的三元判断非常的相似。他有两个值，当条件成立返回一种值，当条件不成立时返回另一种值： if($condition,$if-true,$if-false) 6. Map和Maps函数 Map类型： 123456$map:( key1: vaule1, key2: value2, key3: value3) 在sass中通常这样定义变量： 12$default-color: #fff !default;$primary-color: #22ae39 !default; 我们使用 map 可以更好的进行管理，便于值的增删： 1234$color: ( default: #fff, primary: #22ae39); 另外，Map也可以嵌套Map。 Maps函数： map-get($map,$key)：根据给定的 key 值，返回 map 中相关的值。 map-merge($map1,$map2)：将两个 map 合并成一个新的 map。 map-remove($map,$key)：从 map 中删除一个 key，返回一个新 map。 map-keys($map)：返回 map 中所有的 key。 map-values($map)：返回 map 中所有的 value。 map-has-key($map,$key)：根据给定的 key 值判断 map 是否有对应的 value 值，如果有返回 true，否则返回 false。 keywords($args)：返回一个函数的参数，这个参数可以动态的设置 key 和 value。 7. RGB()颜色函数 rgb($red,$green,$blue)：根据红、绿、蓝三个值创建一个颜色； rgba($red,$green,$blue,$alpha)：根据红、绿、蓝和透明度值创建一个颜色； red($color)：从一个颜色中获取其中红色值； green($color)：从一个颜色中获取其中绿色值； blue($color)：从一个颜色中获取其中蓝色值； mix($color-1,$color-2,[$weight])：把两种颜色混合在一起。 8. HSL函数 hsl($hue,$saturation,$lightness)：通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色； hsla($hue,$saturation,$lightness,$alpha)：通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色； hue($color)：从一个颜色中获取色相（hue）值； saturation($color)：从一个颜色中获取饱和度（saturation）值； lightness($color)：从一个颜色中获取亮度（lightness）值； adjust-hue($color,$degrees)：通过改变一个颜色的色相值，创建一个新的颜色； lighten($color,$amount)：通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色； darken($color,$amount)：通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色； saturate($color,$amount)：通过改变颜色的饱和度值，让颜色更饱和，从而创建一个新的颜色 desaturate($color,$amount)：通过改变颜色的饱和度值，让颜色更少的饱和，从而创建出一个新的颜色； grayscale($color)：将一个颜色变成灰色，相当于desaturate($color,100%); complement($color)：返回一个补充色，相当于adjust-hue($color,180deg); invert($color)：反回一个反相色，红、绿、蓝色值倒过来，而透明度不变。 9. Opacity函数 alpha($color) /opacity($color)：获取颜色透明度值； rgba($color, $alpha)：改变颜色的透明度值； opacify($color, $amount) / fade-in($color, $amount)：使颜色更不透明； transparentize($color, $amount) / fade-out($color, $amount)：使颜色更加透明。 12345 alpha(red)1&gt;&gt; alpha(rgba(red,.8))0.8 **sass初识请移步站内文章…如有不足之处，多多指教！","tags":[{"name":"css","slug":"css","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/sass/"}]},{"title":"初识sass基础","date":"2017-05-10T12:50:00.000Z","path":"2017/05/10/初识sass基础/","text":"初识sass 1. sass和scss SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点： 1.1. 文件扩展名不同,sass文件是以.sass结尾，scss文件是以.scss结尾; 1.2. 语法书写方式不同，Sass是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而SCSS的语法书写和我们的CSS语法书写方式非常类似。 2. sass安装和编译 2.1 安装 到ruby官网http://www.ruby-lang.org/en/downloads/下载并安装ruby. 查看ruby版本 → ruby -v 安装sass → gem install sass 查看sass版本 → sass -v 更新sass → gem update sass 卸载sass → gem uninstall sass 也可以下载文件到本地在命令行中安装记得勾选第二项和建议默认路径。 2.2. 编译 单文件编译： saas &lt;要编译的sass文件路径&gt;/style.scss:&lt;要输出的css文件路径&gt;/style.css 多文件编译： sass sass/:css将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。 自动监测： sass --watch&lt;要编译的sass文件路径&gt;/style.scss:&lt;要输出的css文件路径&gt;/style.css 3. 显示风格 sass的编译输出有四种显示风格： 3.1 嵌套输出方式nested sass --watch test.scss:test.css–style nested 3.2 展开输出方式expanded sass --watch test.scss:test.css–style expanded 3.3 紧凑输出方式compact sass --watch test.scss:test.css–style compact 3.4 压缩输出方式compressed sass --watch test.scss:test.css–style compressed sass基础 1. 变量 $color: red; 这里声明了一个变量并赋值 $color #CCC !default; 声明变量并设定默认值 sass也有局部变量和全局变量，在元素内部定义的变量为局部变量，外部为全局变量。 2. 样式嵌套 2.1 选择器嵌套 1234567&lt;header&gt; &lt;nav&gt; &lt;a href=&quot;&quot;&gt;Home&lt;/a&gt; &lt;a href=&quot;&quot;&gt;Products&lt;/a&gt; &lt;a href=&quot;&quot;&gt;About&lt;/a&gt; &lt;/nav&gt;&lt;/header&gt; 123456nav a&#123; color: red;&#125;header nav a&#123; color: green;&#125; 在sass中的实现方式 12345678nav&#123; a&#123; color: red; &#125; header &amp;&#123; color: green;&#125;&#125; &amp; 选择符置前表示该元素为嵌套元素的子级，置后表示该元素为嵌套元素的父级。 2.2 属性嵌套 1234.box &#123; border-top: 1px solid red; border-bottom: 1px solid green;&#125; sass实现 123456.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125; 2.3 伪类嵌套 1234567891011.box:after&#123; content:&quot; &quot;; display:block;&#125;.box&#123; &amp;:after&#123; content:&quot; &quot;; display: block; &#125;&#125; 3. 混合宏 1234567@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125;button &#123; @include border-radius;&#125; @mixin声明一个混合宏，上例中声明一个带参数$radius的混合宏，@include调用混合宏 4. 扩展继承 利用@extend可以实现样式的继承 我们有这样的sass代码 123456789101112131415.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125; 编译后的css样式 12345678910111213.btn, .btn-primary, .btn-second &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff;&#125;.btn-second &#123; background-clor: orange; color: #fff;&#125; 5. 占位符% 1234567891011121314151617//SCSS%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5; @extend %pt5;&#125;.block &#123; @extend %mt5;span &#123; @extend %pt5; &#125;&#125; 1234567//编译后CSS.btn, .block &#123; margin-top: 5px;&#125;.btn, .block span &#123; padding-top: 5px;&#125; 6. 插值# 123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125; 7. 数据类型 数字: 如，1、 2、 13、 10px； 字符串：有引号字符串或无引号字符串，如，“foo”、 ‘bar’、 baz； 颜色：如，blue、 #04a3f9、 rgba(255,0,0,0.5)； 布尔型：如，true、 false； 空值：如，null； 值列表：用空格或者逗号分开，如，1.5em 1em 0 2em 、Helvetica,Arial, sans-serif。 8. sass运算 加法：width: 20px + 8px; 减法：width: 20px - 8px; 乘法：width: 20px * 2; 除法：$width: 960px; .col &#123;width: $width / 10;&#125; 变量运算：width:$col-width + $col-gap; 数字多级运算：width: ((220px + 720px) - 11 * 20 ) / 12 ; 颜色运算：color: #010203 + #040506; 字符运算：$content: &quot;Hello&quot; + &quot;&quot; + &quot;Sass!&quot;; **sass进阶请移步站内文章…如有不足之处，多多指教！","tags":[{"name":"css","slug":"css","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/sass/"}]},{"title":"jquery动态添加table中的行和列","date":"2017-04-30T03:00:13.000Z","path":"2017/04/30/jquery动态添加table中的行和列/","text":"最近再做一个table的功能比较复杂，网上搜搜关于table列的添加也不是很多，这里写下关于jquery动态添加行列的情况，先分析下思路： 首先是table行添加，只需要在table后面追加tr、td即可，涉及到顺序插入需要获取编号列，对其排序，获取到当前添加的编号索引，在找到相应的tr在其后面插入即可，这也是我为什么这里用到bootstrap模态框的原因；列添加只需要在每行tr的里面追加th或者td即可。当然涉及到table的删除、选择、编辑、排序将在后面的一篇文章里完善，敬请期待！ 1、HTML布局、相关文件引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;body&gt; &lt;div class=&quot;table-box&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;th&gt;星期四&lt;/th&gt; &lt;th&gt;星期五&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=&quot;table_body&quot;&gt; &lt;tr&gt; &lt;td&gt;9&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;表一&lt;/td&gt; &lt;td&gt;表一&lt;/td&gt; &lt;td&gt;生表一&lt;/td&gt; &lt;td&gt;人生表&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;表一&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;单元表&lt;/td&gt; &lt;td&gt;单元表表&lt;/td&gt; &lt;td&gt;单元表&lt;/td&gt; &lt;td&gt;单元表&lt;/td&gt; &lt;td&gt;单元表&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;19&lt;/td&gt; &lt;td&gt;人生表一&lt;/td&gt; &lt;td&gt;生表一&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;表一&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!--button--&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;addrowbtn&quot; data-toggle=&quot;modal&quot; data-target=&quot;#rowModal&quot;&gt;添加行&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;addcolbtn&quot; data-toggle=&quot;modal&quot; data-target=&quot;#colModal&quot;&gt;添加列&lt;/button&gt; &lt;/div&gt; &lt;!--addRow模态框--&gt; &lt;div class=&quot;modal fade&quot; id=&quot;rowModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;exampleModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;exampleModalLabel&quot;&gt;添加新行&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-time&quot; class=&quot;control-label&quot;&gt;填写行编号:&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;recipient-time&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;message-text&quot; class=&quot;control-label&quot;&gt;描述（可选）:&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;message-text&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-dismiss=&quot;modal&quot; id=&quot;confirmrow&quot;&gt;确认&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--addCol模态框--&gt; &lt;div class=&quot;modal fade&quot; id=&quot;colModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;exampleModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;exampleModalLabel&quot;&gt;添加新列&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-date&quot; class=&quot;control-label&quot;&gt;填写列头信息:&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;recipient-date&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;message-text&quot; class=&quot;control-label&quot;&gt;描述（可选）:&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;message-text&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-dismiss=&quot;modal&quot; id=&quot;confirmcol&quot;&gt;确认&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 需要引入的文件 12345&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.1.min.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.table.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.js&quot; &gt;&lt;/script&gt; 2、在script标签写入javascript 首先获取table的行列数，便于后面使用。代码写在$(fuction()&#123;&#125;)里,这里说明一下，添加行，添加列，获取table行列数是通过jquery扩展的形式放在jquery.table.js里面。 12345var $table, rowcol, row_num, col_num, allcols;$table = $(&quot;.table&quot;);rowcol = $table.getrowcol(); //$表格行列row_num = rowcol.rows;col_num = rowcol.cols; 模态框确定按钮触发添加行和列函数： 123456789101112$(&quot;#confirmrow&quot;).on(&quot;click&quot;,function()&#123; var trlength = $(&quot;.table tr:first&quot;).find(&quot;th&quot;).length; var newtime = $(&quot;#recipient-time&quot;).val(); allcols = getCols(&quot;.table&quot;,0); allcols.shift(); //除第一项的所有编号列 $(&quot;.table&quot;).addrow($table,allcols,trlength,newtime); //$添加行&#125;); $(&quot;#confirmcol&quot;).on(&quot;click&quot;,function()&#123; //$添加列 var newdate = $(&quot;#recipient-date&quot;).val(); $(&quot;.table&quot;).addcol($table,row_num,newdate);&#125;); 为了顺序插入我们需要创建一个获取列的函数： 123456789101112function getCols(selector,curCol)&#123; var allcol = [], selector = selector || &quot;&quot;, curIndex = curIndex || &quot;&quot;; $(selector + &quot; tr&quot;).each(function(index)&#123; var e_row = $(this).children().eq(curIndex); allcol.push(e_row); &#125;); allcol = allcol.length &gt; 0 ? allcol : &quot;&quot;; //全列数组 return allcol; &#125; 3、获取table行列数、添加行、添加列在jquery中的扩展 在jquery.table.js中写入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950(function ($) &#123; $.fn.extend(&#123; getrowcol: function()&#123; //获取table 行列数 var obj; this.each(function()&#123; var row_num = $(this).find(&quot;tr&quot;).length; //行 var col_num = $(this).find(&quot;td&quot;).length / (row_num - 1); //列 obj = &#123;rows: row_num, cols: col_num&#125;; &#125;); return obj; &#125;, addrow: function(table,arrcols,trlen,time)&#123; //传 表格selector、编号列、tr长度、新增编号 参数 用于顺序插入 return this.each(function()&#123; var arr = []; $(arrcols).each(function()&#123; arr.push($(this).text()); &#125;); arr.push(time); arr.sort(function(x,y)&#123; x = parseInt(x); y = parseInt(y); if(x&lt;y)&#123; return -1; &#125; if(x&gt;y)&#123; return 1; &#125; return 0; &#125;); var index = arr.indexOf(time); var _html; for(var i = 1;i &lt; trlen; i++)&#123; //tr的长度就是需要td的个数 _html += &quot;&lt;td&gt;&lt;/td&gt;&quot;; &#125; table.find(&quot;tr&quot;).eq(index).after(&quot;&lt;tr&gt;&lt;td&gt;&quot;+time+&quot;&lt;/td&gt;&quot;+_html+&quot;&lt;/tr&gt;&quot;); &#125;); &#125;, addcol: function(table,rownum,newdate)&#123; //传参数： 表格selector、新列 return this.each(function()&#123; $(&quot;tr:first&quot;,this).append(&quot;&lt;th&gt;&quot;+newdate+&quot;&lt;/th&gt;&quot;); $(&quot;tr:gt(0)&quot;,this).each(function()&#123; $(this).append(&quot;&lt;td&gt;&lt;/td&gt;&quot;); &#125;); &#125;); &#125; &#125;); &#125;)(jQuery); 查看演示 **更多table强大功能敬请待续…如有不足之处，多多指教！","tags":[{"name":"jquery","slug":"jquery","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/jquery/"},{"name":"table","slug":"table","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/table/"}]},{"title":"js中this的指向","date":"2017-04-29T13:40:13.000Z","path":"2017/04/29/js中this的指向/","text":"总结下关于常见的this指向的问题。首先，this对象只会是在一个函数中才需要确定，如果在全局作用域下，this永远指向global对象，在浏览器环境下是window对象，在javascript中，函数调用一般有这四种情况： 1、Function Invocation Pattern 函数调用模式，即直接调用定义的函数，如fn()，是函数最直接的使用方式，在这里fn是作为单独的变量出现，而非属性。在这种模式下，fn函数中的this永远指向全局对象，也就是global或者window。 2、Method Invocation Pattern 方法调用模式，此时函数做为一个对象的属性出现，如fn.handle()，主要的特征就是有“.”或者“[]”符号，在这种模式下，handle函数中的this永远指向的是“.”或者“[]”符号前的对象，在上面小例也就是fn。 3、Constructor Pattern 构造模式，在构造函数实例化的时候出现，如new Fn()，其中的new关键字很明显，在种模式下Fn函数内部的this永远指向new Fn()返回的对象，即Fn的实例。 4、Apply Pattern 适应模式，这种模式下，可以使用js提供的call()和apply()方法来改变this的指向，如fn.call(Object)和fn.call(Object)，在这种模式下，fn函数内部的this指向call和apply函数的第一个参数，但是在Object为null或者undefined时，this指向变为global。 ES6中箭头函数的this 在ES6中的箭头函数，(x, y) =&gt; x * x + y * y，省略了function、&#123;&#125;和return语句，有种匿名函数的感觉，箭头函数内部的this词法作用域，有上下文决定。所谓词法作用域，简单的理解就是函数定义的时候this的作用域就已经固定了，是什么就是什么，不会随着运行调用的改变而改变，也就是有些地方所说的静态作用域，不多说来个小例子： 以前javascript对this的绑定： 1234567891011var obj = &#123; name: &quot;nn&quot;, fun: function()&#123; var m = this.name; //obj.fun() 指向obj var say = function()&#123; return this.name; &#125;; return say(); //直接调用指向全局 &#125;&#125;;console.log(obj.fun()); // undefined 箭头函数固定了this指向： 123456789var obj2 = &#123; num: 3, total: function()&#123; var m = this.num; var count = ()=&gt; this.num; //词法作用域 指向外层域obj2 return count(); //直接调用此时已不管用 &#125;&#125;;console.log(obj2.total()); //3 看到这里是不是感觉有点懵逼，其实我也一样懵逼，所以下面再贴一段代码，让我们来加深下对词法作用域和箭头函数固定this作用域的理解： 1234567891011121314var obj3 = &#123; a: 2333, b: &#123; m: 3444, n: function()&#123; var w = this.a; var x = this.m; var y = ()=&gt;this.m; //词法作用域 指向外层域b 3444 var z = ()=&gt;this.a; //词法作用域 指向外层域b undefined return [y(),z()]; &#125; &#125;&#125;;console.log(obj3.b.n()); 其实就是在obj3对象里面又嵌套一个对象，层层嵌套，那啥（想到了那啥烧饼广告0.0），这样更加清晰的理解什么是词法作用域，什么是指向外层域。好了，鄙人才疏学浅，如有不足之处，还望不吝赐教。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"},{"name":"this","slug":"this","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/this/"}]},{"title":"frameset内嵌框架间相互操作","date":"2017-04-22T14:16:13.000Z","path":"2017/04/22/frameset内嵌框架间相互操作/","text":"说说现在的状态，在一首轻快地旋律《Trip》中码一码这篇笔记。一直想把前一个工作项目的笔记整理整理，无奈懒癌已犯（摊双手）。下面记录一下在frameset框架布局中关于内嵌框架间相互操作（js操作）的问题，大概归纳了这几类：基本、在主框架页操作其他内嵌框架、在本框架页操作、在兄弟框架同级框架下操作同级框架、在内嵌框架页操作主框架。 基本： name属性，规定了框架的名字，在后面js操作定位框架很重要；target属性，元素通过这个属性可以规定内容在那个框架中显示。 在主框架页操作其他内嵌框架： 直接用window.frames[&quot;name&quot;].document.... 在本框架页操作: 直接js 在兄弟框架同级框架下操作同级框架: 先回到父级再操作window.parent.frames[&quot;name&quot;].document..... 、在内嵌框架页操作主框架: 直接回到父级的文档window.parent.document.getElement......","tags":[{"name":"frameset","slug":"frameset","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/frameset/"}]},{"title":"frameset对媒体查询的影响","date":"2017-04-20T13:40:58.000Z","path":"2017/04/20/frameset对媒体查询的影响/","text":"今天在做电控系统web布局的时候踩了一坑，虽说frameset已经很少人用，但是我们不可否认frameset曾经的辉煌时刻，现在依然有好多的后台系统布局有它的身影，包括接下来我的那个项目也是一样的，随指一码，不喜勿喷！下面就进入填坑之旅吧！ 首页整个页面采用frameset框架式上左右结构布局，下图所示的就是页面中的某个iframe页面，当我拖动浏览器窗口宽度大小在1440px左右时布局发生错乱，那就针对屏幕文档显示宽度大小在1440px左右做媒体查询设置吧，于是默默地把查询条件设置为max-width:1440px，可事实不并不如人所料，在没有到1440px（目测差异一大截）的地方就做了样式变更，这也是frameset布局对媒体查询的影响，其实媒体查询精度并没有改变，只是媒体查询的对象不同的影响。 媒体查询的定义 这里只说说两种我们常见的也是用得最多的定义，像一些不常用的比如：彩色原件数、屏幕宽高比等请自行搜索。 一：使用@media查询，你可以针对不同的媒体类型定义不同的样式。指的是不同的媒介（平板、阅读器、打印机等）。 二：使用@media查询，你可以根据输出设备中的页面可见区域高度的不同来设置不同的样式，特别是如果你需要设置设计响应式的页面，@media是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。由此可见，这类功能的基准对象是需要调整样式的文档在屏幕设备（浏览器）中的显示宽高度。 html代码 123456789101112131415&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2 class=&quot;user_tit&quot;&gt;日程管理&lt;/h2&gt; &lt;hr /&gt; &lt;div class=&quot;iframe_box&quot;&gt; &lt;frameset&gt; &lt;iframe src=&quot;frame_top.html&quot; width=&quot;90%&quot; height=&quot;185&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;frame_left.html&quot; width=&quot;75%&quot; height=&quot;530&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;frame_right.html&quot; width=&quot;75%&quot; height=&quot;530&quot;&gt;&lt;/iframe&gt; &lt;/frameset&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; css代码 123456789@media screen and (max-width:1440px)&#123; .timer&#123; margin-left: 3%; &#125; .status,.special,.modify&#123; margin-left: 40px; &#125;&#125; 其实也没有啥，就是改变三个div的左右间距。 当然，上面的代码还没到1440就起作用了，有图有真相。 **分析原因：其实上面说的差不多了，当我们需要改变这个框架里面某个独立文档的样式时，我们的查询基准是该文档在输出设备屏幕上的显示宽度高度，下面的js可以实时打印窗口改变的大小，而此时我们所查询的基准是整个输出屏幕文档显示的大小，当然这个准确度就不是差之毫厘了，此时我们可以用尺子量一量我们需要改变样式的文档在整个框架布局中显示的大小，以此为基准就正常的媒体查询自适应了。 js获取文档宽高 12345window.onresize = function()&#123; var w = document.body.clientWidth; var h = document.body.clientHeight; console.log(w+&quot;|&quot;+h);&#125; **总结几种媒体查询失效的原因：① 视口viewport没有声明； ②代码（and后的空格）查询条件的混淆具体数值别的单位； ③上面填坑。","tags":[{"name":"frameset","slug":"frameset","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/frameset/"},{"name":"media","slug":"media","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/media/"}]},{"title":"Js表单操作之formData","date":"2017-04-16T13:12:58.000Z","path":"2017/04/16/Js表单操作之formData/","text":"好久没有更新自己的博客了，回过头来已经‘人间四月天’。健哥说过：先定一个小目标。对，就先定个小目标，每周至少两篇以上的博客，才对的起这人间四月天。 表单操作是最常见的js数据操作了，尤其HTML5的很多属性使得表单操作更加灵活，FormData类型其实是在XMLHttpRequest2级定义的，它是为序列化表以及创建与表单格式相同的数据（当然是用于XHR传输）提供便利。 实例化formdata对象 创建一个空对象实例 var formData = new FormData(); 已有表单数据初始化实例 已有html表单： 12345&lt;form id=&quot;myForm&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;用户名 &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;密码 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; onclick=&quot;refre()&quot;&gt;&lt;/form&gt; js操作读取 12345678function refre()&#123; var eform = document.getElementById(&quot;myForm&quot;); var myform = new FormData(eform); var username = myform.get(&quot;username&quot;); var pwd = myform.get(&quot;pwd&quot;); console.log(username+&quot;|&quot;+pwd);&#125; 操作方法 获取数据（myform为实例化的formData） myform.get(&quot;key&quot;); myform.getAll(&quot;key&quot;); //获取某个键的所有值 必须带参数否则报错 添加数据 myform.append(&quot;key&quot;,&quot;value&quot;); 修改数据（通过set设置数据，如果存在则修改，不存在则新增该条数据） myform.set(&quot;key&quot;,&quot;value&quot;); 删除数据 myform.delete(&quot;key&quot;); 查询数据（判断是否有） myform.has(&quot;key&quot;); // 返回布尔值 遍历数据 我们可以通过entries()来获取一个迭代器，然后遍历所有的数据， 12345678910formData.append(&quot;k1&quot;, &quot;v1&quot;);formData.append(&quot;k1&quot;, &quot;v2&quot;);formData.append(&quot;k2&quot;, &quot;v1&quot;);var i = formData.entries();i.next(); // &#123;done:false, value:[&quot;k1&quot;, &quot;v1&quot;]&#125;i.next(); // &#123;done:fase, value:[&quot;k1&quot;, &quot;v2&quot;]&#125;i.next(); // &#123;done:fase, value:[&quot;k2&quot;, &quot;v1&quot;]&#125;i.next(); // &#123;done:true, value:undefined&#125; 可以看到返回迭代器的规则 每调用一次next()返回一条数据，数据的顺序由添加的顺序决定。 返回的是一个对象，当其done属性为true时，说明已经遍历完所有的数据，这个也可以作为判断的依据。 返回的对象的value属性以数组形式存储了一对keyvalue，数组下标0为key，下标1为value，如果一个key值对应多个value，会变成多对key/value返回。 发送数据 我们可以通过xhr来发送数据 1234var xhr = new XMLHttpRequest();xhr.open(&quot;post&quot;,&quot;login&quot;);xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);xhr.send(formData); 这种方式可以来实现文件的异步上传。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"},{"name":"formData","slug":"formData","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/formData/"}]},{"title":"顽固的element.style","date":"2017-03-20T02:49:23.000Z","path":"2017/03/20/顽固的elementstyle/","text":"有时候在我们编辑页面修改页面的css时，发现怎么添加css样式都不起效果，当我们在浏览器里面审查元素的时候回发现，不知不觉就有一个叫element.style的东西无形中添加了一些我们不需要的样式，这个不是问题，但是它影响我们页面的美观，并且怎么给元素添加样式都不能覆盖它这就是大问题了。 首先我们想到的必然的是不是在什么地方给它加了什么样式破坏了，但是我们找啊找发现没有，有时候我们可以用js来修改样式，但是发现这样也无济于事，这个时候我们就应该想到，既然是css样式，影响它的要么是源代码，要么就是css优先级比较高，所以我们解决的办法就是提升样式的优先级，!important可以使样式优先级最高,此时样式就可以覆盖了。 1234567891011121314151617&lt;style&gt; body&#123; margin: 0 !important; padding: 0 !important; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;overflow:hidde; height: 100%; border: none; margin: 10px; padding: 10px;&quot; &gt; &lt;div class=&quot;wrap&quot; style=&quot;background-color: gray;width: 300px;&quot;&gt; &lt;ol&gt; &lt;li&gt;有序列表1&lt;/li&gt; &lt;li&gt;有序列表2&lt;/li&gt; &lt;li&gt;有序列表3&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;","tags":[{"name":"css","slug":"css","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/css/"},{"name":"笔记","slug":"笔记","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaScript中的短路运算符","date":"2017-03-19T13:12:58.000Z","path":"2017/03/19/JavaScript中的短路运算符/","text":"javascript中的逻辑运算符有&amp;&amp;与运算、||或运算、!非运算，与和或运算可以实现短路运算，使代码更加精简可读，逻辑运算的运算机制是对布尔值进行比较，由于js是弱类型的语言，所有不满足运算符运算对象数据类型的项都会自动转换，在逻辑运算中，转换为boolean类型的值后为false的情况：0、&quot;&quot;、null、false、undefined、NaN，其他都为true。 求真 模式var a = b || c，其运算逻辑为：首先看b，如果b为true的话，a就等于b；如果b不为true，则a的值等于c，不管c是否为true（b、c的类型不是boolean类型会进行自动类型转换）。下面来看个小案例： 1234var a ,b = 0,c = null;console.log(a = b || c); // a = null; 求假 模式var x = y &amp;&amp; z，其运算逻辑为：首先看y，如果y为false的话，x就等于y；如果y不为false，则x的值等于z，不管z是否为false（y、z的类型不是boolean类型会进行自动类型转换）。也来看个小案例： 1234var x,y = null,z = 2333;console.log(x = y &amp;&amp; z); //null **总结：看运算符，是运算true还是false；首先满足条件首先赋值，不管嵌套多少层，短路运算符有利于精简代码，增强代码可读性，在优雅降级方面有很好的作用。 多层嵌套：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"}]},{"title":"css垂直居中的方法极其细节","date":"2017-03-01T14:26:40.000Z","path":"2017/03/01/css垂直居中/","text":"不管是面试还是工作中，垂直居中都是一个经典的不能再经典的问题了，以前我们看的最多的就是盒子固定宽高，只需要设置个定位或者边距就行了，但是，在不知道宽高或者说不考虑宽高的情况下又是怎么样，下面来一一揭晓。 1、表格布局dispaly:table-cell 表格布局前提，是有固定的宽高 html代码： 12345&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;内容区块&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; css代码： 123456789101112131415.container&#123; width: 600px; height: 600px; background-color: bisque; display: table-cell; vertical-align: middle; text-align: center;&#125;.content&#123; display: inline-block; width: 80px; height: 80px; color: red; background-color: aquamarine;&#125; 2、利用绝对定位，外边距的负50% 前提也是有固定的宽高 html代码： 1234567&lt;body&gt; &lt;header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;内容区块&lt;/div&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; css代码： 1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.container&#123; width: 300px; height: 300px; border: 1px solid red; position: relative;&#125;.content&#123; position: absolute; left: 50%; top: 50%; width: 60px; height: 60px; margin-left: -30px; margin-top: -30px; border: 1px solid blue;&#125; 3、利用绝对定位，知道宽高，但不用考虑宽高 前提也是有固定的宽高，但不用去考虑宽高如何处理 html代码： 1234567&lt;body&gt; &lt;header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;内容区块&lt;/div&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; css代码： 123456789101112131415161718.container&#123; width: 600px; height: 600px; background-color: bisque; position: relative;&#125;.content&#123; width: 80px; height: 80px; color: red; background-color: aquamarine; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; 4、利用绝对定位，transform属性 适合未知宽高的情况，但有一定的虑兼容性问题 html代码： 1234567&lt;body&gt; &lt;header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;内容区块&lt;/div&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; css代码： 123456789101112131415.container&#123; width: 600px; height: 600px; background-color: bisque; position: relative;&#125;.content&#123; color: red; border: 1px solid #333; background-color: aquamarine; position: absolute; top:50%; left:50%; transform: translate(-50%, -50%);&#125; 4、利用flex，弹性盒子布局 适合未知宽高的情况，但有一定的虑兼容性问题 html代码： 1234567&lt;body&gt; &lt;header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;内容区块&lt;/div&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; css代码： 12345678910111213.container&#123; width: 600px; height: 600px; background-color: bisque; display: flex; justify-content: center; align-items: center;&#125;.content&#123; color: red; border: 1px solid #333; background-color: aquamarine;&#125; 5、利用js，强行操作 html代码： 1234567&lt;body&gt; &lt;header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;内容区块&lt;/div&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; 123456789let container = document.getElementById(&quot;container&quot;);let content = document.getElementById(&quot;content&quot;);content.style.position = &quot;absolute&quot;;containerW = container.offsetWidth;containerH = container.offsetHeight;contentW = content.offsetWidth;contentH = content.offsetHeight;content.style.left = (containerW - contentW) / 2 + &#x27;px&#x27;;content.style.top = (containerH - contentH) / 2 + &#x27;px&#x27;; 6、其余的一些简单的居中操作 利用背景图片居中 html代码： 1234567&lt;body&gt; &lt;header&gt; &lt;div class=&quot;head-logo&quot;&gt; &lt;!--&lt;img src=&quot;QQ.png&quot;/&gt;--&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; css代码： 123456789*&#123; padding: 0; margin: 0;&#125;.head-logo&#123; height: 100px; border: 1px solid red; background: url(&quot;QQ.png&quot;) no-repeat center center;&#125; 利用p段落的line-height html代码： 123456789&lt;body&gt; &lt;header&gt; &lt;div class=&quot;head-logo&quot;&gt; &lt;p class=&quot;p-img&quot;&gt; &lt;img src=&quot;img/logo.png&quot;/&gt; &lt;/p&gt; &lt;/div&gt; &lt;/header&gt;&lt;/body&gt; css代码： 1234567891011121314151617*&#123; padding: 0; margin: 0;&#125;.head-logo&#123; width: 200px; height: 200px; border: 1px solid red;&#125;.p-img&#123; width: 200px; height: 200px; line-height: 200px;&#125;.p-img img&#123; vertical-align: middle;&#125; 预览效果：","tags":[{"name":"居中","slug":"居中","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%B1%85%E4%B8%AD/"}]},{"title":"你不知道的addLoadEvent和inserAfter","date":"2017-02-21T13:12:58.000Z","path":"2017/02/21/你不知道的addLoadEvent和inserAfter/","text":"你不知道的addLoadEvent()和inserAfter()函数，因为这两个函数js并没有内置，但是在我们编写页面的时候复用度还是挺高的。因此，我在这里继续理理思路，敲一遍。 首先addLoadEvent()，顾名思义，页面加载的事件监听函数，有个想象的addEventLstener()，是DOM事件监听函数，因为不标准，所以对应的在IE中就有attactEvent()了，addLoadEvent()的复用可以解决window.onload每次只能绑定一个函数的弊端了，当然，你也可以给window.onload的匿名函数里面调用多个函数，如： 12345window.onload = function()&#123; fn1(); fn2() fn... &#125; 但是这样的代码可读性变差了，而且不利于样式与表现的分离，我们可以封装一个函数，基本思路是这样的：首先获取window.onload对象，判断其类型是否是function类型，如果是则说明已经绑定了函数，直接在后面追加函数调用，否则直接调用函数。 1234567891011function addLoadEvent(fn)&#123; var par = window.onload; if(typeof window.onload != &quot;function&quot;)&#123; window.onload = fn; &#125;else&#123; window.onload = function()&#123; par(); fn(); &#125; &#125;&#125; 注意的是，当函数赋给window.onload时不需要()，因为这是调用函数，我们需要的是吧函数整体赋给它。 接下来学习insertAfter(),其实并没有这个函数，因为有一个我们熟悉的insertBefore()，然而我们完全可以利用js给我们提供的DOM操作的方法来手写一个insertAfter()，基本思路是这样的：首先获取父级节点，判断父级节点的最后一个节点是否为目标节点，如果是直接在父级节点里面追加新的节点，恰好在最后面，否则在目标节点的下一个节点前面插入节点。 12345678function insertAfter(newNode,targetNode)&#123; var parNode = targetNode.parentNode; if(parNode.lastChild == targetNode)&#123; parNode.appendChild(newNode); &#125;else&#123; parNode.insertBefore(newNode,targetNode.nextSibling); &#125;&#125; 此函数涉及DOM节点操作.parentNode父级节点、.lastChild最后一个子节点、.nextSibling下一个兄弟节点、.appendChild()追加子节点、.insertBefore()节点前插入节点 多层嵌套：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"}]},{"title":"表单操作——两种表单的提交方式","date":"2017-02-20T14:49:23.000Z","path":"2017/02/20/表单操作——两种表单的提交方式/","text":"用javascript操作表单和操作DOM一样，在html中提供了以下几种表单输入控件： 文本框&lt;input type=&quot;text&quot;&gt;用于文本输入； 密码框&lt;input type=&quot;password&quot;&gt;用于密码输入； 单选框&lt;input type=&quot;radio&quot;&gt;用于单选一项； 复选框&lt;select&gt;用于多项选择； Html5中也给我们提供了许多方便的新控件:color date email range url等。 下面是js中最基本的两种表单提交操作： 12345678910111213141516171819202122232425262728293031323334方式一html:&lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;pasd&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;btn&quot; id=&quot;btn&quot; value=&quot;提交&quot; onclick=&quot;sbmit()&quot; /&gt;&lt;/form&gt;javascript:&lt;script&gt;var form1 = document.getElementById(form1);//TODO...form1.submit();//总结：利用按钮点击调用函数进行提交 在函数中获取表单对象 调用表单的submit()进行提交&lt;/script&gt;方式二html:&lt;form id=&quot;form2&quot; method=&quot;post&quot; onsubmit=&quot;return onsbmit&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;pasd&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; /&gt;&lt;/form&gt;javascript:&lt;script&gt; function onsbmit()&#123; var form2 = document.getElementById(&quot;form2&quot;); var psd = document.getElementById(&quot;pasd&quot;); psd_val = toMD5(psd.value);//MD5加密 return true; &#125; //总结：利用submit类型的按钮进行提交 利用form的onsubmit属性return函数 如果函数返回true则提交 返回false则不提交&lt;/script&gt; 注意：当一个表单包含&lt;input type=&quot;file&quot;&gt;的时候，表单的enctype属性必须为multipart/form-data，method必须为post，浏览器才能以multipart/form-data的形式提交数据，同时里面的input必须指定name属性，不然的话该项数据不提交。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"},{"name":"表单","slug":"表单","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E8%A1%A8%E5%8D%95/"},{"name":"笔记","slug":"笔记","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"欢迎来到我的hexo博客，这是我的第一篇测试文章","date":"2017-02-13T13:26:20.000Z","path":"2017/02/13/2017-2-13欢迎来到/","text":"hexo博客，第一篇测试文章 个人博客也是我们生活方式的一种，可以记录我们生活的点滴，每天的所见所闻，每天的所学总结，每天的心得分享，相当于在线的notebook，记录可你每天的足记，当你回过头来翻看自己的文章时，原来指尖的力量已经形成了一部内容深厚的电影————当然，这是以文字图片形式的，在你阅读的同时脑海里也就浮现出当时吸收这些知识的艰难岁月，艰辛的日子，我们勤于记录，乐于分享，业精于勤荒于嬉，就是这样的方式。 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 作者 [@ghosert][3] 2016 年 07月 07日 [3]: http://weibo.com/","tags":[]},{"title":"正则表达式——传统的字符串操作","date":"2016-11-24T02:49:23.000Z","path":"2016/11/24/正则字符串操作/","text":"在没有学正则表达式之前，我们都是用js提供的方法进行匹配指定字符串，往往需要些一大串代码！ 首先来复习下js为我们提供的一些字符串操作方法： str.indexOf(&quot;s&quot;);返回指定字符串首次出现的位置。 str.search(&quot;s&quot;);搜索指定字符串，并返回首次出现的位置，如果没有则返回-1。 str.substring(n,m);返回索引是n和m-1之间的字符串，截取子串。 str.slice(n,m);和substring方法一样。 str.charAt(n);返回指定位置n的字符。 str.split('s');按照指定字符分割字符串，返回一个数组。 str.replace(“s”,“S”);`替代字符，将大S代替小s。 str.match(&quot;ss&quot;);匹配并以数组的形式返回一个指定字符串，该数组有三项，[0]是指定字符串，[1]是指定字符出现的位置，[2]是原字符串。 一般常用的字符串操作方法就是以上7种，以下是小案例分析。 123456789101112131415161718192021222324252627var str = &#x27;acbdfghjfg&#x27;;console.log(str.indexOf(&#x27;f&#x27;)); //返回指定字符串第一次出现的位置 结果（4）console.log(str.search(&#x27;bd&#x27;)); //查找字符串第一次出现的位置，没有返回-1 结果（2）console.log(str.substring(1,4)); //包前不包后 结果（cbd）console.log(str.charAt(5)); //获取指定位置的字符 结果（g）console.log(str.split(&#x27;f&#x27;)); //利用指定字符分割字符串 结果（[ acbd , ghj , g ]）console.log(str.slice(1,4)); //和上面一样 结果（cbd）console.log(str.replace(&#x27;f&#x27;,&#x27;Q&#x27;)); //替换第一次出现的字符 结果（acbdQghjfg）console.log(str.match(&quot;fg&quot;)); //返回指定的字符串（数组形式）,该数组有三项：1.指定字符串2.指定字符串首次出现的位置index.原字符串input结果（[ &quot;fg&quot;,index : 4 , input : acbdfghjfg ]） 下面分析一个完整案例，从某字符串中提取数字。 1234567891011121314151617var str = “di h84 nd9 fpd o3-609 hd0”;var tmp = ‘ ‘; //临时存储数字var arr = [ ] ; //所有数字for( var i = 0; i if( str.charAt( i )&gt;=’0’&amp;&amp;str.charAt( i )&lt;=’9′ )&#123; //匹配大小 tmp += str.charAt( i ); //符合要求存入临时变量 &#125;else&#123; //如果不符合但是临时变量里有值，放入数组，并清空临时变量 if(tmp)&#123; arr.push( tmp ); tmp = ‘ ‘; &#125; &#125;&#125;if( tmp )&#123; //如果最后一位是数字 arr.push( tmp ); tmp = ‘ ‘;&#125; 传统的字符串操作也可以筛选数字、英文、中文，数字的范围是0–9，英文范围是a–z | A-Z ，中文范围\\u4e00–\\u9fa5。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/javascript/"},{"name":"正则","slug":"正则","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"就开始吧","date":"2016-11-24T02:27:16.000Z","path":"2016/11/24/就开始吧/","text":"纷歧样的人纷歧样的品味会对同一幅景象发生纷歧样的感触，晶莹的雪山有着不染纤尘的美，潺潺的小溪有着清秀天然的美，波澜壮阔的大海有着广大豪宕的美，每一种美都给人纷歧样的震撼，都是心旷神怡的。 优秀的人身上会发散着诱人的荣耀，他不只招引你，一同也招引着和你相同有着鉴赏能力的人。就像美丽的风光，它的存在不是为了一座山，一片郊野，而是为了全部天然，是为了点缀这美丽的国际，是为了让更多的人去赏识、去品味、去陶醉其间。 当你爱上一个人的时分，便想完完整整的具有他，包括他的思维，他的情感，以及他全部人，但每一次的感动往后，你又能耐久的具有吗？没有耐久不变的思维，也没有耐久仅有的情感，所以首要的不是爱，而是赏识。 有人说，男人和女人最首要的是相知相爱，正本，在你的一生中真实能感动你的人远远不止一个，都去相爱吗？很不现实，爱是一种用心投入的狭窄的情感，它夸姣但独立而排他。 咱们日子在一个五彩斑斓的国际，在这个国际里不但有着美丽的风光，相同也有着纷歧样特性、纷歧样气质、纷歧样人格魅力的人。在漫漫的人生旅途中，你会相遇相识许多的人，纷歧样的人身上有着纷歧样的质量及魅力，赏识、喜爱和爱，便成了咱们最难把握的标准。----而咱们自个应当学会做日子的智者。","tags":[{"name":"生活","slug":"生活","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"你身边这样的人吗","date":"2016-11-24T02:24:45.000Z","path":"2016/11/24/你身边有这样的人吗/","text":"你身边这样的人吗 01 你身边有没有这样的一个人？ 不论什么时候，只要你需要，他就在。 不论什么时候，只要你需要，你确信他就在。 我有。在我记忆中，他就是那个只要我需要他就在的人。不论什么时候，只要我需要，他就会在！ 怎样说呢？很安心。很贴心。很暖心。 我和他并不是最早成为朋友的，但是直到此刻我们都一向联系密切，我以前并不明白一个人对自我好是什么感觉，直到之后，只要想想他，就懂了一个人对自我好到底是什么感觉。 他并不是一个多话的人，他的话很少很少，其实说到底我并不明白当初我们为什么会成为朋友，更不清楚两种截然不一样性格的人怎样会做朋友这么久。 我跟他总是无话不谈，他从来不会反感我的喋喋不休，他总是默默地听着我说，在必要的时候恰到好处的给我推荐，直到此刻我养成了一种有事就会先去问问他的推荐的习惯。他从不嫌我烦，一次又一次回答我问的那些荒谬至极无聊到上天的问题，跟他在一齐我能够肆意妄为，或者说我从来都不担心他看穿我的骄傲做作下一秒就离我而去，在他那里我从来都是有什么说什么，不用思考那么多说话套路，我想怎样就怎样，从来都不用担心下一秒就被出卖，那是一种安心踏实的感觉。 有时候我都突然觉得他就是我的心灵支柱，他对我的好，我是真的感受得到。我也从他身上明白，一个人对你好到底是什么感觉。 每次我很无聊的时候就跟他打电话，谈话如下： “你干嘛呢？忙不忙？” “上班啊，不忙” “那我们聊五毛钱的天吧” “好啊” “那你在干嘛？” “没干嘛” “没干嘛是在干嘛” “和你说话啊” “和我说话干嘛”…… 这种类似无聊的问题我从来都会问很多遍，他每次都会耐心的一遍又一遍回答我，我闺蜜都说我好烦，但是他从来都没有表现出一丁点很烦的举动或者言辞。 或者说他的忍耐是无限度的…… 02 他真的很闲吗？ 每次我找他的时候，不管急事还是无聊，每次他都在。有时候我就会问他“你好闲啊，每次找你的时候你刚好都在”他总是会说“对啊，我很闲”…… 他真的很闲吗？ 他真的很忙。忙的什么程度呢？白天上班，晚上练车，用吃饭、下班的时间去做兼职，他每一天要五六点起床，他顶着大寒风，他感冒到那么严重都没去看病……他忙，这都是我无意之中明白的。 我记得很早有一次，我和朋友在外面嗨到半夜最后没有钱吃饭的时候，我们两个穷光蛋大眼瞪小眼，最后，我惋惜的和朋友往回走的时候给他发了一条消息，我真的很想吃串串，但是我身上只有一毛钱。因为是大半夜，我以为他睡了，过了一会他打电话过来，说钱已经给我转过去了，快去吃你的饭。然而第二天我才明白他当时是和朋友喝了酒，已经睡下了，在半醉半醒之间看到我的消息后立马给我打来电话的。 或许他都不记得这些件小事了，但是我一向记得，我很难想象得到他当时在醉意睡意双重状况下会打电话过来，这是下意识的举动，朋友对我说。 他做过很多件让我感动的小事。他总是这样感动到你鼻涕涕流，自我还一副不以为意的样貌。此生有他，对我来说真的是莫大的安慰。 你身边有没有这样一个人？ 他或许不会说好听的话，但他总是会默默地听你吐槽完所有的不愉快。 他或许很少主动联系你，但他总是会在你需要他的时候对你永远有空。 他或许不太会讲笑话不幽默，但他总能在你不开心的时候逗你笑逗你开心。 …… 他真的那么有耐心，他总能一遍又一遍的回答你的那些十万个为什么。 他真的很害羞，他总是一次又一次被你调侃之后就红了脸。 他真的很讲义气，他总是帮了你很多忙。 …… 我有。 03 ——愿意抽出时间来陪你的人，才是最爱你的人。舍得为你花时间的人，才是真正把你放到心上的人。 ——你要相信，如果一个人真的在乎你，即使他当时很忙，那他事后必须会再找你的，而绝不是你一找他，他就说忙，然后就没然后了。 ——只要你需要，我每时每刻都有空。 ——你找他，他一向都在。 我们总是会在不开心时找兄弟喝酒，他分分钟就会出现，失恋了找闺蜜谈心，她二话没说就到了你的眼前。我们都懂这种需要和被需要的温暖。 所以，也感谢他们，就是因为他们在你需要的时候一向有空，才让我们一向温暖。 其实，我一向都想对他说， “我真的很感谢你，是你让我明白一个人对自我好是什么感觉，是你一向以来不离不弃帮忙着我，也是你一向以来都让着我，尽管我的脾气真的很臭。而我也真的期望你好，你是我很重要的人，你永远都会是我的好哥们，我期望你幸福。” 如果你身边也有这么一个人，请你必须要好好珍惜，好好珍惜，好好珍惜，重要的话要说三遍。 愿你身边也有这么一个温暖的人~","tags":[{"name":"生活","slug":"生活","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"归纳解决浏览器兼容问题的三种方式","date":"2016-10-31T13:04:50.000Z","path":"2016/10/31/解决浏览器的三种方式/","text":"说到兼容性，是最让前端开发人员头痛的问题。同是一段代码，在不同的浏览器上显示的效果不同，轻者某些效果没有出来，重者乱成一锅粥。看着自己码了几天的代码到浏览器上却乱成一团，是不是突然之间感觉心很累。下面就兼容问题归纳了三种解决的方式，以后遇到了兼容性问题从这几个方面考虑就差不多了。 首先介绍下浏览器的两种模式也就是浏览器解析css的两种方式，quirks mode(怪异模式)和(标准模式static mode)，因为在早期各大浏览器厂商竞争，所以在浏览器解析页面时并未遵循W3C标准，但随着互联网的发展，W3C的标准越来越重要，现在大部分浏览器厂商都遵循W3C的标准，这种标准模式就称为，而以前的模式称为quirks mode，典型的就是IE7-。 对于上面的问题，我们有第一种方式： 一、代码或代码声明解决。 1、&lt;!DOCTYPE&gt;声明，它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令，规定了浏览器的解析模式，现在几乎忽略。 2、&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。例如360浏览器：&lt;meta name=”renderer” content=”webkit|ie-comp|ie-stand”&gt;可以指定360浏览器用哪种内核解析页面文档。例如IE浏览器：&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=IE8&quot;/&gt;可以指定IE浏览器用IE8的mode解析页面文档。 3、前后缀代码，对不同内核的浏览器在具体样式前加上该内核标志前缀，例如： 12345678display: flex;display: -webkit-box; /*兼容webkit内核浏览器，如chrome,safari*/display: -webkit-flex; /*兼容webkit内核浏览器，如chrome,safari*/display: -moz-box; /*兼容mozilla内核浏览器，如：Firefox*/display: -ms-flexbox; /*兼容Trident内核浏览器，如：IE*/ 其实css的hack也有类似的味道，且把它归到下面来讲。 二、工具插件解决。 1、ie7 – js中是一个JavaScript库（解决IE与W3C标准的冲突的JS库），使微软的Internet Explorer的行为像一个Web标准兼容的浏览器，支持更多的W3C标准，支持CSS2、CSS3选择器。它修复了许多的HTML和CSS问题，并使 得透明PNG在IE5、IE6下正确显示。例如：&lt;script src=”http://ie7-js.googlecode.com/svn/version/2.0(beta)/IE8.js” type=”text/javascript”&gt;&lt;/script&gt;，它有7/8/9三个版本，不过对了国内的网络环境，也可以几乎忽略。 2、css3pie是一个css3的样式生成工具，官方http://css3pie.com/，可以在里面设置你想要的css3样式，然后show css会显示很全的代码，可兼容firefox , ie6 , ie7 , ie8。","tags":[{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"}]},{"title":"IE bug兼容问题三——FBC","date":"2016-10-27T08:57:05.000Z","path":"2016/10/27/IE兼容FBC/","text":"BFC，块格式化上下文( Block formatting context )，是指初始化块级元素定义的环境。在CSS中，元素定义的环境有两种，一种是块格式化上下文( Block formatting context )，另一种是行内格式化上下文( Inline formatting context )。其中我们使用比较多的是块级可视化上下文，CSS3草案中将之称为“flow root”，但我们仍习惯叫BFC，其的触发条件如下： *浮动元素（float除了none） *绝对定位元素(absolute/fixed) *设置了’display’ 属性为 “inline-block”，”table-cell”， “table-caption” 的元素 *设置了overflow 非 “visible”的元素","tags":[{"name":"IE","slug":"IE","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/IE/"},{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"}]},{"title":"IE bug兼容问题二——hasLayout","date":"2016-10-27T08:47:55.000Z","path":"2016/10/27/IE兼容hasLayout/","text":"haslayout 是Windows Internet Explorer渲染引擎的一个内部组成部分。可以理解为一个专有的属性。很多的ie下的css bug都与其息息相关，因此我们需要取消hasLayout或者触发hasLayout来调节在InternetExplorer中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。为了调节这两个不同的概念，渲染引擎采用了 hasLayout 的属性，属性值可以为true或false。当一个元素的 hasLayout属性值为true时，我们说这个元素有一个布局（layout）。这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。 ①默认触发hasLayout的html元素 body , html table, tr, th, td img hr input, button, file, select, textarea, fieldset marquee frameset, frame, iframe objects, applets, embed ②触发hasLayout的条件 12345678910111213display: inline-blockheight: (除 auto 外任何值)width: (除 auto 外任何值)float: (left 或 right)position: absolutezoom: (除 normal 外任意值)writing-mode: tb-rl（专有属性） IE7特有的触发Layout的属性 123456789101112131415min-height: (任意值)min-width: (任意值)max-height: (除 none 外任意值)max-width: (除 none 外任意值)overflow: (除 visible 外任意值，仅用于块级元素)overflow-x: (除 visible 外任意值，仅用于块级元素)overflow-y: (除 visible 外任意值，仅用于块级元素)position: fixed 当网页在 IE 中有异常表现时，可以尝试激发 haslayout 来看看是不是问题所在。常用的方法是给某元素 css 设定 zoom:1。使用 zoom:1 是因为大多数情况下，它能在不影响现有环境的条件下激发元素的 haslayout。而一旦问题消失，那基本上就可以判断是haslayout 的原因。然后就可以通过设定相应的 css 属性来对这个问题进行修正了。建议首先要考虑的是设定元素的width/height 属性，其次再考虑其他属性。","tags":[{"name":"IE","slug":"IE","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/IE/"},{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"}]},{"title":"IE bug兼容问题一——hack","date":"2016-10-27T07:48:24.000Z","path":"2016/10/27/IE兼容CSSHack/","text":"由于不同的浏览器对CSS的解析认识不一样，比如IE 6,IE 7,Firefox等，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。我们最常用的就是这在一些css样式前面加上-webkit-、-moz-等。这个针对不同的浏览器写不同的CSS code的过程，就叫CSS hack,也叫写CSS hack。 ##各浏览器兼容标记 标签IE 6IE 7IE 8FirefoxOperaSarari-√ &nbsp;&nbsp;&nbsp;&nbsp;*√√&nbsp;&nbsp;&nbsp;&nbsp;*+&nbsp;√&nbsp;&nbsp;&nbsp;&nbsp;\\9 或 .√√√&nbsp;&nbsp;&nbsp;\\0&nbsp;&nbsp;√&nbsp;√&nbsp;@-moz-document url-prefix(){样式}&nbsp;&nbs√","tags":[{"name":"IE","slug":"IE","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/IE/"},{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"}]},{"title":"360浏览器的兼容问题","date":"2016-10-27T05:26:40.000Z","path":"2016/10/27/360浏览器兼容/","text":"由于众所周知的情况，国内的主流浏览器都是双核浏览器：基于Webkit内核用于常用网站的高速浏览。基于IE的内核用于兼容网银、旧版网站。以360的几款浏览器为例，我们优先通过Webkit内核渲染主流的网站，只有小量的网站通过IE内核渲染，以保证页面兼容。在过去很长一段时间里，我们主要的控制手段是一个几百k大小网址库，一个通过长期人工运营收集的网址库。 尽管我们努力通过用户反馈、代码标签智能判断技术提高浏览器的自动切核准确率。但是在很多情况下，我们仍然无法达到百份百正确。因此，我们新增加了一个控制手段：内核控制Meta标签。只要你在自己的网站里增加一个Meta标签，告诉360浏览器这个网址应该用哪个内核渲染，哪么360浏览器就会在读取到这个标签后，立即切换对应的内核。并将这个行为应用于这个二级域名下所有网址。 目前该功能已经在所有的360安全浏览器实现。我们也建议其它浏览器厂商一起支持这个实现。让这个控制标签成为行业标准。 代码示例 在head标签中添加一行代码： 1234 &lt;meta name=”renderer” content=”webkit|ie-comp|ie-stand”&gt;&lt;/head&gt; content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 若页面需默认用极速核，增加标签：&lt;metaname=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 若页面需默认用ie兼容内核，增加标签：&lt;metaname=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; 若页面需默认用ie标准内核，增加标签：&lt;metaname=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; ##各渲染内核的技术细节 内核 Webkit IE兼容 IE标准 文档模式 Chrome 21 IE6/7 IE9/IE10/IE11(取决于用户的IE) HTML5支持 YES NO YES ActiveX控件支持 NO YES YES 360浏览器内核控制标签mate说明","tags":[{"name":"兼容","slug":"兼容","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/%E5%85%BC%E5%AE%B9/"},{"name":"meta","slug":"meta","permalink":"https://github.com/joydezhong/joydezhong.github.io.git/tags/meta/"}]}]